<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kubernetes中的容器日志路径目录</title>
      <link href="/post/c7ce75fa.html"/>
      <url>/post/c7ce75fa.html</url>
      
        <content type="html"><![CDATA[<h2 id="容器日志文件路径"><a href="#容器日志文件路径" class="headerlink" title="容器日志文件路径"></a>容器日志文件路径</h2><p>本文大概介绍kubernetes集群中POD容器日志存储位置及把运行日志记录至文件 ，主要包括标准输出日志，容器内文件日志，以及其他持久卷存储位置路径等，仅供参考</p><blockquote><p>环境：</p><p>1，TKE集群</p><p>2，容器目录和kubelet目录都是默认配置</p><p>声明：以下仅个人经验总结，如果有不对的地方勿喷</p></blockquote><h2 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h2><p>各种容器运行时都提供了对容器标准输出的处理。腾讯云TKE目前支持两种容器运行时——<strong>docker</strong>和<strong>containerd</strong>。</p><p>docker:</p><blockquote><p>真实路径：&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;$CONTAINERID<br>软连接：kubelet会在&#x2F;var&#x2F;log&#x2F;pods和&#x2F;var&#x2F;log&#x2F;containers创建软连接指向&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;$CONTAINERID<br>配置文件：&#x2F;etc&#x2F;docker&#x2F;daemon.json<br>参数：<br>“log-driver”: “json-file”,<br>“log-level”: “warn”,<br>“log-opts”: {<br> “max-file”: “10”,<br> “max-size”: “100m”<br>},</p></blockquote><p>containerd :</p><blockquote><p>日志存储路径：<br>真实路径：&#x2F;var&#x2F;log&#x2F;pods&#x2F;$CONTAINER_NAMES<br>软连接：同时kubelet也会在&#x2F;var&#x2F;log&#x2F;containers目录下创建软链接指向    &#x2F;var&#x2F;log&#x2F;pods&#x2F;$CONTAINER_NAMES<br>日志配置参数：<br>配置文件：&#x2F;etc&#x2F;kubernetes&#x2F;kubelet<br>kubelet配置参数:<br>–container-log-max-files&#x3D;5 <br>–container-log-max-size&#x3D;“100Mi” <br>–logging-format&#x3D;“json” \</p></blockquote><h3 id="docker运行时标准输出日志"><a href="#docker运行时标准输出日志" class="headerlink" title="docker运行时标准输出日志"></a>docker运行时标准输出日志</h3><p>如果Docker作为K8S容器运行时，容器日志的落盘将由docker来完成，处理的方式是logging driver，docker支持多种logging drivers，可以将日志以特定的格式输出到不同的目标，保存在&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;<container-id> 目录下。Kubelet 会在 &#x2F;var&#x2F;log&#x2F;pods 和 &#x2F;var&#x2F;log&#x2F;containers 下面建立软链接，指向 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;<container-id> 该目录下的容器日志文件</p><p>TKE docker节点使用的logging driver是json-file，会将容器的<strong>标准输出</strong>以 json 的格式写到宿主机的文件里，文件路径为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/var/lib/docker/containers/&lt;container-id&gt;/&lt;container-id&gt;-json.log  <span class="hljs-comment">#其中容器ID可以通过下面命令查询</span><br></code></pre></td></tr></table></figure><p>批量查下集群里面容器conatiner ID：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl get pods -o custom-columns=podName:.metadata.name,podIP:.status.podIP,podStatus:.status.phase,nodeName:.spec.nodeName,nodeIP:.status.hostIP,containerID:.status.containerStatuses[0].containerID | awk -F <span class="hljs-string">&#x27;docker://|| containerd://&#x27;</span>  <span class="hljs-string">&#x27;&#123;print $1,$2&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="containerd运行时标准输出日志"><a href="#containerd运行时标准输出日志" class="headerlink" title="containerd运行时标准输出日志"></a>containerd运行时标准输出日志</h3><p>如果Containerd作为K8 容器运行时， 容器标准输出日志的落盘由 Kubelet 来完成，保存至 &#x2F;var&#x2F;log&#x2F;pods 目录下，同时在 &#x2F;var&#x2F;log&#x2F;containers 目录下创建软链接，指向日志文件</p><p>文件路径为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/var/log/pods/&lt;namespace&gt;_&lt;pod-name&gt;_&lt;pod-uid&gt;/&lt;container-name&gt;/0.log<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202212111839189.png" alt="1668063911037"></p><p>批量查询集群POD的uid</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl get pods -o custom-columns=Namespace:..metadata.namespace,podName:.metadata.name,podIP:.status.podIP,podStatus:.status.phase,nodeIP:.status.hostIP,Pod_ID:.metadata.uid,ContainerName:.spec.containers[*].name<br></code></pre></td></tr></table></figure><h3 id="kubelet处理运行时日志"><a href="#kubelet处理运行时日志" class="headerlink" title="kubelet处理运行时日志"></a>kubelet处理运行时日志</h3><p>无论使用那种容器运行时，kubelet都会在目录“&#x2F;var&#x2F;log&#x2F;containers”和“&#x2F;var&#x2F;log&#x2F;pods”下创建指向容器标准输出日志文件（目录）的软链接，文件路径如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/var/log/containers/&lt;pod_name&gt;_&lt;pod_namespace&gt;_&lt;container_name&gt;-&lt;container_id&gt;.log<br><br>/var/log/pods/&lt;namespace&gt;_&lt;pod_name&gt;_&lt;pod_uid&gt;/&lt;container_name&gt;/0.log<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202212111839400.png" alt="1659871831763"></p><h2 id="容器文件路径"><a href="#容器文件路径" class="headerlink" title="容器文件路径"></a>容器文件路径</h2><p>容器中的文件路径，是相对于容器的文件系统而言。容器中的文件日志也是落在宿主机node节点上的，可以通过宿主机目录查看到对应文件信息</p><h3 id="没有挂载数据卷的目录"><a href="#没有挂载数据卷的目录" class="headerlink" title="没有挂载数据卷的目录"></a>没有挂载数据卷的目录</h3><p>在这种情况下，可以根据storage driver（例如：aufs、overlay2）以及容器运行时（docker、containerd），查看容器根目录在宿主机上的挂载点，再根据日志文件在容器文件系统中的路径，找到日志文件在宿主机上的位置。 目前TKE节点主要安装的操作系统是ubuntu、CentOS和tlinux，使用的storage driver为 aufs或者overlay2。 获取容器根目录挂载点的方法如下：</p><h4 id="docker运行时"><a href="#docker运行时" class="headerlink" title="docker运行时"></a>docker运行时</h4><table><thead><tr><th align="left"></th><th align="left">容器根目录在宿主机的挂载点</th><th align="left">如何查看id</th></tr></thead><tbody><tr><td align="left">aufs</td><td align="left">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;aufs&#x2F;mnt&#x2F;<id></td><td align="left">cat &#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;aufs&#x2F;layerdb&#x2F;mounts&#x2F;<container-id>&#x2F;mount-id</td></tr><tr><td align="left">overlay2</td><td align="left">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;<id>&#x2F;merged</td><td align="left">cat &#x2F;var&#x2F;lib&#x2F;docker&#x2F;image&#x2F;overlay2&#x2F;layerdb&#x2F;mounts&#x2F;<container-id>&#x2F;mount-id</td></tr></tbody></table><p>查询示例：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-249-47-tlinux ~]<span class="hljs-comment"># kubectl get pods -o custom-columns=podName:.metadata.name,podIP:.status.podIP,podStatus:.status.phase,nodeName:.spec.nodeName,nodeIP:.status.hostIP,containerID:.status.containerStatuses[0].containerID | awk -F &#x27;docker://|| containerd://&#x27;  &#x27;&#123;print $1,$2&#125;&#x27;   | grep nginx</span><br>nginx-0                         10.200.0.10   Running     172.30.249.47   172.30.249.47    a0d96814caa6248996dcbcea552fa5f405143500f417a764160010018411f368    <span class="hljs-comment">#容器ID</span><br><br>[root@VM-249-47-tlinux ~]<span class="hljs-comment"># cat /var/lib/docker/image/overlay2/layerdb/mounts/a0d96814caa6248996dcbcea552fa5f405143500f417a764160010018411f368/mount-id</span><br>dfdb4b151beca3e68047e748f2832a5acd04161beb4088ca454e7bdf0bdd7aa4<br><br>[root@VM-249-47-tlinux ~]<span class="hljs-comment"># cd /var/lib/docker/overlay2/dfdb4b151beca3e68047e748f2832a5acd04161beb4088ca454e7bdf0bdd7aa4/merged</span><br>[root@VM-249-47-tlinux /var/lib/docker/overlay2/dfdb4b151beca3e68047e748f2832a5acd04161beb4088ca454e7bdf0bdd7aa4/merged]<span class="hljs-comment"># ls </span><br>bin  boot  dev  docker-entrypoint.d  docker-entrypoint.sh  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202212111839568.png" alt="1659872541684"></p><p>容器的根目录在宿主机上的挂载点</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202212111839396.png" alt="1659873211290"></p><h4 id="容器的存储ID找到对应的容器ID和镜像ID"><a href="#容器的存储ID找到对应的容器ID和镜像ID" class="headerlink" title="容器的存储ID找到对应的容器ID和镜像ID"></a>容器的存储ID找到对应的容器ID和镜像ID</h4><p>1，进入overlay2目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/lib/docker/overlay2<br><br>如果遇到日志处理时候可以查看1G以上的文件大小：<span class="hljs-built_in">du</span> -sh * |grep ‘G’ | <span class="hljs-built_in">sort</span><br></code></pre></td></tr></table></figure><p>2，查看占用空间的pid，以及对应的容器名称</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker ps -q | xargs docker inspect --format ‘&#123;&#123;.State.Pid&#125;&#125;,&#123;&#123;.Name&#125;&#125;,&#123;&#123;.GraphDriver.Data.WorkDir&#125;&#125;’ | grep 4d79558c06c01e7b078cf1829676a06f615371953b15b104cb83d94d4f9c2c43<br><br>如果运行的容器没有，可以在镜像里面查下<br>docker inspect -f $<span class="hljs-string">&#x27;&#123;&#123;.RepoTags&#125;&#125;\t&#123;&#123;.GraphDriver.Data.LowerDir&#125;&#125;&#x27;</span> $(docker images -q)  | grep 4d79558c06c01e7b078cf1829676a06f615371953b15b104cb83d94d4f9c2c43<br></code></pre></td></tr></table></figure><h4 id="containerd运行时"><a href="#containerd运行时" class="headerlink" title="containerd运行时"></a>containerd运行时</h4><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/run/containerd/io.containerd.runtime.v1.linux/k8s.io/&lt;container-id&gt;/rootfs<br><br>/run/containerd/io.containerd.runtime.v2.task/k8s.io/&lt;container-id&gt;/rootfs  <span class="hljs-comment">#最新containerd运行时目录</span><br></code></pre></td></tr></table></figure><p>可以看到，容器根目录在宿主机的挂在点取决于容器的标识（id或者container-id）。</p><blockquote><p> 在默认配置&#x2F;etc&#x2F;containerd&#x2F;config.toml 中还有两个关于存储的配置路径 :</p><p> root &#x3D; “&#x2F;var&#x2F;lib&#x2F;containerd” state &#x3D; “&#x2F;run&#x2F;containerd” </p><p> 其中 root 是用来保存持久化数据，包括 Snapshots, Content, Metadata 以及各种插件的数据，每一个插件都有自己单独的目录，Containerd 本身不存储任何数据，它的所有功能都来自于已加载的插件。</p><p> 而另外的 state 是用来保存运行时的临时数据的，包括 sockets、pid、挂载点、运行时状态以及不需要持久化的插件数据。</p></blockquote><p>则容器里面的文件日志路径，可以通过宿主机的挂在点获取到，</p><table><thead><tr><th align="left">容器中路径</th><th align="left">宿主机路径(docker + overlay2)</th></tr></thead><tbody><tr><td align="left">&#x2F;data&#x2F;logs&#x2F;nginx.log</td><td align="left">&#x2F;run&#x2F;containerd&#x2F;io.containerd.runtime.v2.task&#x2F;k8s.io&#x2F;0b895cd3a0fb017337df1796530904b0185db7469f442b9413333f4c8c878fee&#x2F;rootfs&#x2F;data&#x2F;logs&#x2F;test.log</td></tr></tbody></table><h3 id="挂载数据卷的目录日志"><a href="#挂载数据卷的目录日志" class="headerlink" title="挂载数据卷的目录日志"></a>挂载数据卷的目录日志</h3><p>TKE支持以下几种挂载卷类型</p><h4 id="hostpath"><a href="#hostpath" class="headerlink" title="hostpath"></a>hostpath</h4><p>hostpath的处理比较简单，直接查看POD所在节点的挂载路径日志</p><h4 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h4><p>emptyDir卷在宿主机上的路径为:</p><p>kubelet root-dir的默认值：&#x2F;var&#x2F;lib&#x2F;kubelet</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;kubelet root-dir&gt;/pods/&lt;pod uid&gt;/volumes/kubernetes.io~empty-dir/&lt;volume name&gt;<br></code></pre></td></tr></table></figure><h4 id="腾讯云CBS-x2F-CFS"><a href="#腾讯云CBS-x2F-CFS" class="headerlink" title="腾讯云CBS&#x2F;CFS"></a>腾讯云CBS&#x2F;CFS</h4><p>cbs持久化卷在宿主机上的路径为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#&lt;kubelet root-dir&gt;/pods/&lt;pod uid&gt;/volumes/kubernetes.io~qcloud-cbs/&lt;volume name&gt;/mount  #qcloud-cbs类型的CBS</span><br><br><span class="hljs-comment">#container节点和docker运行节点一样</span><br><span class="hljs-comment"># &lt;kubelet root-dir&gt;/plugins/kubernetes.io/csi/pv/&lt;pvc-name&gt;/globalmount    #cbs-csi类型的CBS</span><br>/var/lib/kubelet/plugins/kubernetes.io/csi/pv/pvc-a8c018b1-6e93-41e2-b620-9585d46d3619/globalmount<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202212111941327.png" alt="image-20221211194126209"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202212111951177.png" alt="image-20221211195129123"></p><p>cfs持久化卷在宿主机上的路径为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#&lt;kubelet root-dir&gt;/pods/&lt;pod uid&gt;/volumes/kubernetes.io~csi/&lt;pv name&gt;/mount</span><br><br>/var/lib/kubelet/pods/4f65675c-ead4-4d75-b1b9-89784a332cf4/volumes/kubernetes.io~csi/pvc-24b1a5c5-f59a-4c5e-8ea8-bad84bacf9df/mount<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202212112003529.png" alt="image-20221211200303472"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202212112004478.png" alt="image-20221211200418423"></p><blockquote><p>验证，如果是一个CFS类型的PVC挂载不同的POD上，节点上只有一个挂载点，</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes中的cgroup Killed问题</title>
      <link href="/post/dcec15df.html"/>
      <url>/post/dcec15df.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>环境：</p><p>1，腾讯云TKE集群</p><p>2，CVM节点 内核：tlinux 4.14.105-19-0024</p><p>3，容器目录和kubelet目录默认设置</p></blockquote><p><strong>Cgroup OOM原因</strong></p><p>一般是由于容器的内存实际使用量超过了容器内存限制值limit而导致的事件。比如容器的内存限制值配置了1Gi，而容器的内存随着容器内进程内存使用量的增加超过了1Gi，就会导致容器被操作系统Cgroup Kill。发生容器被Kill之后，容器已经被停止，所以后续会出现应用实例被重启的情况</p><p><strong>解决方案</strong></p><p>检查容器内进程是否有内存泄漏问题，同时适当调整容器内存的限制值limit大小。可以结合应用监控来看变化趋势。需要注意的是，容器内存限制值大小不应该过大，否则可能导致极端资源争抢情况下，容器被迫驱逐的问题。 </p><p><strong>oom score</strong></p><p>在遇到较高内存使用压力时，Linux 内核会杀掉一些不太重要的进程，腾出空间保障系统正常运行。它会给每个进程（<code>/proc/$pid/oom_score</code>）分配一个得分（<code>oom_score</code>），分数越高，被 OOM 的概率就越大。 <strong>这个参数本身只反映该进程的可用资源在系统中所占的百分比，并没有“该进程有多重要”的概念</strong> </p><p>在kubernetes中各个POD之间资源是通过cgroup进行资源隔离，查看POD cgroup相关信息，登录POD所在节点，执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>  /sys/fs/cgroup/memory/kubepods/burstable/pod[pod的uuid]    <span class="hljs-comment">#uuid可以通过下面命令查询</span><br><br>示例：<br><span class="hljs-built_in">cd</span> /sys/fs/cgroup/memory/kubepods/burstable/pod7b5d76c8-a37b-4f1c-8db9-383017063244<br></code></pre></td></tr></table></figure><p>查下集群POD的uuid（根据具体情况可以根据命名空间查询）</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl get pods -o custom-columns=Namespace:..metadata.namespace,podName:.metadata.name,podIP:.status.podIP,podStatus:.status.phase,nodeIP:.status.hostIP,Pod_ID:.metadata.uid,ContainerName:.spec.containers[*].name<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202212111709485.png" alt="1668051091904"></p><p>当POD发生OOM时候，可以查看dmesg日志：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">dmesg  | grep -A  20  7b5d76c8-a37b-4f1c-8db9-38301706324<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202212111710803.png" alt="1668051203724"></p><p><strong>如何通过oom kill日志反查对应的容器</strong></p><p>通过dmesg日志查到 有如下oom 信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">dmesg  | grep -A  20 -i  killed<br></code></pre></td></tr></table></figure><p>日志如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[198542.576728] Task <span class="hljs-keyword">in</span> /kubepods/burstable/pod0f5eb28f-6722-4cf5-ab0f-b62748c018d4/0dc1822caf9e150de25daa1cf572418426ce6b72757b5efdff52acef348368a3 killed as a result of <span class="hljs-built_in">limit</span> of /kubepods/burstable/pod0f5eb28f-6722-4cf5-ab0f-b62748c018d4<br>[198542.576733] memory: usage 122880kB, <span class="hljs-built_in">limit</span> 122880kB, failcnt 83<br>[198542.576734] memory+swap: usage 122880kB, <span class="hljs-built_in">limit</span> 9007199254740988kB, failcnt 0<br>[198542.576734] kmem: usage 0kB, <span class="hljs-built_in">limit</span> 9007199254740988kB, failcnt 0<br>[198542.576735] Memory cgroup stats <span class="hljs-keyword">for</span> /kubepods/burstable/pod0f5eb28f-6722-4cf5-ab0f-b62748c018d4: cache:0KB rss:0KB rss_huge:0KB shmem:0KB mapped_file:0KB dirty:0KB writeback:0KB swap:0KB inactive_anon:0KB active_anon:0KB inactive_file:0KB active_file:0KB unevictable:0KB<br></code></pre></td></tr></table></figure><p>可以查到POD的uuid：0f5eb28f-6722-4cf5-ab0f-b62748c018d4</p><p>通过kubelet 日志或者message日志过滤该uid</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">journalctl -u kubelet | grep <span class="hljs-string">&quot;0f5eb28f-6722-4cf5-ab0f-b62748c018d4&quot;</span> <span class="hljs-comment">#POD uuid</span><br></code></pre></td></tr></table></figure><p>日志如下，可以看到具体POD信息 包括POD名称和所在namespace</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Dec 11 17:29:21 VM-249-96-tlinux kubelet[10264]: E1211 17:29:21.519957   10264 pod_workers.go:191] Error syncing pod 0f5eb28f-6722-4cf5-ab0f-b62748c018d4 (<span class="hljs-string">&quot;memory-request-limit-54ff657644-wm7pj_default(0f5eb28f-6722-4cf5-ab0f-b62748c018d4)&quot;</span>), skipping: failed to <span class="hljs-string">&quot;StartContainer&quot;</span> <span class="hljs-keyword">for</span> <span class="hljs-string">&quot;memory-demo-ctr&quot;</span> with CrashLoopBackOff: <span class="hljs-string">&quot;back-off 5m0s restarting failed container=memory-demo-ctr pod=memory-request-limit-54ff657644-wm7pj_default(0f5eb28f-6722-4cf5-ab0f-b62748c018d4)&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过环境变量将POD信息呈现给容器</title>
      <link href="/post/6c58efa9.html"/>
      <url>/post/6c58efa9.html</url>
      
        <content type="html"><![CDATA[<p>本文通过环境变量将 Pod 信息呈现给容器</p><h2 id="用-Pod-字段作为环境变量的值"><a href="#用-Pod-字段作为环境变量的值" class="headerlink" title="用 Pod 字段作为环境变量的值"></a>用 Pod 字段作为环境变量的值</h2><p>这个配置文件中，你可以看到五个环境变量。<code>env</code> 字段是一个 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.22/#envvar-v1-core">EnvVars</a>. 对象的数组。 数组中第一个元素指定 <code>MY_NODE_NAME</code> 这个环境变量从 Pod 的 <code>spec.nodeName</code> 字段获取变量值。 同样，其它环境变量也是从 Pod 的字段获取它们的变量值。</p><p><strong>说明：</strong> 本示例中的字段是 Pod 字段，不是 Pod 中 Container 的字段。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  labels:<br>    k8s-app: dapi-envars-fieldref<br>  name: dapi-envars-fieldref<br>  namespace: default<br>spec:<br>  selector:<br>    matchLabels:<br>      k8s-app: dapi-envars-fieldref<br>  template:<br>    metadata:<br>      labels:<br>        k8s-app: dapi-envars-fieldref<br>    spec:<br>      containers:<br>      - args:<br>        - while true; do echo -en &#x27;\n&#x27;; printenv MY_NODE_NAME MY_POD_NAME MY_POD_NAMESPACE; printenv MY_POD_IP MY_POD_SERVICE_ACCOUNT; sleep 10;done;<br>        command:<br>        - sh<br>        - -c<br>        env:<br>        - name: MY_NODE_NAME<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: spec.nodeName<br>        - name: MY_POD_NAME<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: metadata.name<br>        - name: MY_POD_NAMESPACE<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: metadata.namespace<br>        - name: MY_POD_IP<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: status.podIPs<br>        - name: MY_POD_SERVICE_ACCOUNT<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: spec.serviceAccountName<br>        image: busybox<br>        imagePullPolicy: IfNotPresent<br>        name: dapi-envars-fieldref<br>        resources: &#123;&#125;<br><br></code></pre></td></tr></table></figure><h2 id="用-Container-字段作为环境变量的值"><a href="#用-Container-字段作为环境变量的值" class="headerlink" title="用 Container 字段作为环境变量的值"></a>用 Container 字段作为环境变量的值</h2><p>前面的练习中，你将 Pod 字段作为环境变量的值。 接下来这个练习中，你将用 Container 字段作为环境变量的值。这里是包含一个容器的 Pod 的配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  labels:<br>    k8s-app: dapi-envars-container<br>  name: dapi-envars-container<br>  namespace: default<br>spec:<br>  replicas: 1<br>  selector:<br>    matchLabels:<br>      k8s-app: dapi-envars-container<br>  template:<br>    metadata:<br>      labels:<br>        k8s-app: dapi-envars-container<br>    spec:<br>      containers:<br>      - args:<br>        - while true; do  echo -en &#x27;\n&#x27;; printenv MY_CPU_REQUEST MY_CPU_LIMIT;printenv MY_MEM_REQUEST MY_MEM_LIMIT;sleep 10;done;<br>        command:<br>        - sh<br>        - -c<br>        env:<br>        - name: MY_CPU_REQUEST<br>          valueFrom:<br>            resourceFieldRef:<br>              containerName: test-container<br>              divisor: &quot;1&quot;<br>              resource: requests.cpu<br>        - name: MY_CPU_LIMIT<br>          valueFrom:<br>            resourceFieldRef:<br>              containerName: test-container<br>              divisor: &quot;1&quot;<br>              resource: limits.cpu<br>        - name: MY_MEM_REQUEST<br>          valueFrom:<br>            resourceFieldRef:<br>              containerName: test-container<br>              divisor: &quot;1&quot;<br>              resource: requests.memory<br>        - name: MY_MEM_LIMIT<br>          valueFrom:<br>            resourceFieldRef:<br>              containerName: test-container<br>              divisor: &quot;1&quot;<br>              resource: limits.memory<br>        image: busybox:1.24<br>        imagePullPolicy: IfNotPresent<br>        name: test-container<br>        resources:<br>          limits:<br>            cpu: 200m<br>            memory: 128Mi<br>          requests:<br>            cpu: 100m<br>            memory: 64Mi<br><br><br></code></pre></td></tr></table></figure><p>这个配置文件中，你可以看到四个环境变量。<code>env</code> 字段是一个 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.22/#envvar-v1-core">EnvVars</a>. 对象的数组。数组中第一个元素指定 <code>MY_CPU_REQUEST</code> 这个环境变量从 Container 的 <code>requests.cpu</code> 字段获取变量值。同样，其它环境变量也是从 Container 的字段获取它们的变量值。</p><p><strong>说明：</strong> 本例中使用的是 Container 的字段而不是 Pod 的字段。</p><h2 id="通过文件将-Pod-信息呈现给容器"><a href="#通过文件将-Pod-信息呈现给容器" class="headerlink" title="通过文件将 Pod 信息呈现给容器"></a>通过文件将 Pod 信息呈现给容器</h2><p>此页面描述 Pod 如何使用 DownwardAPIVolumeFile 把自己的信息呈现给 Pod 中运行的容器。 DownwardAPIVolumeFile 可以呈现 Pod 的字段和容器字段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  labels:<br>    k8s-app: kubernetes-downwardapi-volume-example<br>  name: kubernetes-downwardapi-volume-example<br>  namespace: default<br>spec:<br>  selector:<br>    matchLabels:<br>      k8s-app: kubernetes-downwardapi-volume-example<br>  template:<br>    metadata:<br>      labels:<br>        k8s-app: kubernetes-downwardapi-volume-example<br>    spec:<br>      containers:<br>      - args:<br>        - while true; do if [[ -e /etc/podinfo/labels ]]; then  echo -en &#x27;\n\n&#x27;; cat /etc/podinfo/labels; fi; if [[ -e /etc/podinfo/annotations ]]; then echo -en &#x27;\n\n&#x27;; cat /etc/podinfo/annotations; fi; sleep 5;done;<br>        command:<br>        - sh<br>        - -c<br>        image: busybox<br>        imagePullPolicy: IfNotPresent<br>        name: client-container<br>        resources: &#123;&#125;<br>        volumeMounts:<br>        - name: podinfo<br>          mountPath: /etc/podinfo<br>      volumes:<br>      - name: podinfo<br>        downwardAPI:<br>          items:<br>            - path: &quot;labels&quot;<br>              fieldRef:<br>                fieldPath: metadata.labels<br>            - path: &quot;annotations&quot;<br>              fieldRef:<br>                fieldPath: metadata.annotations<br></code></pre></td></tr></table></figure><h2 id="Downward-API支持的常用字段"><a href="#Downward-API支持的常用字段" class="headerlink" title="Downward API支持的常用字段"></a>Downward API支持的常用字段</h2><p><strong>1，使用fieldRef可以声明使用:</strong></p><p>spec.nodeName - 宿主机名字</p><p>status.hostIP - 宿主机IP</p><p>metadata.name - Pod的名字</p><p>metadata.namespace - Pod的Namespace</p><p>status.podIP - Pod的IP</p><p>spec.serviceAccountName - Pod的Service Account的名字</p><p>metadata.uid - Pod的UID</p><p>metadata.labels[‘<KEY>‘] - 指定<KEY>的Label值</p><p>metadata.annotations[‘<KEY>‘] - 指定<KEY>的Annotation值</p><p>metadata.labels - Pod的所有Label</p><p>metadata.annotations - Pod的所有Annotation</p><p><strong>2，使用resourceFieldRef可以声明使用:</strong></p><p>limits.cpu-容器的CPU limit </p><p>requests.cpu-容器的CPU request</p><p>limits.memory-容器的memory limit</p><p>requests.memory容器的memory request</p><p>完整示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  labels:<br>    k8s-app: centos-env<br>    qcloud-app: centos-env<br>  name: centos-env<br>spec:<br>  selector:<br>    matchLabels:<br>      k8s-app: centos-env<br>  template:<br>    metadata:<br>      annotations:<br>        description: ddd<br>      labels:<br>        k8s-app: centos-env<br>        qcloud-app: centos-env<br>    spec:<br>      containers:<br>      - env:<br>        - name: pod-name<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: metadata.name<br>        - name: pod-namespacce<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: metadata.namespace<br>        - name: pod-labels<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: metadata.labels[&#x27;k8s-app&#x27;]<br>        - name: pod-annotations<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: metadata.annotations[&#x27;description&#x27;]<br>        - name: pod-uid<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: metadata.uid<br>        - name: pod-nodename<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: spec.nodeName<br>        - name: pod-hostIP<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: status.hostIP<br>        - name: pod-podIP<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: status.podIP<br>        - name: pod-serviceAccountName<br>          valueFrom:<br>            fieldRef:<br>              apiVersion: v1<br>              fieldPath: spec.serviceAccountName<br>        image: ccr.ccs.tencentyun.com/chenjingwei/centos:latest<br>        imagePullPolicy: IfNotPresent<br>        name: centos-1<br>        resources:<br>          limits:<br>            cpu: 25m<br>            memory: 64Mi<br>          requests:<br>            cpu: 25m<br>            memory: 64Mi<br>        volumeMounts:<br>        - mountPath: /etc/podinfo<br>          name: podinfo<br>          readOnly: false<br>      imagePullSecrets:<br>      - name: qcloudregistrykey<br>      volumes:<br>      - name: podinfo<br>        projected:<br>          sources:<br>          - downwardAPI:<br>              items:<br>                - path: &quot;labels&quot;<br>                  fieldRef:<br>                    fieldPath: metadata.labels<br>                - path: &quot;annotations&quot;<br>                  fieldRef:<br>                    fieldPath: metadata.annotations<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TKE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> TKE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx-Ingress实现gRPC服务访问</title>
      <link href="/post/450ae69a.html"/>
      <url>/post/450ae69a.html</url>
      
        <content type="html"><![CDATA[<p>这里验证下如何通过Ingress-NGINX控制器将流量路由到gRPC服务</p><blockquote><p>前提条件：</p><p>1，已创建或者自建kubernetes集群</p><p>2，已经申请对应域名</p><p>3，已安装了ingress-nginx-controller</p><p>4，GRPC服务 可以使用<a href="https://github.com/grpc/grpc-go/blob/91e0aeb192456225adf27966d04ada4cf8599915/examples/features/reflection/server/main.go">go-grpc-greeter-server</a>作为示例</p><p>5，和域名对应的SSL证书</p></blockquote><h2 id="部署gRPC应用"><a href="#部署gRPC应用" class="headerlink" title="部署gRPC应用"></a>部署gRPC应用</h2><p>确保gRPC应用程序正在运行并监听连接，本示例使用镜像<code>ccr.ccs.tencentyun.com/v_cjweichen/grpc-server:latest</code>创建gRPC服务</p><p>复制以下YAML内容创建grpc.yaml文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">grpc-service</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">nginx-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">grpc-service</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">grpc-service</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">ccr.ccs.tencentyun.com/chenjingwei/grpc-server:latest</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">grpc-service</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">50051</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">imagePullSecrets:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">qcloudregistrykey</span> <br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Always</span><br></code></pre></td></tr></table></figure><h2 id="为gRPC应用创建Service"><a href="#为gRPC应用创建Service" class="headerlink" title="为gRPC应用创建Service"></a>为gRPC应用创建Service</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">grpc-service</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">grpc-service</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">50051</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">50051</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">grpc-service</span><br>  <span class="hljs-attr">sessionAffinity:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br></code></pre></td></tr></table></figure><p>执行以下命令查看Pod</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-16-tlinux ~/grpc]<span class="hljs-comment"># kubectl  get pods,svc -o wide</span><br>NAME                                READY   STATUS    RESTARTS   AGE     IP           NODE        NOMINATED NODE   READINESS GATES<br>pod/grpc-service-5d48b78787-hcfhf   1/1     Running   0          3m57s   172.16.0.5   10.0.0.16   &lt;none&gt;           &lt;none&gt;<br><br>NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)     AGE     SELECTOR<br>service/grpc-service   ClusterIP   172.16.255.180   &lt;none&gt;        50051/TCP   2m41s   run=grpc-service<br></code></pre></td></tr></table></figure><h2 id="为gRPC应用创建ingress路由"><a href="#为gRPC应用创建ingress路由" class="headerlink" title="为gRPC应用创建ingress路由"></a>为gRPC应用创建ingress路由</h2><p>复制以下YAML内容创建grpc-ingress.yaml文件。</p><blockquote><p><strong>注意</strong></p><ul><li>部署gRPC服务所使用的Ingress需要在<strong>annotation</strong>中加入<code>nginx.ingress.kubernetes.io/backend-protocol</code>，值为<strong>GRPC</strong>。</li><li>本示例使用的域名为<code>grpc.example.com</code>，请根据实际情况修改。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: networking.k8s.io/v1beta1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    kubernetes.io/ingress.class: nginx<br>    nginx.ingress.kubernetes.io/backend-protocol: GRPC   # 注意这里：必须要配置以指明后端服务为gRPC服务<br>  name: grpc-ingress<br>  namespace: default<br>spec:<br>  rules:<br>  - host: grpc.chen1900s.cn<br>    http:<br>      paths:<br>      - backend:<br>          serviceName: grpc-service<br>          servicePort: 50051<br>        path: /<br>        pathType: ImplementationSpecific<br>  tls:<br>  - hosts:<br>    - grpc.chen1900s.cn<br>    secretName: grpc-secret<br><br></code></pre></td></tr></table></figure><h2 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h2><p>一旦我们将配置应用到Kubernetes上，就该测试我们是否可以实际与后端通信了。为此，我们将使用grpcurl实用测试程序:</p><p>需要提前安装grpcurl工具，grpcurl是Go语言开源社区开发的工具，需要手工安装：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">wget https://github.com/fullstorydev/grpcurl/releases/download/v1.7.0/grpcurl_1.7.0_linux_x86_64.tar.gz<br>tar -xvf grpcurl_1.7.0_linux_x86_64.tar.gz<br>chmod +x grpcurl<br>./grpcurl -help<br></code></pre></td></tr></table></figure><p>本示例中使用域名<code>grpc.chen1900s.cn</code>以及自签证书，执行以下命令验证请求是否成功转发到后端服务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">##grpcurl -insecure -authority grpc.example.com &lt;ip_address&gt;:443 list<br>##ip_address为Nginx Ingress Controller的Service外部IP<br><br><br>[root@VM-0-16-tlinux ~/grpc]# ./grpcurl -insecure -authority grpc.chen1900s.cn  170.106.134.2:443 list<br>greet.GrpcService<br>grpc.reflection.v1alpha.ServerReflection<br></code></pre></td></tr></table></figure><p>从预期输出可得，流量被Ingress成功转发到后端gRPC服务</p><p>注意点：由于Nginx grpc_pass的限制，目前对于gRPC服务，暂不支持service-weight的配置</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Nginx-ingress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署kubernetes-dashboard服务</title>
      <link href="/post/1814e34b.html"/>
      <url>/post/1814e34b.html</url>
      
        <content type="html"><![CDATA[<h2 id="在TKE集群部署kubernetes-dashboard服务"><a href="#在TKE集群部署kubernetes-dashboard服务" class="headerlink" title="在TKE集群部署kubernetes-dashboard服务"></a>在TKE集群部署kubernetes-dashboard服务</h2><p><a href="https://github.com/kubernetes/dashboard">具体参考</a></p><blockquote><p>基于已经创建好的Kubernetes集群进行部署Kubernetes-dashboard</p></blockquote><h3 id="下载部署yaml文件"><a href="#下载部署yaml文件" class="headerlink" title="下载部署yaml文件"></a>下载部署yaml文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.4/aio/deploy/recommended.yaml<br></code></pre></td></tr></table></figure><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>由于镜像是国外镜像，国内集群部署有可能会拉取镜像失败，可以先手动拉取下来，然后修改对应的yaml文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker pull kubernetesui/dashboard:v2.0.4<br>docker pull kubernetesui/metrics-scraper:v1.0.4<br><br>docker tag 46d0a29c3f61 ccr.ccs.tencentyun.com/chenjingwei/dashboard:v2.0.4  <span class="hljs-comment">#重新打tag, 对应到自己账号下个人镜像参考，我这里上传到我自己的镜像仓库，如果有需要 也可以从这个地址下载</span><br>docker tag 86262685d9ab  ccr.ccs.tencentyun.com/chenjingwei/metrics-scraper:v1.0.4<br><br>docker push ccr.ccs.tencentyun.com/chenjingwei/dashboard:v2.0.4<br>docker push ccr.ccs.tencentyun.com/chenjingwei/metrics-scraper:v1.0.4<br></code></pre></td></tr></table></figure><h3 id="访问方式配置（可选）"><a href="#访问方式配置（可选）" class="headerlink" title="访问方式配置（可选）"></a>访问方式配置（可选）</h3><p>对应的service 默认是clusterIP方式，如果需要CLB去访问 或者nodePort方式去访问，可以修改对应的yaml文件，也可以部署完后修改</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">443</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8443</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span>   <span class="hljs-comment">#添加这个 service类型  如果需要是CLB类型 则修改成  LoadBalancer</span><br></code></pre></td></tr></table></figure><h3 id="部署kubernetes-dashboard"><a href="#部署kubernetes-dashboard" class="headerlink" title="部署kubernetes-dashboard"></a>部署kubernetes-dashboard</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl apply -f recommended.yaml<br></code></pre></td></tr></table></figure><p>查看是否部署成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-249-41-tlinux ~]<span class="hljs-comment"># kubectl  -n kubernetes-dashboard get pod,svc</span><br>NAME                                            READY   STATUS    RESTARTS   AGE<br>pod/dashboard-metrics-scraper-7748f84fc-8ldkn   1/1     Running   0          92m<br>pod/kubernetes-dashboard-6fbb5497cf-qscnk       2/2     Running   1          29m<br><br>NAME                                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE<br>service/dashboard-metrics-scraper   ClusterIP   172.16.253.139   &lt;none&gt;        8000/TCP        92m<br>service/kubernetes-dashboard        NodePort    172.16.252.218   &lt;none&gt;        443:31778/TCP   92m<br></code></pre></td></tr></table></figure><h3 id="访问kubernetes-dashboard"><a href="#访问kubernetes-dashboard" class="headerlink" title="访问kubernetes-dashboard"></a>访问kubernetes-dashboard</h3><p>由于上面service使用的是NodePort类型，可以通过nodeIP+NodePort端口去访问，kubernetes-dashboard后端服务是https协议的，则需要通过https:&#x2F;&#x2F;节点IP:NodePort</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180021047.png" alt="image-20221018002131961"></p><p>验证方式选择token</p><h3 id="TKE集群获取Token认证方式"><a href="#TKE集群获取Token认证方式" class="headerlink" title="TKE集群获取Token认证方式"></a>TKE集群获取Token认证方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 创建serviceaccount<br>kubectl create serviceaccount dashboard-serviceaccount -n kubernetes-dashboard<br># 创建clusterrolebinding<br>kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:dashboard-serviceaccount<br></code></pre></td></tr></table></figure><p>获取token</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-249-41-tlinux ~]# kubectl get secret -n kubernetes-dashboard | grep dashboard-serviceaccount-token<br>dashboard-serviceaccount-token-pddv4   kubernetes.io/service-account-token   3      98m<br>[root@VM-249-41-tlinux ~]# kubectl describe secret dashboard-serviceaccount-token-pddv4 -n kubernetes-dashboard<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180024730.png" alt="image-20221018002432661"></p><p>复制token 到控制台</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180025468.png" alt="image-20221018002536365"></p><h2 id="基于Istio的访问kubernetes-dashboard配置"><a href="#基于Istio的访问kubernetes-dashboard配置" class="headerlink" title="基于Istio的访问kubernetes-dashboard配置"></a>基于Istio的访问kubernetes-dashboard配置</h2><p>参考<a href="https://preliminary.istio.io/latest/docs/tasks/traffic-management/ingress/ingress-sni-passthrough/">istio官方文档</a></p><blockquote><p>前提条件：</p><p>1，服务网格已经关联集群</p><p>2，已经创建边缘代理网关<strong>istio-ingressgateway</strong></p></blockquote><p>首先需要开启 Sidecar 自动注入配置，命名空间选择kubernetes-dashboard，然后销毁重建kubernetes-dashboard的POD</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#这边是基于TKE的容器服务网格1.12.5版本的，其他版本需要修改成对应版本</span><br><br>kubectl label namespace kubernetes-dashboard istio.io/rev=1-12-5<br><br><span class="hljs-comment">#如果是使用的是自建sidecar 则需要使用下面这个命令开启自动注入</span><br><span class="hljs-comment">#kubectl label namespace xxx istio-injection=enalbed 为某个 namespace 开启 sidecar 自动注入</span><br></code></pre></td></tr></table></figure><h3 id="新建Gateway"><a href="#新建Gateway" class="headerlink" title="新建Gateway"></a>新建Gateway</h3><p>这里使用自定义的域名kubernetes-dashboard.chen1900s.com</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180038668.png" alt="image-20221018003822597"></p><p>对应yaml:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: networking.istio.io/v1alpha3<br>kind: Gateway<br>metadata:<br>  name: kubernetes-dashboard-gateway<br>  namespace: kubernetes-dashboard<br>spec:<br>  servers:<br>    - port:<br>        number: 443<br>        name: HTTPS-1-m00g<br>        protocol: HTTPS<br>      hosts:<br>        - kubernetes-dashboard.chen1900s.com<br>      tls:<br>        mode: PASSTHROUGH<br>  selector:<br>    app: istio-ingressgateway<br>    istio: ingressgateway<br></code></pre></td></tr></table></figure><h3 id="创建Virtual-Service"><a href="#创建Virtual-Service" class="headerlink" title="创建Virtual Service"></a>创建Virtual Service</h3><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180041789.png" alt="image-20221018004125714"></p><p>yaml文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: networking.istio.io/v1alpha3<br>kind: VirtualService<br>metadata:<br>  name: kubernetes-dashboard-vs<br>  namespace: kubernetes-dashboard<br>spec:<br>  hosts:<br>    - kubernetes-dashboard.chen1900s.com<br>  gateways:<br>    - kubernetes-dashboard/kubernetes-dashboard-gateway<br>  tls:<br>    - match:<br>        - sniHosts:<br>            - kubernetes-dashboard.chen1900s.com<br>      route:<br>        - destination:<br>            host: kubernetes-dashboard.kubernetes-dashboard.svc.cluster.local<br>            port:<br>              number: 443<br>          weight: 100<br></code></pre></td></tr></table></figure><p>设置完成后，配置如下本地host映射，即可通过域名 <a href="https://kubernetes-dashboard.chen1900s.com/">https://kubernetes-dashboard.chen1900s.com</a> 访问，效果与之前的NodePort一致</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-249-41-tlinux ~]# kubectl  -n istio-system get svc  istio-ingressgateway <br>NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP      PORT(S)         AGE<br>istio-ingressgateway   LoadBalancer   172.16.255.54   114.117.219.33   443:32430/TCP   3h47m<br><br>#114.117.219.33 kubernetes-dashboard.chen1900s.com<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180045224.png" alt="image-20221018004522135"></p><p>输入上面查询到的token 可以正常登陆</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180046871.png" alt="image-20221018004606746"></p><p>Istio中基于Secure Ingress的访问方式还有多种</p><h2 id="基于nginx-ingress方式访问kubernetes-dashboard"><a href="#基于nginx-ingress方式访问kubernetes-dashboard" class="headerlink" title="基于nginx-ingress方式访问kubernetes-dashboard"></a>基于nginx-ingress方式访问kubernetes-dashboard</h2><p>Nginx Ingress Controller默认使用HTTP协议转发请求到后端业务容器。当后端业务容器为HTTPS协议时，可以通过使用注解<code>nginx.ingress.kubernetes.io/backend-protocol: &quot;HTTPS&quot;</code>来使得Nginx Ingress Controller使用HTTP协议转发请求到后端业务容器</p><p>kubernetes-dashboard服务正是HTTPS协议服务，则需要使用这个annotations</p><blockquote><p>环境准备：</p><p>1，已经创建nginx-ingress-controller 实例</p><p>2，已经创建TLS证书</p></blockquote><p>首先是如果不添加这个annotations 访问会报 Client sent an HTTP request to an HTTPS server.</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180102998.png" alt="image-20221018010208941"></p><p>添加nginx.ingress.kubernetes.io&#x2F;backend-protocol: “HTTPS” 后访问正常</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180103610.png" alt="image-20221018010345523"></p><p>yaml文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">kubernetes.io/ingress.rule-mix:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/backend-protocol:</span> <span class="hljs-string">HTTPS</span>    <span class="hljs-comment">#重点这个annotations</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/use-regex:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">kubernetes-dashboard.chen1900s.cn</span>     <span class="hljs-comment">#域名替换成自己的域名</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">kubernetes-dashboard</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">443</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">ImplementationSpecific</span><br>  <span class="hljs-attr">tls:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">kubernetes-dashboard.chen1900s.cn</span><br>    <span class="hljs-attr">secretName:</span> <span class="hljs-string">chen1900s</span>                          <span class="hljs-comment">#替换成自己的证书secret</span><br></code></pre></td></tr></table></figure><h2 id="基于CLB类型ingress方式访问kubernetes-dashboard配置"><a href="#基于CLB类型ingress方式访问kubernetes-dashboard配置" class="headerlink" title="基于CLB类型ingress方式访问kubernetes-dashboard配置"></a>基于CLB类型ingress方式访问kubernetes-dashboard配置</h2><p>CLB类型ingress，对应后端服务协议是默认HTTP的，后端协议是指 CLB 与后端服务之间协议，后端协议选择 HTTP 时，后端服务需部署 HTTP 服务。后端协议选中 HTTPS 时，后端服务需部署 HTTPS 服务，HTTPS 服务的加解密会让后端服务消耗更多资源</p><p>如果需要后端协议为HTTPS 则需要使用TkeServiceConfig来配置ingress自动创建的CLB</p><p>如果不通过TkeServiceConfig配置后端是HTTPS服务时候，访问会异常，如下：</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180117469.png" alt="image-20221018011724396"></p><h3 id="使用-TkeServiceConfig-配置-CLB"><a href="#使用-TkeServiceConfig-配置-CLB" class="headerlink" title="使用 TkeServiceConfig 配置 CLB"></a>使用 TkeServiceConfig 配置 CLB</h3><p>创建 Ingress 时，设置 <strong>ingress.cloud.tencent.com&#x2F;tke-service-config-auto:<true></strong> ，将自动创建 <IngressName>-auto-ingress-config</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">ingress.cloud.tencent.com/tke-service-config-auto:</span> <span class="hljs-string">&quot;true&quot;</span>   <span class="hljs-comment">#自动创建TkeServiceConfig</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">qcloud</span><br>    <span class="hljs-attr">kubernetes.io/ingress.rule-mix:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">kubernetes-dashboard.chen1900s.cn</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">kubernetes-dashboard</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">443</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">ImplementationSpecific</span><br>  <span class="hljs-attr">tls:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">kubernetes-dashboard.chen1900s.cn</span><br>    <span class="hljs-attr">secretName:</span> <span class="hljs-string">chen1900s-ye4ubdzo</span><br><br></code></pre></td></tr></table></figure><p>查看TkeServiceConfig配置</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-249-41-tlinux ~]<span class="hljs-comment"># kubectl  -n  kubernetes-dashboard  get TkeServiceConfig   kubernetes-dashboard-auto-ingress-config </span><br>NAME                                       AGE<br>kubernetes-dashboard-auto-ingress-config   66s<br></code></pre></td></tr></table></figure><p>编辑这个配置文件，修改后端协议 <code>spec.loadBalancer.l7listeners.protocol.domain.rules.url.forwardType</code>: 指定后端协议</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl  -n  kubernetes-dashboard  edit  TkeServiceConfig   kubernetes-dashboard-auto-ingress-config <br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180123467.png" alt="image-20221018012329401"></p><p>然后使用这个CLB对应的域名进行访问</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180124832.png" alt="image-20221018012426758"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202210180125382.png" alt="image-20221018012544266"></p><p>附：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">cloud.tencent.com/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">TkeServiceConfig</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubernetes-dashboard-auto-ingress-config</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">loadBalancer:</span><br>    <span class="hljs-attr">l7Listeners:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">defaultServer:</span> <span class="hljs-string">kubernetes-dashboard.chen1900s.cn</span><br>      <span class="hljs-attr">domains:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">domain:</span> <span class="hljs-string">kubernetes-dashboard.chen1900s.cn</span><br>        <span class="hljs-attr">rules:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">forwardType:</span> <span class="hljs-string">HTTPS</span>                  <span class="hljs-comment">#主要修改这个   指定后端协议</span><br>          <span class="hljs-attr">healthCheck:</span><br>            <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>            <span class="hljs-attr">healthNum:</span> <span class="hljs-number">3</span><br>            <span class="hljs-attr">httpCheckDomain:</span> <span class="hljs-string">kubernetes-dashboard.chen1900s.cn</span><br>            <span class="hljs-attr">httpCheckMethod:</span> <span class="hljs-string">HEAD</span><br>            <span class="hljs-attr">httpCheckPath:</span> <span class="hljs-string">/</span><br>            <span class="hljs-attr">httpCode:</span> <span class="hljs-number">31</span><br>            <span class="hljs-attr">intervalTime:</span> <span class="hljs-number">5</span><br>            <span class="hljs-attr">sourceIpType:</span> <span class="hljs-number">0</span><br>            <span class="hljs-attr">timeout:</span> <span class="hljs-number">5</span><br>            <span class="hljs-attr">unHealthNum:</span> <span class="hljs-number">3</span><br>          <span class="hljs-attr">scheduler:</span> <span class="hljs-string">WRR</span><br>          <span class="hljs-attr">session:</span><br>            <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>          <span class="hljs-attr">url:</span> <span class="hljs-string">/</span><br>      <span class="hljs-attr">keepaliveEnable:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">443</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTPS</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">keepaliveEnable:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">HTTP</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TKE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> TKE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes常见驱逐Eviction问题</title>
      <link href="/post/d0686bc1.html"/>
      <url>/post/d0686bc1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在高可用的k8s集群中，当Node节点挂掉，kubelet无法提供工作的时候，pod将会驱逐并自动调度到其他的节点上去，或者在node节点的资源紧缺的条件下，kubelet为了保证node节点的稳定性，也回触发主动驱逐pod的机制</p></blockquote><h2 id="POD驱逐"><a href="#POD驱逐" class="headerlink" title="POD驱逐"></a>POD驱逐</h2><p>Eviction状态介绍：</p><ul><li>Eviction，即驱逐的意思，意思是当节点出现异常时，为了保证工作负载的可用性，kubernetes将有相应的机制驱逐该节点上的Pod。<br>目前kubernetes中存在两种eviction机制，分别由kube-controller-manager和kubelet实现。</li><li>kube-controller-manager的eviction机制是粗粒度的，即驱赶一个节点上的所有pod，而kubelet则是细粒度的，它驱赶的是节点上的某些Pod，驱赶哪些Pod与Pod的Qos机制有关。该Eviction会周期性检查本节点内存、磁盘等资源，当资源不足时，按照优先级驱逐部分pod</li></ul><h3 id="kube-controller-manager实现的eviction"><a href="#kube-controller-manager实现的eviction" class="headerlink" title="kube-controller-manager实现的eviction"></a>kube-controller-manager实现的eviction</h3><p>kube-controller-manager主要由多个控制器构成，而eviction的功能主要由node controller这个控制器实现。该Eviction会周期性检查所有节点状态，当节点处于<strong>NotReady</strong>状态超过一段时间后，驱逐该节点上所有pod</p><p>Kubelet 状态更新的基本流程：</p><ul><li>kubelet 自身会定期更新状态到 apiserver，通过参数–node-status-update-frequency指定上报频率，默认是 10s 上报一次。</li><li>kube-controller-manager 会每隔–node-monitor-period时间去检查 kubelet 的状态，默认是 5s。</li><li>当 node 失联一段时间后，kubernetes 判定 node 为 notready 状态，这段时长通过–node-monitor-grace-period参数配置，默认 40s。</li><li>当 node 失联一段时间后，kubernetes 判定 node 为 unhealthy 状态，这段时长通过–node-startup-grace-period参数配置，默认 1m0s。</li><li>当 node 失联一段时间后，kubernetes 开始删除原 node 上的 pod，这段时长是通过–pod-eviction-timeout参数配置，默认 5m0s。</li></ul><blockquote><p>kube-controller-manager 和 kubelet 是异步工作的，这意味着延迟可能包括任何的网络延迟、apiserver 的延迟、etcd 延迟，一个节点上的负载引起的延迟等等。因此，如果–node-status-update-frequency设置为5s，那么实际上 etcd 中的数据变化会需要 6-7s，甚至更长时间。</p></blockquote><p>启动参数控制eviction：</p><ul><li><strong>pod-eviction-timeout：</strong>即当节点宕机该时间间隔后，开始eviction机制，驱赶宕机节点上的Pod，默认为5min。</li><li><strong>node-eviction-rate：</strong>驱赶速率，即驱赶Node的速率，由令牌桶流控算法实现，默认为0.1，即每秒驱赶0.1个节点，注意这里不是驱赶Pod的速率，而是驱赶节点的速率。相当于每隔10s，清空一个节点。</li><li><strong>secondary-node-eviction-rate：</strong>二级驱赶速率，当集群中宕机节点过多时，相应的驱赶速率也降低，默认为0.01。</li><li><strong>unhealthy-zone-threshold：</strong>不健康zone阈值，会影响什么时候开启二级驱赶速率，默认为0.55，即当该zone中节点宕机数目超过55%，而认为该zone不健康。</li><li><strong>large-cluster-size-threshold：</strong>大集群阈值，当该zone的节点多余该阈值时，则认为该zone是一个大集群。大集群节点宕机数目超过55%时，则将驱赶速率降为0.01，假如是小集群，则将速率直接降为0。</li></ul><p>社区默认的配置：</p><table><thead><tr><th>参数</th><th>值</th></tr></thead><tbody><tr><td>–node-status-update-frequency</td><td>10s</td></tr><tr><td>–node-monitor-period</td><td>5s</td></tr><tr><td>–node-monitor-grace-period</td><td>40s</td></tr><tr><td>–pod-eviction-timeout</td><td>5m</td></tr></tbody></table><h3 id="kubelet基于节点压力eviction机制"><a href="#kubelet基于节点压力eviction机制" class="headerlink" title="kubelet基于节点压力eviction机制"></a>kubelet基于节点压力eviction机制</h3><p>如果节点处于资源压力，那么kubelet就会执行驱逐策略。驱逐会考虑Pod的优先级，资源使用和资源申请。当优先级相同时，资源使用&#x2F;资源申请最大的Pod会被首先驱逐，更多详情可以参考<a href="https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/">官方文档</a></p><p>kubelet提供了以下参数控制eviction：</p><ul><li><strong>eviction-soft：</strong>软驱逐阈值设置，具有一系列阈值，比如memory.available&lt;1.5Gi时，它不会立即执行pod eviction，而会等待eviction-soft-grace-period时间，假如该时间过后，依然还是达到了eviction-soft，则触发一次pod eviction。</li><li><strong>eviction-soft-grace-period：</strong>默认为90秒，当eviction-soft时，终止Pod的grace的时间，即软驱逐宽限期，软驱逐信号与驱逐处理之间的时间差。</li><li><strong>eviction-max-pod-grace-period：</strong>最大驱逐pod宽限期，停止信号与kill之间的时间差。</li><li><strong>eviction-pressure-transition-period：</strong>默认为5分钟，脱离pressure condition的时间，超过阈值时，节点会被设置为memory pressure或者disk pressure，然后开启pod eviction。</li><li><strong>eviction-minimum-reclaim：</strong>表示每一次eviction必须至少回收多少资源。</li><li><strong>eviction-hard****：</strong>强制驱逐设置，也具有一系列的阈值，比如memory.available&lt;1Gi，即当节点可用内存低于1Gi时，会立即触发一次pod eviction。</li></ul><h3 id="驱逐问题处理"><a href="#驱逐问题处理" class="headerlink" title="驱逐问题处理"></a>驱逐问题处理</h3><p>1，使用如下命令发现很多pod的状态为Evicted：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl get pods   -o wide --all-namespaces | grep -i Evicted<br></code></pre></td></tr></table></figure><p>2，在节点的kubelet日志中会记录Evicted相关内容，搜索方法可参考如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">journalctl  -u kubelet | grep -i Evicted -C3<br></code></pre></td></tr></table></figure><p>3，查看节点监控是否有内存打满或者 节点磁盘</p><p>4，清理异常状态Evicted的POD</p><blockquote><p><namespace>  为命名空间名称，请根据需要指定。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl get pods &lt;namespace&gt; | grep Evicted | awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> | xargs kubectl delete pod &lt;namespace&gt; <br></code></pre></td></tr></table></figure><p>或者使用这个命令清理所有命名空间驱逐状态的POD</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl get pod -o wide --all-namespaces | awk <span class="hljs-string">&#x27;&#123;if($4==&quot;Evicted&quot;)&#123;cmd=&quot;kubectl -n &quot;$1&quot; delete pod &quot;$2; system(cmd)&#125;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>5，pod驱逐后，如果新调度到的节点也有驱逐情况，就会再次被驱逐；甚至出现pod不断被驱逐的情况,，需要确保集群资源充足</p><p>6，如果是由kube-controller-manager触发的驱逐，会留下一个状态为Terminating的pod；直到容器所在节点状态恢复后，pod才会自动删除。如果节点已经删除或者其他原因导致的无法恢复，可以使用“强制删除”删除pod，</p><p>7，如果是由kubelet触发的驱逐，会留下一个状态为Evicted的pod，此pod只是方便后期定位的记录，可以直接删除。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes中节点压力驱逐机制</title>
      <link href="/post/3d95a7a0.html"/>
      <url>/post/3d95a7a0.html</url>
      
        <content type="html"><![CDATA[<h2 id="K8S节点压力驱逐原理"><a href="#K8S节点压力驱逐原理" class="headerlink" title="K8S节点压力驱逐原理"></a>K8S节点压力驱逐原理</h2><p>节点压力驱逐是 <a href="https://kubernetes.io/docs/reference/generated/kubelet">kubelet</a> 主动终止 Pod 以回收节点上资源的过程。<br><a href="https://kubernetes.io/docs/reference/generated/kubelet">kubelet</a> 监控集群节点的 CPU、内存、磁盘空间和文件系统的 inode 等资源。 当这些资源中的一个或者多个达到特定的消耗水平， kubelet 可以主动地使节点上一个或者多个 Pod 失效，以回收资源防止节点崩溃。<br>在节点压力驱逐期间，kubelet 将所选 Pod 的 PodPhase 设置为 Failed状态。这将终止 Pod，节点压力驱逐不同于 <a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/api-eviction/">API 发起的驱逐</a>。<br>kubelet 并不理会你配置的 PodDisruptionBudget 或者是 Pod 的 terminationGracePeriodSeconds。 如果你使用了<a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/node-pressure-eviction/#soft-eviction-thresholds">软驱逐条件</a>，kubelet 会考虑你所配置的 eviction-max-pod-grace-period。 如果你使用了<a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/node-pressure-eviction/#hard-eviction-thresholds">硬驱逐条件</a>，它使用 0s 宽限期来终止 Pod。<br>如果 Pod 是高级资源对象管理的POD （例如 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a> 或者 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a>）管理， 则控制平面或 kube-controller-manager 会在其他节点上创建新的 Pod 来代替被驱逐的 Pod。</p><blockquote><p>说明：kubelet 在驱逐Pod 之前会尝试<a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/node-pressure-eviction/#reclaim-node-resources">回收节点级资源</a>。 例如，它会在磁盘资源不足时删除未使用的容器镜像。</p></blockquote><p>kubelet 使用各种参数来做出驱逐决定，如下所示：</p><ul><li>驱逐信号</li><li>驱逐条件</li><li>监控间隔</li></ul><h3 id="驱逐信号"><a href="#驱逐信号" class="headerlink" title="驱逐信号"></a>驱逐信号</h3><p>驱逐信号是特定资源在特定时间点的当前状态。 kubelet 使用驱逐信号，通过将信号与驱逐条件进行比较来做出驱逐决定， 驱逐条件是节点上应该可用资源的最小量。</p><p>kubelet 使用以下驱逐信号：</p><table><thead><tr><th>驱逐信号</th><th>描述</th></tr></thead><tbody><tr><td>memory.available</td><td>memory.available :&#x3D; node.status.capacity[memory] - node.stats.memory.workingSet</td></tr><tr><td>nodefs.available</td><td>nodefs.available :&#x3D; node.stats.fs.available</td></tr><tr><td>nodefs.inodesFree</td><td>nodefs.inodesFree :&#x3D; node.stats.fs.inodesFree</td></tr><tr><td>imagefs.available</td><td>imagefs.available :&#x3D; node.stats.runtime.imagefs.available</td></tr><tr><td>imagefs.inodesFree</td><td>imagefs.inodesFree :&#x3D; node.stats.runtime.imagefs.inodesFree</td></tr><tr><td>pid.available</td><td>pid.available :&#x3D; node.stats.rlimit.maxpid - node.stats.rlimit.curproc</td></tr></tbody></table><p>在上表中，描述列显示了 kubelet 如何获取信号的值。每个信号支持百分比值或者是字面值。 kubelet 计算相对于与信号有关的总量的百分比值。</p><p><strong>memory.available 的值来自 cgroupfs，而不是取自 free -m 这样的工具，这很重要</strong>，因为 free -m 在容器中不起作用，如果用户使用 <a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable">节点可分配资源</a> 这一功能特性，资源不足的判定是基于 cgroup 层次结构中的用户 Pod 所处的局部及 cgroup 根节点作出的。 这个<a href="https://kubernetes.io/zh-cn/examples/admin/resource/memory-available.sh">脚本</a> 重现了 kubelet 为计算 memory.available 而执行的相同步骤。 kubelet 在其计算中排除了 inactive_file（即非活动 LRU 列表上基于文件来虚拟的内存的字节数）， 因为它假定在压力下内存是可回收的。</p><p>kubelet 支持以下文件系统分区：</p><ol><li>nodefs：节点的主要文件系统，用于本地磁盘卷、emptyDir、日志存储等。 例如，nodefs 包含 &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;。</li><li>imagefs：可选文件系统，供容器运行时存储容器镜像和容器可写层。</li></ol><p>当 nodefs 用量到达阈值，Kubelet 会选择性的驱逐 Pod（及其容器）来释放空间。</p><p>当 imagefs 用量到达驱逐阈值，Kubelet 会删除所有未使用的镜像，释放空间。</p><h3 id="驱逐条件"><a href="#驱逐条件" class="headerlink" title="驱逐条件"></a>驱逐条件</h3><p>你可以为 kubelet 指定自定义驱逐条件，以便在作出驱逐决定时使用。</p><p>驱逐条件的形式为 [eviction-signal][operator][quantity]，其中：</p><ul><li>eviction-signal 是要使用的<a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals">驱逐信号</a>。</li><li>operator 是你想要的<a href="https://en.wikipedia.org/wiki/Relational_operator#Standard_relational_operators">关系运算符</a>， 比如 &lt;（小于）。</li><li>quantity 是驱逐条件数量，例如 1Gi。 quantity 的值必须与 Kubernetes 使用的数量表示相匹配。 你可以使用文字值或百分比（%）。</li></ul><p>例如，如果一个节点的总内存为 10Gi 并且你希望在可用内存低于 1Gi 时触发驱逐， 则可以将驱逐条件定义为 memory.available&lt;10% 或 memory.available&lt; 1G。 你不能同时使用二者。</p><p>你可以配置软和硬驱逐条件。</p><h4 id="软驱逐条件"><a href="#软驱逐条件" class="headerlink" title="软驱逐条件"></a>软驱逐条件</h4><p>软驱逐条件将驱逐条件与用户所必须指定的宽限期配对。 在超过宽限期之前，kubelet 不会驱逐 Pod。 如果没有指定的宽限期，kubelet 会在启动时返回错误。你可以既指定软驱逐条件宽限期，又指定 Pod 终止宽限期的上限，给 kubelet 在驱逐期间使用。 如果你指定了宽限期的上限并且 Pod 满足软驱逐阈条件，则 kubelet 将使用两个宽限期中的较小者。 如果你没有指定宽限期上限，kubelet 会立即杀死被驱逐的 Pod，不允许其体面终止。</p><p>你可以使用以下标志来配置软驱逐条件：</p><ul><li>eviction-soft：一组驱逐条件，如 memory.available&lt;1.5Gi， 如果驱逐条件持续时长超过指定的宽限期，可以触发 Pod 驱逐。</li><li>eviction-soft-grace-period：一组驱逐宽限期， 如 memory.available&#x3D;1m30s，定义软驱逐条件在触发 Pod 驱逐之前必须保持多长时间。</li><li>eviction-max-pod-grace-period：在满足软驱逐条件而终止 Pod 时使用的最大允许宽限期（以秒为单位）。</li></ul><h4 id="硬驱逐条件"><a href="#硬驱逐条件" class="headerlink" title="硬驱逐条件"></a>硬驱逐条件</h4><p>硬驱逐条件没有宽限期。当达到硬驱逐条件时， kubelet 会立即杀死 pod，而不会正常终止以回收紧缺的资源。</p><p>你可以使用 eviction-hard 标志来配置一组硬驱逐条件， 例如 memory.available&lt;1Gi。</p><p>kubelet 具有以下默认硬驱逐条件：</p><ul><li>memory.available&lt;100Mi</li><li>nodefs.available&lt;10%</li><li>imagefs.available&lt;15%</li><li>nodefs.inodesFree&lt;5%（Linux 节点）</li></ul><blockquote><p>驱逐监测间隔： kubelet 根据其配置的 housekeeping-interval（默认为 10s）评估驱逐条件。</p></blockquote><h4 id="节点条件"><a href="#节点条件" class="headerlink" title="节点条件"></a>节点条件</h4><p>kubelet 报告节点状况以反映节点处于压力之下，因为满足硬或软驱逐条件，与配置的宽限期无关。</p><p>kubelet 根据下表将驱逐信号映射为节点状况：</p><table><thead><tr><th>节点条件</th><th>驱逐信号</th><th>描述</th></tr></thead><tbody><tr><td>MemoryPressure</td><td>memory.available</td><td>节点上的可用内存已满足驱逐条件</td></tr><tr><td>DiskPressure</td><td>nodefs.available、nodefs.inodesFree、imagefs.available 或 imagefs.inodesFree</td><td>节点的根文件系统或镜像文件系统上的可用磁盘空间和 inode 已满足驱逐条件</td></tr><tr><td>PIDPressure</td><td>pid.available</td><td>(Linux) 节点上的可用进程标识符已低于驱逐条件</td></tr></tbody></table><p>kubelet 根据配置的 –node-status-update-frequency 更新节点条件，默认为 10s。</p><blockquote><p>节点条件振荡</p><p>在某些情况下，节点在软驱逐条件上下振荡，而没有保持定义的宽限期。 这会导致报告的节点条件在 true 和 false 之间不断切换，从而导致错误的驱逐决策。</p><p>为了防止振荡，你可以使用 eviction-pressure-transition-period 标志， 该标志控制 kubelet 在将节点条件转换为不同状态之前必须等待的时间。 过渡期的默认值为 5m。</p></blockquote><h3 id="回收节点级资源"><a href="#回收节点级资源" class="headerlink" title="回收节点级资源"></a>回收节点级资源</h3><p>kubelet 在驱逐最终用户 Pod 之前会先尝试回收节点级资源。</p><p>当报告 DiskPressure 节点状况时，kubelet 会根据节点上的文件系统回收节点级资源。</p><ul><li><strong>有 imagefs</strong></li></ul><p>如果节点有一个专用的 imagefs 文件系统供容器运行时使用，kubelet 会执行以下操作：</p><ul><li><p>如果 nodefs 文件系统满足驱逐条件，kubelet 垃圾收集死亡 Pod 和容器。</p></li><li><p>如果 imagefs 文件系统满足驱逐条件，kubelet 将删除所有未使用的镜像。</p></li><li><p><strong>没有 imagefs</strong></p></li></ul><p>如果节点只有一个满足驱逐条件的 nodefs 文件系统， kubelet 按以下顺序释放磁盘空间：</p><ol><li>对死亡的 Pod 和容器进行垃圾收集</li><li>删除未使用的镜像</li></ol><h3 id="kubelet-驱逐时-Pod-的选择"><a href="#kubelet-驱逐时-Pod-的选择" class="headerlink" title="kubelet 驱逐时 Pod 的选择"></a>kubelet 驱逐时 Pod 的选择</h3><p>如果 kubelet 回收节点级资源的尝试没有使驱逐信号低于条件， 则 kubelet 开始驱逐最终用户 Pod。</p><p>kubelet 使用以下参数来确定 Pod 驱逐顺序：</p><ol><li>Pod 的资源使用是否超过其请求</li><li><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/">Pod 优先级</a></li><li>Pod 相对于请求的资源使用情况</li></ol><p>因此，kubelet 按以下顺序排列和驱逐 Pod：</p><ol><li>首先考虑资源使用量超过其请求的 BestEffort 或 Burstable Pod。 这些 Pod 会根据它们的优先级以及它们的资源使用级别超过其请求的程度被逐出。</li><li>资源使用量少于请求量的 Guaranteed Pod 和 Burstable Pod 根据其优先级被最后驱逐。</li></ol><blockquote><p>说明：kubelet 不使用 Pod 的 QoS 类来确定驱逐顺序。 在回收内存等资源时，你可以使用 QoS 类来估计最可能的 Pod 驱逐顺序。 QoS 不适用于临时存储（EphemeralStorage）请求， 因此如果节点在 DiskPressure 下，则上述场景将不适用。</p></blockquote><p>仅当 Guaranteed Pod 中所有容器都被指定了请求和限制并且二者相等时，才保证 Pod 不被驱逐。 这些 Pod 永远不会因为另一个 Pod 的资源消耗而被驱逐。 如果系统守护进程（例如 kubelet 和 journald） 消耗的资源比通过 system-reserved 或 kube-reserved 分配保留的资源多， 并且该节点只有 Guaranteed 或 Burstable Pod 使用的资源少于其上剩余的请求， 那么 kubelet 必须选择驱逐这些 Pod 中的一个以保持节点稳定性并减少资源匮乏对其他 Pod 的影响。 在这种情况下，它会选择首先驱逐最低优先级的 Pod。</p><p>当 kubelet 因 inode 或 PID 不足而驱逐 Pod 时， 它使用优先级来确定驱逐顺序，因为 inode 和 PID 没有请求。</p><p>kubelet 根据节点是否具有专用的 imagefs 文件系统对 Pod 进行不同的排序：</p><ul><li><strong>有 imagefs</strong></li></ul><p>如果 nodefs 触发驱逐， kubelet 会根据 nodefs 使用情况（本地卷 + 所有容器的日志）对 Pod 进行排序。</p><p>如果 imagefs 触发驱逐，kubelet 会根据所有容器的可写层使用情况对 Pod 进行排序。</p><ul><li><strong>没有 imagefs</strong></li></ul><p>如果 nodefs 触发驱逐， kubelet 会根据磁盘总用量（本地卷 + 日志和所有容器的可写层）对 Pod 进行排序。</p><h3 id="最小驱逐回收"><a href="#最小驱逐回收" class="headerlink" title="最小驱逐回收"></a>最小驱逐回收</h3><p>在某些情况下，驱逐 Pod 只会回收少量的紧俏资源。 这可能导致 kubelet 反复达到配置的驱逐条件并触发多次驱逐。</p><p>你可以使用 –eviction-minimum-reclaim 标志或 <a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubelet-config-file/">kubelet 配置文件</a> 为每个资源配置最小回收量。 当 kubelet 注意到某个资源耗尽时，它会继续回收该资源，直到回收到你所指定的数量为止。</p><p>例如，以下配置设置最小回收量：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubelet.config.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">KubeletConfiguration</span><br><span class="hljs-attr">evictionHard:</span><br>  <span class="hljs-attr">memory.available:</span> <span class="hljs-string">&quot;500Mi&quot;</span><br>  <span class="hljs-attr">nodefs.available:</span> <span class="hljs-string">&quot;1Gi&quot;</span><br>  <span class="hljs-attr">imagefs.available:</span> <span class="hljs-string">&quot;100Gi&quot;</span><br><span class="hljs-attr">evictionMinimumReclaim:</span><br>  <span class="hljs-attr">memory.available:</span> <span class="hljs-string">&quot;0Mi&quot;</span><br>  <span class="hljs-attr">nodefs.available:</span> <span class="hljs-string">&quot;500Mi&quot;</span><br>  <span class="hljs-attr">imagefs.available:</span> <span class="hljs-string">&quot;2Gi&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，如果 nodefs.available 信号满足驱逐条件， kubelet 会回收资源，直到信号达到 1Gi 的条件， 然后继续回收至少 500Mi 直到信号达到 1.5Gi。</p><p>类似地，kubelet 会回收 imagefs 资源，直到 imagefs.available 信号达到 102Gi。</p><p>对于所有资源，默认的 eviction-minimum-reclaim 为 0。</p><h3 id="节点内存不足触发的驱逐"><a href="#节点内存不足触发的驱逐" class="headerlink" title="节点内存不足触发的驱逐"></a>节点内存不足触发的驱逐</h3><p>如果节点在 kubelet 能够回收内存之前遇到内存不足（OOM）事件， 则节点依赖 <a href="https://lwn.net/Articles/391222/">oom_killer</a> 来响应。</p><p>kubelet 根据 Pod 的服务质量（QoS）为每个容器设置一个 oom_score_adj 值。</p><table><thead><tr><th>服务质量</th><th>oom_score_adj</th></tr></thead><tbody><tr><td>Guaranteed</td><td>-997</td></tr><tr><td>BestEffort</td><td>1000</td></tr><tr><td>Burstable</td><td>min(max(2, 1000 - (1000 * memoryRequestBytes) &#x2F; machineMemoryCapacityBytes), 999)</td></tr></tbody></table><blockquote><p>说明：kubelet 还将具有 system-node-critical <a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/#pod-priority">优先级</a> 的 Pod 中的容器 oom_score_adj 值设为 -997。</p></blockquote><p>如果 kubelet 在节点遇到 OOM 之前无法回收内存， 则 oom_killer 根据它在节点上使用的内存百分比计算 oom_score， 然后加上 oom_score_adj 得到每个容器有效的 oom_score。 然后它会杀死得分最高的容器。</p><p>这意味着低 QoS Pod 中相对于其调度请求消耗内存较多的容器，将首先被杀死。</p><p>与 Pod 驱逐不同，如果容器被 OOM 杀死， kubelet 可以根据其 RestartPolicy 重新启动它。</p><h3 id="磁盘容量不足触发的驱逐"><a href="#磁盘容量不足触发的驱逐" class="headerlink" title="磁盘容量不足触发的驱逐"></a>磁盘容量不足触发的驱逐</h3><p>​      当不可压缩资源（内存、磁盘）不足时，节点上的 Kubelet 会尝试驱逐掉某些 Pod，以释放资源，防止整个系统受到影响。</p><p>其中，磁盘资源不足的信号来源有两个：</p><ul><li>imagefs：容器运行时用作存储镜像、可写层的文件系统</li><li>nodefs：Kubelet 用作卷、守护进程日志的文件系统</li></ul><p>当 imagefs 用量到达驱逐阈值，Kubelet 会删除所有未使用的镜像，释放空间。</p><p>当 nodefs 用量到达阈值，Kubelet 会选择性的驱逐 Pod（及其容器）来释放空间。</p><p>本地临时存储触发的驱逐</p><p>K8S 支持设置每个 Pod 可以使用的临时存储的 request&#x2F;limit，驱逐行为可以更具有针对性。如果 Pod 使用了超过限制的本地临时存储，Kubelet 将设置驱逐信号，触发 Pod 驱逐流程：</p><ol><li>对于容器级别的隔离，如果一个容器的可写层、日志占用磁盘超过限制，则 Kubelet 标记 Pod 为待驱逐</li><li>对于 Pod 级别的隔离，Pod 总用量限制，是每个容器限制之和。如果各容器用量之和+Pod 的 emptyDir 卷超过 Pod 总用量限制，标记 Pod 为待驱逐</li></ol><h2 id="驱逐问题最佳实践"><a href="#驱逐问题最佳实践" class="headerlink" title="驱逐问题最佳实践"></a>驱逐问题最佳实践</h2><p>以下部分描述了驱逐配置的最佳实践。</p><h3 id="可调度的资源和驱逐策略"><a href="#可调度的资源和驱逐策略" class="headerlink" title="可调度的资源和驱逐策略"></a>可调度的资源和驱逐策略</h3><p>当你为 kubelet 配置驱逐策略时， 你应该确保调度程序不会在 Pod 触发驱逐时对其进行调度，因为这类 Pod 会立即引起内存压力。</p><p>考虑以下场景：</p><ul><li>节点内存容量：10Gi</li><li>操作员希望为系统守护进程（内核、kubelet 等）保留 10% 的内存容量</li><li>操作员希望在节点内存利用率达到 95% 以上时驱逐 Pod，以减少系统 OOM 的概率。</li></ul><p>为此，kubelet 启动设置如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">--eviction-hard=memory.available&lt;500Mi<br>--system-reserved=memory=1.5Gi<br></code></pre></td></tr></table></figure><p>在此配置中，–system-reserved 标志为系统预留了 1.5Gi 的内存， 即 总内存的 10% + 驱逐条件量。</p><p>如果 Pod 使用的内存超过其请求值或者系统使用的内存超过 1Gi， 则节点可以达到驱逐条件，这使得 memory.available 信号低于 500Mi 并触发条件。</p><h3 id="DaemonSet驱逐"><a href="#DaemonSet驱逐" class="headerlink" title="DaemonSet驱逐"></a>DaemonSet驱逐</h3><p>Pod 优先级是做出驱逐决定的主要因素。 如果你不希望 kubelet 驱逐属于 DaemonSet 的 Pod， 请在 Pod 规约中为这些 Pod 提供足够高的 priorityClass。 你还可以使用优先级较低的 priorityClass 或默认配置， 仅在有足够资源时才运行 DaemonSet Pod。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TKE集群中Nginx-ingress常用案例</title>
      <link href="/post/26d138ca.html"/>
      <url>/post/26d138ca.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Ingress简介"><a href="#一、Ingress简介" class="headerlink" title="一、Ingress简介"></a>一、Ingress简介</h2><blockquote><p><a href="https://kubernetes.github.io/ingress-nginx/">nginx-ingress官方文档介绍</a></p></blockquote><p>在Kubernetes中，服务和Pod的IP地址仅可以在集群网络内部使用，对于集群外的应用是不可见的。为了使外部的应用能够访问集群内的服务，在Kubernetes 目前 提供了以下几种方案：</p><ul><li>NodePort类型</li><li>LoadBalancer类型</li><li>Ingress</li></ul><p><strong>1，Ingress组成</strong></p><ul><li>ingress controller：实际 Nginx 负载，会 watch kubernetes ingress 对象的变化更新在集群中，将新加入的Ingress转化成Nginx的配置文件并使之生效</li><li>ingress服务：将Nginx的配置抽象成一个Ingress对象，每添加一个新的服务只需写一个新的Ingress的yaml文件即可</li></ul><p><strong>2，Ingress工作原理</strong></p><ol><li>ingress controller通过和kubernetes api交互，动态的去感知集群中ingress规则变化，</li><li>然后读取它，按照自定义的规则，规则就是写明了哪个域名对应哪个service，生成一段nginx配置，</li><li>再写到nginx-ingress-control的pod里，这个Ingress controller的pod里运行着一个Nginx服务，控制器会把生成的nginx配置写入&#x2F;etc&#x2F;nginx.conf文件中，</li><li>然后reload一下使配置生效，以此达到域名分配置和动态更新的问题。</li></ol><p><strong>3，Ingress 可以解决什么问题</strong></p><ul><li>动态配置服务</li></ul><p>如果按照传统方式， 当新增加一个服务时，我们可能需要在流量入口加一个反向代理指向我们新的k8s服务. 而如果用了Ingress, 只需要配置好这个服务, 当服务启动时，自动注册到Ingress的中, 不需要额外的操作.</p><ul><li>减少不必要的端口暴露</li></ul><p>配置过k8s的都清楚，第一步是要关闭防火墙的, 主要原因是k8s的很多服务会以NodePort方式映射出去，这样就相当于给宿主机打了很端口， 既不安全也不优雅. 而Ingress可以避免这个问题, 除了Ingress自身服务可能需要映射出去，其他服务都不要用NodePort方式 </p><h2 id="二、部署安装"><a href="#二、部署安装" class="headerlink" title="二、部署安装"></a>二、部署安装</h2><p>见组件管理</p><h2 id="三、相关案例"><a href="#三、相关案例" class="headerlink" title="三、相关案例"></a>三、相关案例</h2><p>环境准备：</p><ul><li>创建TKE集群</li><li>安装nginx-ingress组件</li><li>域名和证书</li></ul><p>部署nginx服务用于测试和验证</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-249-130-tlinux ~]# kubectl -n  nginx-ingress get svc -o wide<br>NAME       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE     SELECTOR<br>nginx-v1   ClusterIP   172.16.252.224   &lt;none&gt;        80/TCP    13m     app=nginx,version=v1<br>nginx-v2   ClusterIP   172.16.252.208   &lt;none&gt;        80/TCP    13m     app=nginx,version=v2<br>nginx-v3   ClusterIP   172.16.254.220   &lt;none&gt;        80/TCP    7m40s   app=nginx,version=v3<br>nginx-v4   ClusterIP   172.16.255.165   &lt;none&gt;        80/TCP    6m13s   app=nginx,version=v4<br>[root@VM-249-130-tlinux ~]# curl http://172.16.252.224:80<br>nginx-v1<br>[root@VM-249-130-tlinux ~]# curl http://172.16.252.208:80<br>nginx-v2<br>[root@VM-249-130-tlinux ~]# curl http://172.16.254.220:80<br>nginx-v3<br>[root@VM-249-130-tlinux ~]# curl http://172.16.255.165:80<br>nginx-v4<br></code></pre></td></tr></table></figure><p>表示访问对应的service 成功的</p><h3 id="案例1-最简单基础配置"><a href="#案例1-最简单基础配置" class="headerlink" title="案例1 最简单基础配置"></a>案例1 最简单基础配置</h3><p>yaml示例如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/use-regex:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">nginx-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">nginx.chen1900s.cn</span>      <span class="hljs-comment">#相当于定义了nginx的一个server_name</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-v1</span>  <span class="hljs-comment">#定义后端的service</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span>                 <span class="hljs-comment">#一个path就相当于一个location，path的值必须为“/”。这里为匹配的规则，根表示默认请求转发规则</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">ImplementationSpecific</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">nginx.chen1900s.cn</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-v2</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/.*.(txt|css|doc)</span>  <span class="hljs-comment">#可以进入到ingress controller查看nginx的配置,这里相当于把结尾为txt,css,doc的url请求转发到nginx-v2 service</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">ImplementationSpecific</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">nginx.chen1900s.cn</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-v3</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/(api|app)/</span>       <span class="hljs-comment">#这里相当于将api和app开头的目录语法转发至nginx-v3 service</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">ImplementationSpecific</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">nginx.chen1900s.cn</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-v4</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/api</span>           <span class="hljs-comment">#这里相当于将api开头的url（可以是一个文件，也可以是一个目录）的请求，转发到nginx-4</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">ImplementationSpecific</span><br><span class="hljs-comment">#如果上面的都没匹配到，则默认转到“/”  也就是nginx-v1</span><br></code></pre></td></tr></table></figure><p>执行以下命令，访问Nginx服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># curl nginx.chen1900s.cn    #默认转发规则</span><br>nginx-v1<br><span class="hljs-comment"># curl nginx.chen1900s.cn/nginx.txt  #结尾为txt,css,doc的url请求转发到nginx-v2 service</span><br>nginx-v2<br><span class="hljs-comment"># curl nginx.chen1900s.cn/nginx.css  #结尾为txt,css,doc的url请求转发到nginx-v2 service</span><br>nginx-v2<br><span class="hljs-comment"># curl nginx.chen1900s.cn/nginx.doc  #结尾为txt,css,doc的url请求转发到nginx-v2 service</span><br>nginx-v2<br><span class="hljs-comment"># curl nginx.chen1900s.cn/api/       #将api和app开头的目录语法转发至nginx-v3 service</span><br>nginx-v3<br><span class="hljs-comment"># curl nginx.chen1900s.cn/api/hello  #将api和app开头的目录语法转发至nginx-v3 service</span><br>nginx-v3<br><span class="hljs-comment"># curl nginx.chen1900s.cn/app/       #将api和app开头的目录语法转发至nginx-v3 service</span><br>nginx-v3<br><span class="hljs-comment"># curl nginx.chen1900s.cn/api        将api开头的url（可以是一个文件，也可以是一个目录）的请求，转发到nginx-4</span><br>nginx-v4<br><span class="hljs-comment"># curl nginx.chen1900s.cn/api111      将api开头的url（可以是一个文件，也可以是一个目录）的请求，转发到nginx-4</span><br>nginx-v4<br><span class="hljs-comment"># curl nginx.chen1900s.cn/app        #默认转发到/ nginx-v1上面</span><br>nginx-v1<br></code></pre></td></tr></table></figure><p> annotations配置作用于server </p><blockquote><p>指定了我们使用后端ingress controller的类别，如果后端有多个ingress controller的时候很重要<br>kubernetes.io&#x2F;ingress.class: “nginx”<br>指定我们的rules的path可以使用正则表达式，如果我们没有使用正则表达式，此项则可不使用<br>nginx.ingress.kubernetes.io&#x2F;use-regex: “true”</p></blockquote><p> 说明：</p><blockquote><p>上面定义的所有path到ingress controller都将会转换成nginx location规则，那么关于location的优先级与nginx一样，path转换到nginx后，会将path规则最长的排在最前面，最短的排在最后面。 </p></blockquote><h3 id="案例2-个性化配置"><a href="#案例2-个性化配置" class="headerlink" title="案例2 个性化配置"></a>案例2 个性化配置</h3><p> 在案例1的基础上面我们可以增加了annotations的一些配置 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kubernetes.io/ingress.class: &quot;nginx&quot;<br>nginx.ingress.kubernetes.io/use-regex: &quot;true&quot;<br><br>#连接超时时间，默认为5s<br>nginx.ingress.kubernetes.io/proxy-connect-timeout: &quot;600&quot;<br><br>#后端服务器回转数据超时时间，默认为60s<br>nginx.ingress.kubernetes.io/proxy-send-timeout: &quot;600&quot;<br><br>#后端服务器响应超时时间，默认为60s<br>nginx.ingress.kubernetes.io/proxy-read-timeout: &quot;600&quot;<br><br>#客户端上传文件，最大大小，默认为20m<br>nginx.ingress.kubernetes.io/proxy-body-size: &quot;10m&quot;<br></code></pre></td></tr></table></figure><h3 id="案例3-配置URL重定向rewrite-target"><a href="#案例3-配置URL重定向rewrite-target" class="headerlink" title="案例3 配置URL重定向rewrite-target"></a>案例3 配置URL重定向rewrite-target</h3><p>使用Nginx Ingress Controller的时候，Nginx会将路径完整转发到后端（如，从Ingress访问的&#x2F;service1&#x2F;api路径会直接转发到后端Pod的&#x2F;service1&#x2F;api&#x2F;路径）。如果您后端的服务路径为&#x2F;api，则会出现路径错误，导致404的情况。该情况下，您可以通过配置<code>rewrite-target</code>的方式，来将路径重写至需要的目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">nginx.ingress.kubernetes.io/rewrite-target: /$2<br></code></pre></td></tr></table></figure><p>完整配置如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/use-regex:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="hljs-string">/$2</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">nginx-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">nginx.chen1900s.cn</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-v1</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/svc(/|$)(.*)</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">ImplementationSpecific</span><br><br></code></pre></td></tr></table></figure><h3 id="案例4-rewrite配置二"><a href="#案例4-rewrite配置二" class="headerlink" title="案例4 rewrite配置二"></a>案例4 rewrite配置二</h3><p>匹配请求头，主要用于根据请求头信息将用户请求转发到不同的应用，比如根据不同的客户端转发请求</p><ul><li><code>nginx.ingress.kubernetes.io/server-snippet</code>：扩展配置到Server章节。</li><li><code>nginx.ingress.kubernetes.io/configuration-snippet</code>：扩展配置到Location章节。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">annotations:<br>     nginx.ingress.kubernetes.io/server-snippet: |<br>         rewrite ^/v4/(.*)/card/query http://www.chen1900s.cn/v5/#!/card/query permanent;<br>     nginx.ingress.kubernetes.io/configuration-snippet: |<br>         rewrite ^/v6/(.*)/card/query http://www.chen1900s.cn/v7/#!/card/query permanent;<br></code></pre></td></tr></table></figure><p>示例配置生成的nginx.conf如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">## start server www.chen1900s.cn<br>    server &#123;<br>        server_name www.chen1900s.cn ;<br>        listen 80;<br>        listen [::]:80;<br>        set $proxy_upstream_name &quot;-&quot;;<br>    ### server-snippet配置。<br>        rewrite ^/v4/(.*)/card/query http://www.chen1900s.cn/v5/#!/card/query permanent;<br>        ...<br>    ### configuration-snippet配置。<br>      rewrite ^/v6/(.*)/card/query http://www.chen1900s.cn/v7/#!/card/query permanent;<br>      ...<br>    &#125;<br>    ## end server www.chen1900s.cn<br></code></pre></td></tr></table></figure><p>这里直接使用了“nginx.ingress.kubernetes.io&#x2F;server-snippet”来指定配置，这里可以直接写nginx的配置，通过这里可以不止是实现rewrite重写，还可以实现更多的功能需求，只要是作用于server的都可以 </p><h3 id="案例5-域名登录认证"><a href="#案例5-域名登录认证" class="headerlink" title="案例5 域名登录认证"></a>案例5 域名登录认证</h3><p>有时候我们的服务没有提供登录认证，但是有不希望将服务提供给所有的人都能访问，那么可以通过ingress上的认证控制访问，常用的2种认证方式。 </p><p><strong>1，基本身份认证</strong></p><p>创建secret 用于访问凭证</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/nginx-ingress]<span class="hljs-comment"># htpasswd -c auth admin</span><br>New password: <br>Re-<span class="hljs-built_in">type</span> new password: <br>Adding password <span class="hljs-keyword">for</span> user admin<br><span class="hljs-comment">#创建secret</span><br>[root@VM-0-17-tlinux ~/nginx-ingress]<span class="hljs-comment">#  kubectl create secret generic basic-auth --from-file=auth -n nginx-ingress</span><br>secret/basic-auth created<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: networking.k8s.io/v1beta1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    kubernetes.io/ingress.class: nginx<br>    kubernetes.io/ingress.rule-mix: &quot;true&quot;<br>    nginx.ingress.kubernetes.io/auth-realm: Authentication Required - admin #请求用户名<br>    nginx.ingress.kubernetes.io/auth-secret: basic-auth  #对应的secret<br>    nginx.ingress.kubernetes.io/auth-type: basic  #认证方式<br>    nginx.ingress.kubernetes.io/use-regex: &quot;true&quot;<br>  name: nginx-basic-auth<br>  namespace: nginx-ingress<br>spec:<br>  rules:<br>  - host: nginx.chen1900s.cn<br>    http:<br>      paths:<br>      - backend:<br>          serviceName: nginx-v1<br>          servicePort: 80<br>        path: /<br><br></code></pre></td></tr></table></figure><p>验证</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#再不输入认真情况下，访问会出现 401 Unauthorized</span><br>[root@VM-249-130-tlinux ~/nginx-ingress]<span class="hljs-comment"># curl -kI https://nginx.chen1900s.cn/ </span><br>HTTP/1.1 401 Unauthorized<br>Date: Sun, 18 Sep 2022 07:10:24 GMT<br>Content-Type: text/html<br>Content-Length: 172<br>Connection: keep-alive<br>WWW-Authenticate: Basic realm=<span class="hljs-string">&quot;Authentication Required - admin&quot;</span><br>Strict-Transport-Security: max-age=15724800; includeSubDomains<br><br><span class="hljs-comment">#携带访问凭证访问</span><br>[root@VM-249-130-tlinux ~/nginx-ingress]<span class="hljs-comment"># curl -kI https://nginx.chen1900s.cn/   -u &#x27;admin:admin123&#x27;</span><br>HTTP/1.1 200 OK<br>Date: Sun, 18 Sep 2022 07:11:32 GMT<br>Content-Type: text/plain<br>Connection: keep-alive<br>Strict-Transport-Security: max-age=15724800; includeSubDomains<br></code></pre></td></tr></table></figure><p><strong>2.2 外部身份验证</strong></p><p>有时候我们有自己的鉴权中心，也是可以使用外部身份进行认证的，这里我们采用<a href="https://httpbin.org/basic-auth/user/passwd%E8%BF%99%E4%B8%AA%E4%BD%9C%E4%B8%BA%E5%A4%96%E9%83%A8%E8%BA%AB%E4%BB%BD%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7%E5%92%8C%E5%AF%86%E7%A0%81user/passwd">https://httpbin.org/basic-auth/user/passwd这个作为外部身份，这个默认账号和密码user/passwd</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: networking.k8s.io/v1beta1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    kubernetes.io/ingress.class: nginx<br>    kubernetes.io/ingress.rule-mix: &quot;true&quot;<br>    nginx.ingress.kubernetes.io/auth-url: https://httpbin.org/basic-auth/user/passwd<br>    nginx.ingress.kubernetes.io/use-regex: &quot;true&quot;<br>  name: nginx-basic-auth-out<br>  namespace: nginx-ingress<br>spec:<br>  rules:<br>  - host: nginx.chen1900s.cn<br>    http:<br>      paths:<br>      - backend:<br>          serviceName: nginx-v1<br>          servicePort: 80<br>        path: /<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># curl -k https://nginx.chen1900s.cn/  -v -H &#x27;Host: nginx.chen1900s.cn&#x27;  -u &#x27;user:passwd&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181519636.png" alt="image-20220918151952442"></p><h3 id="案例6-访问白名单"><a href="#案例6-访问白名单" class="headerlink" title="案例6 访问白名单"></a>案例6 访问白名单</h3><p>有时候我们需要给域名配置下访问白名单，只希望部分ip可以访问我的服务，这时候需要用到ingress的whitelist-source-range，我们可以通过这个注解来配置我们希望放通访问的ip。下面我们只放通81.69.221.19 也可以指定某一网段 可以访问 </p><blockquote><p>该案例需要nginx-ingress能够正常获取到客户端源IP，nginx-ingress-controller 对应的service需要是local模式 或者直连POD模式</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">kubernetes.io/ingress.rule-mix:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/whitelist-source-range:</span> <span class="hljs-number">81.69</span><span class="hljs-number">.221</span><span class="hljs-number">.19</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/use-regex:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-whitelist-ip</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">nginx-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">nginx.chen1900s.cn</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-v2</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><p>源IP未81.69.221.19正常访问</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-33-tlinux ~]<span class="hljs-comment"># curl myip.ipip.net</span><br>当前 IP：81.69.221.19  来自于：中国 上海 上海  电信<br>[root@VM-0-33-tlinux ~]<span class="hljs-comment"># curl http://nginx.chen1900s.cn</span><br>nginx-v2<br></code></pre></td></tr></table></figure><p>其他客户端禁止访问</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@172-16-155-8 ~]<span class="hljs-comment"># curl myip.ipip.net</span><br>当前 IP：121.5.26.195  来自于：中国 上海 上海  电信<br>[root@172-16-155-8 ~]<span class="hljs-comment"># curl http://nginx.chen1900s.cn</span><br>&lt;html&gt;<br>&lt;<span class="hljs-built_in">head</span>&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181531107.png" alt="image-20220918153106012"></p><h3 id="案例7-永久重定向配置重定向错误码"><a href="#案例7-永久重定向配置重定向错误码" class="headerlink" title="案例7  永久重定向配置重定向错误码"></a>案例7  永久重定向配置重定向错误码</h3><p> redirect主要用于域名重定向，比如访问a.com被重定向到b.com。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">nginx.ingress.kubernetes.io/permanent-redirect: https://www.baidu.com<br>nginx.ingress.kubernetes.io/permanent-redirect-code: &quot;308&quot;<br></code></pre></td></tr></table></figure><h3 id="案例8-客户端请求body的大小"><a href="#案例8-客户端请求body的大小" class="headerlink" title="案例8 客户端请求body的大小"></a>案例8 客户端请求body的大小</h3><p>如果遇到请求报错是 413 Request Entity Too Large </p><p>可以配置客户端请求body的大小，创建 ingress 时添加 annotations（注释）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">metadata:<br>  annotations:<br>    nginx.ingress.kubernetes.io/proxy-body-size: 1024m<br></code></pre></td></tr></table></figure><h3 id="案例9-414-Request-URI-too-large或400-bad-request错"><a href="#案例9-414-Request-URI-too-large或400-bad-request错" class="headerlink" title="案例9  414 Request URI too large或400 bad request错"></a>案例9  414 Request URI too large或400 bad request错</h3><p>如遇到调用后端接口时候，需要在header中传一段很长的token，会报”414 Request URI too large”，可以登陆nginx-ingress-controller pod里查看配置</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181553609.png" alt="image-20220918155331525"></p><p>解决方法是修改两个参数</p><p>参数一：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#client_header_buffer_size：客户端请求头缓冲区大小，</span><br>client_header_buffer_size 128k;<span class="hljs-comment">#如果请求头总长度大于小于128k，则使用此缓冲区</span><br></code></pre></td></tr></table></figure><p>参数二：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#large_client_header_buffers：请求头总长度大于128k时使用large_client_header_buffers设置的缓存区</span><br>large_client_header_buffers 4 128k;<br><span class="hljs-comment">#large_client_header_buffers 指令参数4为个数，128k为大小，默认是8k。申请4个128k。</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">data:</span><br>  <span class="hljs-attr">client-header-buffer-size:</span> <span class="hljs-string">128k</span>      <span class="hljs-comment">#注意参数是中横线</span><br>  <span class="hljs-attr">large-client-header-buffers:</span> <span class="hljs-number">4</span> <span class="hljs-string">128k</span>   <span class="hljs-comment">#注意参数是中横线</span><br>  <span class="hljs-attr">allow-backend-server-header:</span> <span class="hljs-string">&quot;true&quot;</span><br>  <span class="hljs-attr">enable-underscores-in-headers:</span> <span class="hljs-string">&quot;true&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181557022.png" alt="image-20220918155742919"></p><h3 id="案例10-上传超时-504：Gateway-Timeout"><a href="#案例10-上传超时-504：Gateway-Timeout" class="headerlink" title="案例10 上传超时 504：Gateway Timeout"></a>案例10 上传超时 504：Gateway Timeout</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>　　 <span class="hljs-string">nginx.ingress.kubernetes.io/proxy-connect-timeout：&quot;300&quot;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/proxy-send-timeout:</span> <span class="hljs-string">&quot;300&quot;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/proxy-read-timeout:</span> <span class="hljs-string">&quot;300&quot;</span><br>    <br>    <br><span class="hljs-comment">#连接超时时间，默认为5s</span><br><span class="hljs-attr">nginx.ingress.kubernetes.io/proxy-connect-timeout:</span> <span class="hljs-string">&quot;300&quot;</span><br><span class="hljs-comment">#后端服务器回转数据超时时间，默认为60s</span><br><span class="hljs-attr">nginx.ingress.kubernetes.io/proxy-send-timeout:</span> <span class="hljs-string">&quot;300&quot;</span><br><span class="hljs-comment">#后端服务器响应超时时间，默认为60s</span><br><span class="hljs-attr">nginx.ingress.kubernetes.io/proxy-read-timeout:</span> <span class="hljs-string">&quot;300&quot;</span><br></code></pre></td></tr></table></figure><h3 id="案例11-白名单及请求速率限制"><a href="#案例11-白名单及请求速率限制" class="headerlink" title="案例11  白名单及请求速率限制"></a>案例11  白名单及请求速率限制</h3><p> 可以限制速率来降低后端压力，比如如下配置： </p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">nginx-ingress</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/limit-rate:</span> <span class="hljs-string">&quot;100K&quot;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/limit-whitelist:</span> <span class="hljs-number">81.69</span><span class="hljs-number">.221</span><span class="hljs-number">.19</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/limit-rps:</span> <span class="hljs-string">&quot;1&quot;</span>  <span class="hljs-comment">#为每秒1个连接数</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/limit-rpm:</span> <span class="hljs-string">&quot;5&quot;</span>  <span class="hljs-comment">#单个IP每分钟的连接数</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">nginx.chen1900s.cn</span> <br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-v4</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>用以设置基于流量、请求连接数、请求频率的访问控制。访问控制配置说明如下表所示。 </p><table><thead><tr><th align="center">注解</th><th align="center">类型&#x2F;选项</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;limit-rate</td><td align="center">number</td><td align="center">访问流量速度限制，同 Nginx 配置指令 limit_rate</td></tr><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;limit-rate-after</td><td align="center">number</td><td align="center">启用访问流量速度限制的最大值，同 Nginx 配置指令 limit_rate_after</td></tr><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;limit-connections</td><td align="center">number</td><td align="center">节并发连接数限制，同 Nginx 配置指令 limit_conn</td></tr><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;limit-rps</td><td align="center">number</td><td align="center">每秒请求频率限制，burst 参数为给定值的 5 倍，响应状态码由 ConfigMap 的 limit-req-status-code 设定</td></tr><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;limit-rpm</td><td align="center">number</td><td align="center">每分钟请求频率限制，burst 参数为给定值的 5 倍，响应状态码由 ConfigMap 的 limit-req-status-code 设定</td></tr><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;limit-whitelist</td><td align="center">CIDR</td><td align="center">对以上限制设置基于 IP 的白名单</td></tr></tbody></table><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181622635.png" alt="image-20220918162246526"></p><h3 id="案例12-配置URL重定向的路由服"><a href="#案例12-配置URL重定向的路由服" class="headerlink" title="案例12 配置URL重定向的路由服"></a>案例12 配置URL重定向的路由服</h3><p>通过以下命令创建一个简单的Ingress，所有对&#x2F;svc路径的访问都会重新定向到后端服务能够识别的&#x2F;路径上面。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="hljs-string">/$1</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">rewrite-nginx-ingress</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">nginx-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">rewrite-nginx-ingress.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-v1</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/svc/(.*)</span><br><br><br></code></pre></td></tr></table></figure><p>执行以下命令，访问Nginx服务，替换<strong>IP_ADDRESS</strong>为Ingress对应的I</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#curl -k -H &quot;Host: rewrite-test-ingress.com&quot;  http://&lt;IP_ADDRESS&gt;/svc/foo</span><br><br><span class="hljs-comment"># curl -k -H &quot;Host: rewrite-nginx-ingress.com&quot;  http://118.24.224.221/svc/foo</span><br>nginx-v1<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181626193.png" alt="image-20220918162633115"></p><h3 id="案例13-配置安全的路由服务"><a href="#案例13-配置安全的路由服务" class="headerlink" title="案例13 配置安全的路由服务"></a>案例13 配置安全的路由服务</h3><p>支持多证书管理，为您的服务提供安全防护。</p><p>1，准备您的服务证书。如果没有证书，可以通过下面的方法生成测试证书。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">说明** 域名需要与您的Ingress配置保持一致。 **<br></code></pre></td></tr></table></figure><ul><li>执行以下命令，生成一个证书文件tls.crt和一个私钥文件tls.key</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj <span class="hljs-string">&quot;/CN=tls-nginx-ingress.com/O=tls-nginx-ingress.com&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>执行以下命令，创建密钥。</p><p>通过该证书和私钥创建一个名为tls-nginx-ingress的Kubernetes Secret。创建Ingress时需要引用这个Secret。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl create secret tls tls-nginx-ingress --key tls.key --cert tls.crt  -n nginx-ingress<br></code></pre></td></tr></table></figure></li></ul><p>2，执行以下命令，创建一个安全的Ingress服务。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">tls-nginx-ingress</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">nginx-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">tls-nginx-ingress.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-v2</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>  <span class="hljs-attr">tls:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tls-nginx-ingress.com</span><br>    <span class="hljs-attr">secretName:</span> <span class="hljs-string">tls-nginx-ingress</span><br></code></pre></td></tr></table></figure><p>3，执行以下命令，查询Ingress信息。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># kubectl  get ingress -n nginx-ingress | grep tls</span><br>tls-nginx-ingress       &lt;none&gt;   tls-nginx-ingress.com       114.117.219.97   80, 443   4m3s<br></code></pre></td></tr></table></figure><p>4，配置<code>hosts</code>文件或者设置域名来访问该TLS服务</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130053.png" alt="image-20211021151855901"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130095.png" alt="image-20211125174832750"></p><h3 id="案例14-配置HTTPS双向认证"><a href="#案例14-配置HTTPS双向认证" class="headerlink" title="案例14 配置HTTPS双向认证"></a>案例14 配置HTTPS双向认证</h3><p>某些业务场景需要启用HTTPS双向验证，Ingress-Nginx支持该特性，配置步骤参考以下示例。</p><p>1，执行以下命令，创建自签的CA证书。 </p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">openssl req -x509 -sha256 -newkey rsa:4096 -keyout ca.key -out ca.crt -days 356 -nodes -subj <span class="hljs-string">&#x27;/CN=Fern Cert Authority&#x27;</span><br></code></pre></td></tr></table></figure><p>2，执行以下命令，创建Server端证书。</p><p>执行以下命令，生成Server端证书的请求文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">openssl req -new -newkey rsa:4096 -keyout server.key -out server.csr -nodes -subj <span class="hljs-string">&#x27;/CN=test.nginx.ingress.com&#x27;</span><br></code></pre></td></tr></table></figure><p> 执行以下命令，使用根证书签发Server端请求文件，生成Server端证书</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">openssl x509 -req -sha256 -days 365 -<span class="hljs-keyword">in</span> server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt<br></code></pre></td></tr></table></figure><p>3，执行以下命令，创建Client端证书。</p><p>  生成Client端证书的请求文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">openssl req -new -newkey rsa:4096 -keyout client.key -out client.csr -nodes -subj <span class="hljs-string">&#x27;/CN=Fern&#x27;</span><br></code></pre></td></tr></table></figure><p> 执行以下命令，使用根证书签发Client端请求文件，生成Client端证书。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">openssl x509 -req -sha256 -days 365 -<span class="hljs-keyword">in</span> client.csr -CA ca.crt -CAkey ca.key -set_serial 02 -out client.crt<br></code></pre></td></tr></table></figure><p>4，执行以下命令，检查创建的证书</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># ls</span><br>ca.crt  ca.key  client.crt  client.csr  client.key  server.crt  server.csr  server.key<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130150.png" alt="image-20211021160303691"></p><p>5，执行以下命令，创建CA证书的Secret。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl create secret generic ca-secret --from-file=ca.crt=ca.crt  -n nginx-ingress<br></code></pre></td></tr></table></figure><p>6，执行以下命令，创建Server证书的Secret。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl create secret tls  tls-secret --cert server.crt --key server.key  -n nginx-ingress<br><br></code></pre></td></tr></table></figure><p>7，执行以下命令，创建测试用的Ingress用例。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">description:</span> <span class="hljs-string">配置HTTPS双向认证</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">kubernetes.io/ingress.rule-mix:</span> <span class="hljs-string">&quot;false&quot;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/auth-tls-pass-certificate-to-upstream:</span> <span class="hljs-string">&quot;true&quot;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/auth-tls-secret:</span> <span class="hljs-string">nginx-ingress/ca-secret</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/auth-tls-verify-client:</span> <span class="hljs-string">&quot;on&quot;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/auth-tls-verify-depth:</span> <span class="hljs-string">&quot;1&quot;</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-nginx-ingress</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">nginx-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">test.nginx.ingress.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-a</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br><br></code></pre></td></tr></table></figure><p>8，执行以下命令，查看Ingress的IP地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># kubectl  get ingress -n nginx-ingress | grep test</span><br>test-nginx-ingress      &lt;none&gt;   test.nginx.ingress.com      114.117.219.97   80        3m34s<br></code></pre></td></tr></table></figure><p>9，执行以下命令，更新Hosts文件，替换下面的IP地址为真实获取的Ingress的IP地址。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;114.117.219.97 test.nginx.ingress.com&quot;</span> &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><p><strong>结果验证</strong></p><p>客户端不传证书访问</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl --cacert ./ca.crt  https://test.nginx.ingress.com<br><span class="hljs-comment">#预期输出</span><br>[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># curl --cacert ./ca.crt  https://test.nginx.ingress.com</span><br>&lt;html&gt;<br>&lt;<span class="hljs-built_in">head</span>&gt;&lt;title&gt;400 No required SSL certificate was sent&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt;<br>&lt;center&gt;No required SSL certificate was sent&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>客户端传证书访问</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl --cacert ./ca.crt --cert ./client.crt --key ./client.key https://test.nginx.ingress.com<br><span class="hljs-comment">#预期输出</span><br>[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># curl --cacert ./ca.crt --cert ./client.crt --key ./client.key https://test.nginx.ingress.com</span><br>nginx-a hello world<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130187.png" alt="image-20211021163648495"></p><h3 id="案例15-配置域名支持正则化"><a href="#案例15-配置域名支持正则化" class="headerlink" title="案例15 配置域名支持正则化"></a>案例15 配置域名支持正则化</h3><p>在Kubernetes集群中，Ingress资源不支持对域名配置正则表达式，但是可以通过<code>nginx.ingress.kubernetes.io/server-alias</code>注解来实现</p><p>1，创建Ingress，以正则表达式<code>~^www\.\d+\.example\.com</code>为例。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">apiVersion: networking.k8s.io/v1beta1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    description: 配置域名支持正则化<br>    kubernetes.io/ingress.class: nginx<br>    nginx.ingress.kubernetes.io/server-alias: ~^www\.\d+\.example\.com$, abc.example.com<br>  name: regex-nginx-ingress<br>  namespace: nginx-ingress<br>spec:<br>  rules:<br>  - host: regex-nginx-ingress.com<br>    http:<br>      paths:<br>      - backend:<br>          serviceName: nginx-b<br>          servicePort: 80<br>        path: /<br></code></pre></td></tr></table></figure><p>2，执行以下命令，查看对应Nginx Ingress Controller的配置。</p><p>​      执行以下命令，查看部署Nginx Ingress Controller服务的Pod。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># kubectl  get pods -n kube-system  | grep nginx-ingress-nginxnginx-ingress-nginx-controller-5ddf7ccc4f-vss4f                   1/1     Running   0          5h13m</span><br></code></pre></td></tr></table></figure><p>​    执行以下命令，查看对应Nginx Ingress Controller的配置，可以发现生效的配置（Server_Name字段）</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># kubectl  -n kube-system exec nginx-ingress-ingress-nginx-controller-7dc5fd97f-t9l9l cat /etc/nginx/nginx.conf | grep -C3  &quot;regex-nginx-ingress.com&quot;</span><br>kubectl <span class="hljs-built_in">exec</span> [POD] [COMMAND] is DEPRECATED and will be removed <span class="hljs-keyword">in</span> a future version. Use kubectl kubectl <span class="hljs-built_in">exec</span> [POD] -- [COMMAND] instead.<br>        &#125;<br>        <span class="hljs-comment">## end server _</span><br><br>        <span class="hljs-comment">## start server regex-nginx-ingress.com</span><br>        server &#123;<br>                server_name regex-nginx-ingress.com abc.example.com ~^www\.\d+\.example\.com$ ;<br><br>                listen 80  ;<br>                listen 443  ssl ;<br>--<br>                &#125;<br><br>        &#125;<br>        <span class="hljs-comment">## end server regex-nginx-ingress.com</span><br><br>        <span class="hljs-comment">## start server rewrite-nginx-ingress.com</span><br>        server &#123;<br></code></pre></td></tr></table></figure><p>3，执行以下命令，获取Ingress对应的IP。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># kubectl get ingress -n nginx-ingress  | grep regex</span><br>regex-nginx-ingress     &lt;none&gt;   regex-nginx-ingress.com     114.117.219.97   80        12m<br></code></pre></td></tr></table></figure><p>4，执行以下命令，进行不同规则下的服务访问测试，配置以下<strong>IP_ADDRESS</strong>为上一步获取的IP地址。</p><p>执行以下命令，通过<code>Host: regex-nginx-ingress.com </code>访问服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># curl -H &quot;Host: regex-nginx-ingress.com&quot;  114.117.219.97/</span><br><br>nginx-b<br></code></pre></td></tr></table></figure><p>执行以下命令，通过<code>Host: www.123.example.com</code>访问服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># curl -H &quot;Host: www.123.example.com&quot;  114.117.219.97/</span><br>nginx-b<br></code></pre></td></tr></table></figure><p>执行以下命令，通过<code>Host: www.321.example.com</code>访问服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># curl -H &quot;Host:  www.321.example.com&quot;  114.117.219.97/</span><br>nginx-b<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130222.png" alt="image-20211021170658628"></p><h3 id="案例16-配置域名支持泛化"><a href="#案例16-配置域名支持泛化" class="headerlink" title="案例16 配置域名支持泛化"></a>案例16 配置域名支持泛化</h3><p>在Kubernetes集群中，Ingress资源支持对域名配置泛域名，例如，可配置<code>*.ingress-regex.com</code>泛域名。</p><p>1，部署以下模板，创建Ingress</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">apiVersion: networking.k8s.io/v1beta1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    kubernetes.io/ingress.class: nginx<br>  name: regex-ingress<br>  namespace: nginx-ingress<br>spec:<br>  rules:<br>  - host: <span class="hljs-string">&#x27;*.regex-ingress.com&#x27;</span><br>    http:<br>      paths:<br>      - backend:<br>          serviceName: nginx-c<br>          servicePort: 80<br>        path: /<br><br></code></pre></td></tr></table></figure><p>2，执行以下命令，查看对应Nginx Ingress Controller的配置，可以发现生效的配置（Server_Name字段）</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> -n kube-system &lt;ningx-ingress-pod-name&gt; <span class="hljs-built_in">cat</span> /etc/nginx/nginx.conf | grep -C3 <span class="hljs-string">&quot;regex-ingress.com&quot;</span><br><br>[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># kubectl  -n kube-system exec nginx-ingress-ingress-nginx-controller-7dc5fd97f-t9l9l cat /etc/nginx/nginx.conf | grep -C3  &quot;regex-ingress.com&quot;</span><br>kubectl <span class="hljs-built_in">exec</span> [POD] [COMMAND] is DEPRECATED and will be removed <span class="hljs-keyword">in</span> a future version. Use kubectl kubectl <span class="hljs-built_in">exec</span> [POD] -- [COMMAND] instead.<br><br>        <span class="hljs-comment"># Global filters</span><br><br>        <span class="hljs-comment">## start server *.regex-ingress.com</span><br>        server &#123;<br>                server_name ~^(?&lt;subdomain&gt;[\w-]+)\.regex-ingress\.com$ ;<br><br>--<br>                &#125;<br><br>        &#125;<br>        <span class="hljs-comment">## end server *.regex-ingress.com</span><br><br>        <span class="hljs-comment">## start server _</span><br>        server &#123;<br></code></pre></td></tr></table></figure><p>执行以下命令，获取Ingress对应的IP</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># kubectl  get ingress -nnginx-ingress | grep regex-ingress.com</span><br><br>regex-ingress           &lt;none&gt;   *.regex-ingress.com         114.117.219.97   80        10m<br></code></pre></td></tr></table></figure><p>4，执行以下命令，进行不同规则下的服务访问测试，配置以下<strong>IP_ADDRESS</strong>为上一步获取的IP地址。</p><p>执行以下命令，通过Host: abc.regex-ingress.com </p><p>访问服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># curl -H &quot;Host: abc.regex-ingress.com&quot; &lt;IP_ADDRESS&gt;/</span><br><br>[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># curl -H &quot;Host: abc.regex-ingress.com&quot;  114.117.219.97/</span><br>nginx-c<br></code></pre></td></tr></table></figure><p>预期输出：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">nginx-c<br></code></pre></td></tr></table></figure><p>执行以下命令，通过<code>Host: 123.regex-ingress.com </code>访问服务。 </p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># curl -H &quot;Host: 123.regex-ingress.com&quot;  114.117.219.97/</span><br>nginx-c<br></code></pre></td></tr></table></figure><p> 执行以下命令，通过<code>Host: a1b1.regex-ingress.com</code>访问服务。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/tls/nginx-ingress]<span class="hljs-comment"># curl -H &quot;Host: ab1.regex-ingress.com&quot;  114.117.219.97/</span><br>nginx-c<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130279.png" alt="image-20211021173344117"></p><h3 id="案例17-cookie会话保持"><a href="#案例17-cookie会话保持" class="headerlink" title="案例17 cookie会话保持"></a>案例17 cookie会话保持</h3><p>nginx.ingress.kubernetes.io&#x2F;session-cookie-name</p><p>默认为round-robin，在具体ingress资源中通过ingress metadata.annotations字段可具体设置</p><p>通过会话cookie进行一致性hash均衡算法</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ingress.kubernetes.io/affinity:</span> <span class="hljs-string">&quot;cookie&quot;</span><br><span class="hljs-attr">ingress.kubernetes.io/session-cookie-name:</span> <span class="hljs-string">&quot;route&quot;</span><br><span class="hljs-attr">ingress.kubernetes.io/session-cookie-hash:</span> <span class="hljs-string">&quot;sha1&quot;</span><br></code></pre></td></tr></table></figure><p>通过客户端ip进行一致性hash的均衡算法</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">nginx.ingress.kubernetes.io/upstream-hash-by:</span> <span class="hljs-string">&quot;$&#123;remote_addr&#125;&quot;</span><br></code></pre></td></tr></table></figure><p> 通过请求uri进行一致性hash的均衡算法</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">nginx.ingress.kubernetes.io/upstream-hash-by:</span> <span class="hljs-string">&quot;$&#123;request_uri&#125;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="案例18-nginx-ingress-开启跨域-CORS"><a href="#案例18-nginx-ingress-开启跨域-CORS" class="headerlink" title="案例18 nginx-ingress 开启跨域(CORS)"></a>案例18 nginx-ingress 开启跨域(CORS)</h3><blockquote><p><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#enable-cors">参考官方文档</a></p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">nginx-ingress</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/cors-allow-headers:</span> <span class="hljs-string">&gt;-</span><br><span class="hljs-string">      DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization</span><br><span class="hljs-string"></span>    <span class="hljs-attr">nginx.ingress.kubernetes.io/cors-allow-methods:</span> <span class="hljs-string">&#x27;PUT, GET, POST, OPTIONS&#x27;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/cors-allow-origin:</span> <span class="hljs-string">&#x27;*&#x27;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/enable-cors:</span> <span class="hljs-string">&#x27;true&#x27;</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/service-weight:</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">cors-nginx-ingress</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">nginx-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">cors-nginx-ingress.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">nginx-v2</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>  <span class="hljs-attr">tls:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">tls-nginx-ingress.com</span><br>    <span class="hljs-attr">secretName:</span> <span class="hljs-string">tls-nginx-ingress</span><br></code></pre></td></tr></table></figure><p>跨域访问功能配置说明如下表所示。</p><table><thead><tr><th align="center">注解</th><th align="center">类型</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;enable-cors</td><td align="center">true 或 false</td><td align="center">是否启用跨域访问支持，默认为 false</td></tr><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;cors-allow-origin</td><td align="center">string</td><td align="center">允许跨域访问的域名，默认为 *，表示接受任意域名的访问</td></tr><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;cors-allow-methods</td><td align="center">string</td><td align="center">允许跨域访问方法，默认为 GET、PUT、POST、DELETE、PATCH、OPTIONS</td></tr><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;cors-allow-headers</td><td align="center">string</td><td align="center">允许跨域访问的请求头，默认为 DNT，X-CustomHeader、Keep-Alive、User-Agent、X-Requested-With、If-Modified-Since、Cache-Control、Content-Type、Authorization</td></tr><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;cors-allow-credentials</td><td align="center">true 或 false</td><td align="center">设置在响应头中 Access-Control-Allow-Credentials 的值，设置是否允许客户端携带验证信息，如 cookie 等，默认为 true</td></tr><tr><td align="center">nginx.ingress.kubernetes.io&#x2F;cors-max-age</td><td align="center">number</td><td align="center">设置响应头中 Access-Control-Max-Age 的值，设置返回结果可以用于缓存的最长时间，默认为 1728000 秒</td></tr></tbody></table><h3 id="案例19-nginx-ingress关闭80强制跳转443"><a href="#案例19-nginx-ingress关闭80强制跳转443" class="headerlink" title="案例19 nginx-ingress关闭80强制跳转443"></a>案例19 nginx-ingress关闭80强制跳转443</h3><p>默认情况下，如果ingress对象入口启用了TLS，则ingress-controller将使用308永久重定向响应将HTTP客户端重定向到HTTPS端口443</p><p>1，执行以下命令，创建一个安全的Ingress服务(<strong>带TLS证书</strong> )</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: networking.k8s.io/v1beta1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    kubernetes.io/ingress.class: nginx-ingress<br>  name: tls-nginx-ingress<br>  namespace: nginx-ingress<br>spec:<br>  rules:<br>  - host: tls-nginx-ingress.com<br>    http:<br>      paths:<br>      - backend:<br>          serviceName: nginx-v2<br>          servicePort: 80<br>        path: /<br>  tls:<br>  - hosts:<br>    - tls-nginx-ingress.com<br>    secretName: tls-nginx-ingress<br></code></pre></td></tr></table></figure><p>2，执行以下命令，返回的是308信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~/tls/nginx-ingress]# curl -I  http://tls-nginx-ingress.com<br>HTTP/1.1 308 Permanent Redirect<br>Date: Thu, 25 Nov 2021 10:07:30 GMT<br>Content-Type: text/html<br>Content-Length: 164<br>Connection: keep-alive<br>Location: https://tls-nginx-ingress.com<br></code></pre></td></tr></table></figure><p>3，可以在特定ingress资源的metadata.annotations中通过配置nginx.ingress.<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&q=kubernetes">kubernetes</a>.io&#x2F;ssl-redirect: “false” 使用注释禁用此功能，关闭80强制跳转443</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: networking.k8s.io/v1beta1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    kubernetes.io/ingress.class: nginx-ingress<br>    nginx.ingress.kubernetes.io/ssl-redirect: &#x27;false&#x27;   #就可以禁止http强制跳转至https<br>  name: tls-nginx-ingress<br>  namespace: nginx-ingress<br>spec:<br>  rules:<br>  - host: tls-nginx-ingress.com<br>    http:<br>      paths:<br>      - backend:<br>          serviceName: nginx-v2<br>          servicePort: 80<br>        path: /<br>  tls:<br>  - hosts:<br>    - tls-nginx-ingress.com<br>    secretName: tls-nginx-ingress<br></code></pre></td></tr></table></figure><p>4，添加annotations后再去访问，就可以正常访问80端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~]# curl -I  http://tls-nginx-ingress.com<br>HTTP/1.1 200 OK<br>Date: Thu, 25 Nov 2021 10:12:47 GMT<br>Content-Type: text/plain<br>Connection: keep-alive<br><br>[root@VM-0-17-tlinux ~]# curl   http://tls-nginx-ingress.com<br>nginx-v2<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130320.png" alt="image-20211125181623891"></p><h3 id="案例20-nginx-ingress中ingress匹配优先级"><a href="#案例20-nginx-ingress中ingress匹配优先级" class="headerlink" title="案例20 nginx-ingress中ingress匹配优先级"></a>案例20 nginx-ingress中ingress匹配优先级</h3><p>首先在nginx中location的匹配优先级大致为：精准匹配 &gt; 前缀匹配 &gt; 正则匹配&gt; &#x2F;</p><p>其中，前缀匹配：^~，精准匹配 &#x3D;，正则匹配细分为：</p><p>~ 区分大小写（大小写敏感）匹配成功；<del>* 不区分大小写匹配成功；!</del> 区分大小写匹配失败；!~*  不区分大小写匹配失败</p><p>而ingress资源对象中，spec.rules.http.paths.path字段默认只支持不区分大小写的正则匹配，但前提需要设置nginx.ingress.kubernetes.io&#x2F;use-regex注释设置</p><p>为true(默认值为false)来启用此功能</p><p>1，根据如下yaml文件创建ingress资源</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: extensions/v1beta1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    kubernetes.io/ingress.class: &quot;nginx-ingress&quot;<br>    nginx.ingress.kubernetes.io/use-regex: &quot;true&quot;<br>  namespace: nginx-ingress<br>  name: use-regex-nginx-ingress<br>spec:<br>  rules:<br>    - host: use-regex-nginx-ingress.com<br>      http:<br>        paths:<br>          - path: /<br>            backend:<br>              serviceName: nginx-v1<br>              servicePort: 80<br>          - path: /wifi<br>            backend:<br>              serviceName: nginx-v2<br>              servicePort: 80<br><br></code></pre></td></tr></table></figure><p>2，进入到ingress-controller的pod中，观察nginx配置文件，发现location的<strong>正则匹配已生效</strong>  </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">root@VM-0-17-tlinux ~]# kubectl  exec -it  nginx-ingress-ingress-nginx-controller-7dc5fd97f-t9l9l  -n  kube-system  /bin/bash<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130362.png" alt="image-20211125184440501"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130393.png" alt="image-20211125184457459"></p><p>3，如果创建时候nginx.ingress.kubernetes.io&#x2F;use-regex: “false”  或者不设置验证下效果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~]# kubectl  exec -it  nginx-ingress-ingress-nginx-controller-7dc5fd97f-t9l9l  -n  kube-system  /bin/bash<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130429.png" alt="image-20211125185055225"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130470.png" alt="image-20211125185129326"></p><h3 id="案例21-支持websocket配置"><a href="#案例21-支持websocket配置" class="headerlink" title="案例21 支持websocket配置"></a>案例21 <strong>支持websocket配置</strong></h3><p>1，准备服务证书。如果没有证书，可以通过下面的方法生成测试证书。</p><pre><code>  说明** 域名需要与您的Ingress配置保持一致。 **</code></pre><p>执行以下命令，生成一个证书文件tls.crt和一个私钥文件tls.key</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">openssl req -x509 -nodes -days 1000 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj &quot;/CN=websocket-nginx-ingress.com/O=websocket-nginx-ingress.com&quot;<br></code></pre></td></tr></table></figure><p>执行以下命令，创建密钥。</p><p>通过该证书和私钥创建一个名为tls-nginx-ingress的Kubernetes Secret。创建Ingress时需要引用这个Secret。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kubectl create secret tls websocket-nginx-ingress --key tls.key --cert tls.crt  -n nginx-ingress<br></code></pre></td></tr></table></figure><p>2，执行以下命令，创建一个安全的Ingress服务 (由于没有websocket，暂时没有做验证)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: networking.k8s.io/v1beta1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    kubernetes.io/ingress.class: nginx-ingress<br>    nginx.ingress.kubernetes.io/configuration-snippet:  &gt;-<br>    nginx.ingress.kubernetes.io/proxy-read-timeout 3600;<br>    nginx.ingress.kubernetes.io/proxy-send-timeout 3600;<br>  name: websocket-nginx-ingress<br>  namespace: nginx-ingress<br>spec:<br>  rules:<br>  - host: websocket-nginx-ingress.com<br>    http:<br>      paths:<br>      - backend:<br>          serviceName: nginx-v2<br>          servicePort: 80<br>        path: /<br>  tls:<br>  - hosts:<br>    - websocket-nginx-ingress.com<br>    secretName: websocket-nginx-ingress<br><br></code></pre></td></tr></table></figure><h3 id="案例22-通过configmap-定义全局常规参数"><a href="#案例22-通过configmap-定义全局常规参数" class="headerlink" title="案例22 通过configmap 定义全局常规参数"></a>案例22 通过configmap 定义全局常规参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">data:<br>  multi_accept: on;<br>  use: epoll;<br>  user: www;<br>  worker_connections: 65535;<br>  worker_cpu_affinity: auto;<br>  worker_processes: auto;<br>  worker_rlimit_nofile: 300000;<br>  <br>  # 把真实IP地址传给后端<br>  compute-full-forwarded-for: &quot;true&quot;<br>  forwarded-for-header: &quot;X-Forwarded-For&quot;<br>  use-forwarded-headers: &quot;true&quot;<br>  <br>  # 关闭版本显示<br>  server-tokens: &quot;false&quot;<br>  <br>  # 客户端请求头的缓冲区大小 <br>  client-header-buffer-size: &quot;512k&quot;<br>  # 设置用于读取大型客户端请求标头的最大值number和size缓冲区<br>  large-client-header-buffers: &quot;16 512k&quot;<br>  <br>  # 读取客户端请求body的缓冲区大小<br>  client-body-buffer-size: &quot;968k&quot;<br>  # 代理缓冲区大小<br>  proxy-buffer-size: &quot;1024k&quot;<br>  # 代理body大小<br>  proxy-body-size: &quot;50m&quot;<br>  # 服务器名称哈希大小<br>  server-name-hash-bucket-size: &quot;128&quot;<br>  # map哈希大小<br>  map-hash-bucket-size: &quot;128&quot;<br>  # SSL加密套件<br>  ssl-ciphers: &quot;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA&quot;<br>  # ssl 协议<br>  ssl-protocols: &quot;TLSv1 TLSv1.1 TLSv1.2&quot;<br>#定义json 访问日志格式<br>log-format-upstream: &#x27;&#123;&quot;time&quot;: &quot;$time_iso8601&quot;, &quot;remote_addr&quot;: &quot;$proxy_protocol_addr&quot;, &quot;x-forward-for&quot;: &quot;$proxy_add_x_forwarded_for&quot;, &quot;request_id&quot;: &quot;$req_id&quot;, &quot;remote_user&quot;: &quot;$remote_user&quot;, &quot;bytes_sent&quot;: $bytes_sent, &quot;request_time&quot;: $request_time, &quot;status&quot;:$status, &quot;vhost&quot;: &quot;$host&quot;, &quot;request_proto&quot;: &quot;$server_protocol&quot;, &quot;path&quot;: &quot;$uri&quot;, &quot;request_query&quot;: &quot;$args&quot;, &quot;request_length&quot;: $request_length, &quot;duration&quot;: $request_time,&quot;method&quot;: &quot;$request_method&quot;, &quot;http_referrer&quot;: &quot;$http_referer&quot;, &quot;http_user_agent&quot;: &quot;$http_user_agent&quot;&#125;&#x27;<br><br></code></pre></td></tr></table></figure><p>更多配置可以参考<a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/">文档</a></p><h3 id="案例23-获取真实IP地址配置"><a href="#案例23-获取真实IP地址配置" class="headerlink" title="案例23 获取真实IP地址配置"></a>案例23 <strong>获取真实IP地址配置</strong></h3><p>nginx-ingress官方是通过修改容器的配置文件来配置，配置文件：ingress-nginx&#x2F;ingress-nginx-controller</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kubectl  edit   cm  -n kube-system nginx-ingress-nginx-controller -o yaml<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">compute-full-forwarded-for: &quot;true&quot;<br>forwarded-for-header: &quot;X-Forwarded-For&quot;<br>use-forwarded-headers: &quot;true&quot;<br></code></pre></td></tr></table></figure><blockquote><p>compute-full-forwarded-for: “true”  &#x2F;&#x2F;如果为真，NGINX 将传入的X-Forwarded-*标头传递给上游。当 NGINX 在设置这些标头的另一个 L7 代理&#x2F;负载均衡器之后使用此选项</p><p>forwarded-for-header: X-Forwarded-For &#x2F;&#x2F;设置用于标识客户端的原始 IP 地址的标头字段。后端程序就可以在http 包的header里的X-Forwarded-For获取真实ip</p><p>use-forwarded-headers: “true”   &#x2F;&#x2F;将远程地址附加到 X-Forwarded-For 标头，而不是用pod或者其它cookie信息替换它。启用此选项后，应用程序负责根据自己的受信任代理列表来提取客户端 IP</p></blockquote><p>保存后立即生效。随后ingress的添加真实的IP行为会与RFC一样都依次添加到X-Forwarded-For中了</p><blockquote><p>在TKE集群环境中，想获取客户端源IP，需要nginx-ingress-controller 是local模式或者POD直连模式才可以，不需要修改配置文件</p></blockquote><p><strong>local模式</strong></p><p>nginx-ingress-controller-service 配置</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181701765.png" alt="image-20220918170155658"></p><p>验证 ingress示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: networking.k8s.io/v1beta1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    kubernetes.io/ingress.class: nginx<br>    kubernetes.io/ingress.rule-mix: &quot;false&quot;<br>    nginx.ingress.kubernetes.io/use-regex: &quot;true&quot;<br>  name: whoami<br>  namespace: nginx-ingress<br>spec:<br>  rules:<br>  - host: whoami.chen1900s.cn<br>    http:<br>      paths:<br>      - backend:<br>          serviceName: whoami<br>          servicePort: 80<br>        path: /<br>        pathType: ImplementationSpecific<br><br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181658981.png" alt="image-20220918165856854"></p><p>直连POD模式参考<a href="https://cloud.tencent.com/document/product/457/48949">TKE官方文档</a></p><h3 id="案例24-nginx-ingress做tcp-x2F-udp4层网络转发"><a href="#案例24-nginx-ingress做tcp-x2F-udp4层网络转发" class="headerlink" title="案例24  nginx-ingress做tcp&#x2F;udp4层网络转发"></a>案例24  nginx-ingress做tcp&#x2F;udp4层网络转发</h3><p>k8s集群通过nginx-ingress做tcp\udp 4层网络转发</p><p>1，检查nginx-ingress是否开启tcp\udp转发</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">- args:<br>  - --tcp-services-configmap=kube-system/nginx-ingress-nginx-tcp<br>  - --udp-services-configmap=kube-system/nginx-ingress-nginx-udp<br></code></pre></td></tr></table></figure><p>2，示例 kuard-demo.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  name: kuard<br>  namespace: nginx-ingress<br>spec:<br>  selector:<br>    matchLabels:<br>      app: kuard<br>  replicas: 1<br>  template:<br>    metadata:<br>      labels:<br>        app: kuard<br>    spec:<br>      containers:<br>      - image: ccr.ccs.tencentyun.com/chenjingwei/kuard-amd64:v1<br>        imagePullPolicy: Always<br>        name: kuard<br>        ports:<br>        - containerPort: 8080<br>        <br>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: kuard<br>  namespace: nginx-ingress<br>spec:<br>  ports:<br>  - port: 9527<br>    targetPort: 8080<br>    protocol: TCP<br>  selector:<br>    app: kuard<br></code></pre></td></tr></table></figure><p>3，需要修改下configmap</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># kubectl  -n kube-system get cm  | grep nginx-ingress-nginx<br>nginx-ingress-nginx-controller                      9      133d<br>nginx-ingress-nginx-tcp                             0      133d<br>nginx-ingress-nginx-udp                             0      133d<br><br># kubectl  -n kube-system edit  cm nginx-ingress-nginx-tcp<br><br>[root@VM-0-17-tlinux ~]# kubectl  -n kube-system get  cm nginx-ingress-nginx-tcp -o yaml<br>apiVersion: v1<br>data:                                   #TKE默认么有data<br>  &quot;9527&quot;: nginx-ingress/kuard:9527      #添加这个配置<br>kind: ConfigMap<br>metadata:<br>  labels:<br>    k8s-app: nginx-ingress-nginx-tcp<br>    qcloud-app: nginx-ingress-nginx-tcp<br>  name: nginx-ingress-nginx-tcp<br>  namespace: kube-system<br><br></code></pre></td></tr></table></figure><p>4，进入nginx-ingress容器查看TCP services处会出现对应的负载配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># kubectl  -n kube-system  exec -it nginx-ingress-nginx-controller-5ddf7ccc4f-v4pzp -- /bin/sh<br><br>vi  nginx.conf  镜像过滤<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br><br># TCP services            <br>                                 <br>       server &#123;<br>               preread_by_lua_block &#123;<br>                       ngx.var.proxy_upstream_name=&quot;tcp-nginx-ingress-kuard-9527&quot;;<br>               &#125;                                 <br><br>               listen                  9527;<br>                                                         <br>               listen                  [::]:9527;<br>                                            <br>               proxy_timeout           600s;  <br>               proxy_pass              upstream_balancer;<br>                                              <br>       &#125;<br></code></pre></td></tr></table></figure><p>5，编辑nginx-ingress-nginx-controller  svc 添加对应端口</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130616.png" alt="image-20220303172655193"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: v1<br>kind: Service<br>metadata:<br>  annotations:<br>    service.cloud.tencent.com/direct-access: &quot;false&quot;<br>  labels:<br>    k8s-app: nginx-ingress-nginx-controller<br>    qcloud-app: nginx-ingress-nginx-controller<br>  name: nginx-ingress-nginx-controller<br>  namespace: kube-system<br>spec:<br>  clusterIP: 172.18.248.35<br>  externalTrafficPolicy: Cluster<br>  ports:<br>  - name: 80-80-tcp<br>    nodePort: 31899<br>    port: 80<br>    protocol: TCP<br>    targetPort: 80<br>  - name: 443-443-tcp<br>    nodePort: 32534<br>    port: 443<br>    protocol: TCP<br>    targetPort: 443<br>  - name: 9527-9527-tcp-5q8prs0zx68<br>    nodePort: 32677<br>    port: 9527<br>    protocol: TCP<br>    targetPort: 9527<br>  selector:<br>    k8s-app: nginx-ingress-nginx-controller<br>    qcloud-app: nginx-ingress-nginx-controller<br>  sessionAffinity: None<br>  type: LoadBalancer<br>,<br></code></pre></td></tr></table></figure><p>然后通过nginx-ingress-nginx-controller   的svc  clb访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~]# kubectl  -n kube-system  get svc   | grep  nginx-ingress-nginx-controller<br>nginx-ingress-nginx-controller                     LoadBalancer   172.18.248.35    118.24.224.251   80:31899/TCP,443:32534/TCP     3m3s<br>nginx-ingress-nginx-controller-admission           ClusterIP      172.18.251.207   &lt;none&gt;           443/TCP                        133d<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209181130653.png" alt="image-20220303173434838"></p><h3 id="案例25-Nginx-Ingress-实现grpc转发"><a href="#案例25-Nginx-Ingress-实现grpc转发" class="headerlink" title="案例25   Nginx-Ingress 实现grpc转发"></a>案例25   Nginx-Ingress 实现grpc转发</h3><p>参考文档：<a href="https://cloud.tencent.com/developer/article/1730604">https://cloud.tencent.com/developer/article/1730604</a></p><h3 id="案例26-配置HTTPS服务转发到后端容器为HTTPS协议"><a href="#案例26-配置HTTPS服务转发到后端容器为HTTPS协议" class="headerlink" title="案例26 配置HTTPS服务转发到后端容器为HTTPS协议"></a>案例26 配置HTTPS服务转发到后端容器为HTTPS协议</h3><p>Nginx Ingress Controller默认使用HTTP协议转发请求到后端业务容器。当您的业务容器为HTTPS协议时，可以通过使用注解<code>nginx.ingress.kubernetes.io/backend-protocol: &quot;HTTPS&quot;</code>来使得Nginx Ingress Controller使用HTTP协议转发请求到后端业务容器。</p><p>Nginx Ingress配置示例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: networking.k8s.io/v1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    kubernetes.io/ingress.class: nginx<br>    nginx.ingress.kubernetes.io/backend-protocol: HTTPS<br>  name: backend-protocol-https-ingress<br>  namespace: default<br>spec:<br>  rules:<br>  - host: example.chen1900s.cn<br>    http:<br>      paths:<br>      - backend:<br>          service:<br>            name: nginx<br>            port:<br>              number: 443<br>        path: /<br>        pathType: ImplementationSpecific<br>  tls:<br>  - hosts:<br>    - example.chen1900s.cn<br>    secretName: chen1900s<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Nginx-ingress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在TKE容器集群中使用sysctl</title>
      <link href="/post/b81d5734.html"/>
      <url>/post/b81d5734.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在日常使用K8S部署业务时候，需要修改容器部分内核参数来做优化</p></blockquote><h2 id="在-Kubernetes-集群中使用-sysctl"><a href="#在-Kubernetes-集群中使用-sysctl" class="headerlink" title="在 Kubernetes 集群中使用 sysctl"></a>在 Kubernetes 集群中使用 sysctl</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><blockquote><p>节点操作系统镜像名称：tlinux2.4x86_64 </p><p>节点内核版本：4.14+</p><p>TKE集群：1.18版本</p></blockquote><ul><li><p>如果镜像是tlinux 宿主机内核跟容器内核是相互的独立的， tlinux 做了特殊的处理 容器运行时 与linux 可以相互独立一部分内核参数，按理来说原生的linux 与docker 是共享内核</p></li><li><p>kubelet 配置的目的是为了开启修改容器内核的权限 ，</p></li></ul><h3 id="获取-Sysctl-的参数列表"><a href="#获取-Sysctl-的参数列表" class="headerlink" title="获取 Sysctl 的参数列表"></a>获取 Sysctl 的参数列表</h3><p>在 Linux系统 中，用户可以通过 sysctl 接口修改内核运行时的参数。在 <code>/proc/sys/</code> 虚拟文件系统下存放许多内核参数。这些参数涉及了多个内核子系统，如：</p><ul><li>内核子系统（通常前缀为: <code>kernel.</code>）</li><li>网络子系统（通常前缀为: <code>net.</code>）</li><li>虚拟内存子系统（通常前缀为: <code>vm.</code>）</li><li>MDADM 子系统（通常前缀为: <code>dev.</code>）</li></ul><h3 id="启用非安全的-Sysctl-参数"><a href="#启用非安全的-Sysctl-参数" class="headerlink" title="启用非安全的 Sysctl 参数"></a>启用非安全的 Sysctl 参数</h3><p>sysctl 参数分为 <em>安全</em> 和 <em>非安全的</em>。 <em>安全</em> sysctl 参数除了需要设置恰当的命名空间外，在同一 node 上的不同 Pod 之间也必须是 <em>相互隔离的</em>。这意味着在 Pod 上设置 <em>安全</em> sysctl 参数</p><ul><li>必须不能影响到节点上的其他 Pod</li><li>必须不能损害节点的健康</li><li>必须不允许使用超出 Pod 的资源限制的 CPU 或内存资源。</li></ul><p>至今为止，大多数 <em>有命名空间的</em> sysctl 参数不一定被认为是 <em>安全</em> 的。 以下几种 sysctl 参数是 <em>安全的</em>：</p><ul><li>kernel.shm_rmid_forced</li><li>net.ipv4.ip_local_port_range</li><li>net.ipv4.tcp_syncookies</li><li>net.ipv4.ping_group_range （从 Kubernetes 1.18 开始）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-1-17-tlinux /proc/sys]# sysctl -a | grep -E &#x27;net.ipv4.ip_local_port_range|kernel.shm_rmid_forced|net.ipv4.tcp_syncookies|net.ipv4.pin<br>g_group_range&#x27; <br><br>kernel.shm_rmid_forced = 0<br>net.ipv4.ip_local_port_range = 32768    60999<br>net.ipv4.ping_group_range = 1   0<br>net.ipv4.tcp_syncookies = 1<br></code></pre></td></tr></table></figure><p>在未来的 Kubernetes 版本中，若 kubelet 支持更好的隔离机制，则上述列表中将会 列出更多 <em>安全的</em> sysctl 参数。</p><p>所有 <em>安全的</em> sysctl 参数都默认启用。</p><p>所有 <em>非安全的</em> sysctl 参数都默认禁用，且必须由集群管理员在每个节点上手动开启。 那些设置了不安全 sysctl 参数的 Pod 仍会被调度，但无法正常启动。</p><p>参考上述警告，集群管理员只有在一些非常特殊的情况下（如：高可用或实时应用调整）， 才可以启用特定的 <em>非安全的</em> sysctl 参数。 如需启用 <em>非安全的</em> sysctl 参数，需要每个节点上分别设置 kubelet 参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">--allowed-unsafe-sysctls=&#x27;kernel.msg*,kernel.shm*,net.*&#x27; <br></code></pre></td></tr></table></figure><h3 id="设置-Pod-的-Sysctl-参数"><a href="#设置-Pod-的-Sysctl-参数" class="headerlink" title="设置 Pod 的 Sysctl 参数"></a>设置 Pod 的 Sysctl 参数</h3><p>目前，在 Linux 内核中，有许多的 sysctl 参数都是 <em>有命名空间的</em> 。 这就意味着可以为节点上的每个 Pod 分别去设置它们的 sysctl 参数。 在 Kubernetes 中，只有那些有命名空间的 sysctl 参数可以通过 Pod 的 securityContext 对其进行配置。</p><p>以下列出有命名空间的 sysctl 参数，在未来的 Linux 内核版本中，此列表可能会发生变化。</p><ul><li><code>kernel.shm*</code>,</li><li><code>kernel.msg*</code>,</li><li><code>kernel.sem</code>,</li><li><code>fs.mqueue.*</code>,</li><li><code>net.*</code>（内核中可以在容器命名空间里被更改的网络配置项相关参数）。然而也有一些特例 （例如，<code>net.netfilter.nf_conntrack_max</code> 和 <code>net.netfilter.nf_conntrack_expect_max</code> 可以在容器命名空间里被更改，但它们是非命名空间的）。</li></ul><p>没有命名空间的 sysctl 参数称为 <em>节点级别的</em> sysctl 参数。 如果需要对其进行设置，则必须在每个节点的操作系统上手动地去配置它们， 或者通过在 DaemonSet 中运行特权模式容器来配置。</p><p>可使用 Pod 的 securityContext 来配置有命名空间的 sysctl 参数， securityContext 应用于同一个 Pod 中的所有容器。</p><p>此示例中，使用 Pod SecurityContext 来对一个安全的 sysctl 参数 <code>kernel.shm_rmid_forced</code> 以及两个非安全的 sysctl 参数 <code>net.core.somaxconn</code> 和 <code>kernel.msgmax</code> 进行设置。 在 Pod 规约中对 <em>安全的</em> 和 <em>非安全的</em> sysctl 参数不做区分。</p><p>不修改前节点和POD里面参数配置如下：</p><ul><li>CVM节点上的参数配置</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-1-17-tlinux /proc/sys]# sysctl -a | grep -E &#x27;kernel.shm_rmid_forced|net.core.somaxconn|kernel.msgmax&#x27;<br><br>kernel.msgmax = 65536<br>kernel.shm_rmid_forced = 0<br>net.core.somaxconn = 32768<br></code></pre></td></tr></table></figure><ul><li>容器镜像是centos启动POD参数</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@centos-sysctl-7445b79c9f-fchxn /]# sysctl -a | grep -E &#x27;kernel.shm_rmid_forced|net.core.somaxconn|kernel.msgmax&#x27;<br><br>kernel.msgmax = 65536<br>kernel.shm_rmid_forced = 0<br>net.core.somaxconn = 4096<br></code></pre></td></tr></table></figure><h4 id="使用initContainers容器修改内核参数"><a href="#使用initContainers容器修改内核参数" class="headerlink" title="使用initContainers容器修改内核参数"></a>使用initContainers容器修改内核参数</h4><blockquote><p>在不配置kubelet参数allowed-unsafe-sysctls 之前</p></blockquote><p><strong>1，先修改安全参数 kernel.shm_rmid_forced &#x3D;1</strong></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171436514.png" alt="1627548971447"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171455727.png" alt="image-20220917145559626"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#登陆容器里面查看参数<br>[root@centos-sysctl-5c6686499c-lhbdv /]# sysctl -a | grep -E &#x27;kernel.shm_rmid_forced&#x27;<br>kernel.shm_rmid_forced = 1<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171436630.png" alt="1627549087889"></p><p>以上测试表示安全参数是不需要启动kubelet 的allowed-unsafe-sysctls配置就可以修改成功的</p><p><strong>2，同时修改非安全参数net.core.somaxconn&#x3D;1024， kernel.msgmax&#x3D;60000</strong></p><p>yaml实例如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  labels:<br>    k8s-app: centos-sysctl<br>    qcloud-app: centos-sysctl<br>  name: centos-sysctl<br>  namespace: default<br>spec:<br>  selector:<br>    matchLabels:<br>      k8s-app: centos-sysctl<br>      qcloud-app: centos-sysctl<br>  template:<br>    metadata:<br>      labels:<br>        k8s-app: centos-sysctl<br>        qcloud-app: centos-sysctl<br>    spec:<br>      containers:<br>      - args:<br>        - -c<br>        - sleep 300000<br>        command:<br>        - /bin/sh<br>        image: centos:latest<br>        imagePullPolicy: IfNotPresent<br>        name: centos<br>        resources:<br>          limits:<br>            cpu: 200m<br>            memory: 128Mi<br>          requests:<br>            cpu: 100m<br>            memory: 64Mi<br>      dnsPolicy: ClusterFirst<br>      imagePullSecrets:<br>      - name: qcloudregistrykey<br>      initContainers:<br>      - args:<br>        - -c<br>        - sysctl  -w  kernel.shm_rmid_forced=1 &amp;&amp; sysctl  -w  net.core.somaxconn=1024 &amp;&amp; sysctl -w kernel.msgmax=60000<br>        command:<br>        - /bin/sh<br>        image: busybox:latest<br>        imagePullPolicy: Always<br>        name: initc<br>        securityContext:<br>          privileged: true<br><br></code></pre></td></tr></table></figure><p>配置截图如下</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171436668.png" alt="1627549559535"></p><p>容器内也是生效的</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171436702.png" alt="1627549596942"></p><p>节点上系统参数依据是</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171436729.png" alt="1627549700468"></p><p>以上测试表示安全参数 和部分非安全参数也可以直接修改</p><p><strong>3，修改其他内核非安全参数</strong></p><p>示例修改如下参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">net.ipv4.tcp_synack_retries=1<br>net.ipv4.tcp_syn_retries=1<br>net.ipv4.tcp_tw_recycle=1<br>net.ipv4.tcp_tw_reuse=1<br>net.ipv4.tcp_fin_timeout=1<br>net.ipv4.tcp_keepalive_time=30<br>net.ipv4.ip_local_port_range=&quot;1024 65000&quot;<br></code></pre></td></tr></table></figure><p>CVM初始值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-1-17-tlinux ~]# sysctl  -a| grep -E &#x27;net.ipv4.tcp_synack_retries|net.ipv4.tcp_syn_retries|net.ipv4.tcp_tw_recycle|net.ipv4.tcp_tw_reuse|net.ipv4.tcp_fin_timeout|net.ipv4.tcp_keepalive_time|net.ipv4.ip_local_port_range&#x27;<br><br>net.ipv4.ip_local_port_range = 32768    60999<br>net.ipv4.tcp_fin_timeout = 60<br>net.ipv4.tcp_keepalive_time = 7200<br>net.ipv4.tcp_syn_retries = 6<br>net.ipv4.tcp_synack_retries = 5<br>net.ipv4.tcp_tw_reuse = 0<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171436768.png" alt="1627549985182"></p><p>POD未修改前和操作系统保持默认的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@centos-sysctl-5c4d8dc5b-rc8gv /]# sysctl  -a| grep -E &#x27;net.ipv4.tcp_synack_retries|net.ipv4.tcp_syn_retries|net.ipv4.tcp_tw_recycle|net.ipv4.tcp_tw_reuse|net.ipv4.tcp_fin_timeout|net.ipv4.tcp_keepalive_time|net.ipv4.ip_local_port_range&#x27;<br>net.ipv4.ip_local_port_range = 32768    60999<br>net.ipv4.tcp_fin_timeout = 60<br>net.ipv4.tcp_keepalive_time = 7200<br>net.ipv4.tcp_syn_retries = 6<br>net.ipv4.tcp_synack_retries = 5<br>net.ipv4.tcp_tw_reuse = 0<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171436801.png" alt="1627550034823"></p><p>然后使用initContainer去修改这些参数，发现会报错，不让修改，修改失败</p><p><strong>4，kubelet 开启非安全参数  (需要将节点移除重新)</strong></p><blockquote><p>*在TKE集群节点默认情况下是没有开启这个参数的，就需要用户提交工单申请开通自定义kubernetes参数，在创建节点时候可以设置，文章结尾会附上设置相关截图</p></blockquote><p>–allowed-unsafe-sysctls&#x3D;kernel.shm*,kernel.msg*,net.*</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171436828.png" alt="1627550973864"></p><p>然后再去使用initContainer修改，查看修改成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@centos-sysctl-5d6d89c66d-z4mxr /]# sysctl  -a| grep -E &#x27;net.ipv4.tcp_synack_retries|net.ipv4.tcp_syn_retries|net.ipv4.tcp_tw_recycle|net.ipv4.tcp_tw_reuse|net.ipv4.tcp_fin_timeout|net.ipv4.tcp_keepalive_time|net.ipv4.ip_local_port_range&#x27;<br><br>net.ipv4.ip_local_port_range = 1024     65000<br>net.ipv4.tcp_fin_timeout = 1<br>net.ipv4.tcp_keepalive_time = 30<br>net.ipv4.tcp_syn_retries = 1<br>net.ipv4.tcp_synack_retries = 1<br>net.ipv4.tcp_tw_reuse = 1<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171436812.png" alt="1627551531024"></p><p>完整yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  labels:<br>    k8s-app: centos-sysctl<br>    qcloud-app: centos-sysctl<br>  name: centos-sysctl<br>  namespace: default<br>spec:<br>  replicas: 1<br>  revisionHistoryLimit: 5<br>  selector:<br>    matchLabels:<br>      k8s-app: centos-sysctl<br>      qcloud-app: centos-sysctl<br>  template:<br>    metadata:<br>      creationTimestamp: null<br>      labels:<br>        k8s-app: centos-sysctl<br>        qcloud-app: centos-sysctl<br>    spec:<br>      containers:<br>      - args:<br>        - -c<br>        - sleep 300000<br>        command:<br>        - /bin/sh<br>        image: centos:latest<br>        imagePullPolicy: IfNotPresent<br>        name: centos<br>        resources:<br>          limits:<br>            cpu: 200m<br>            memory: 128Mi<br>          requests:<br>            cpu: 100m<br>            memory: 64Mi<br>        securityContext: &#123;&#125;<br>      dnsPolicy: ClusterFirst<br>      imagePullSecrets:<br>      - name: qcloudregistrykey<br>      initContainers:<br>      - args:<br>        - -c<br>        - sysctl -w  net.ipv4.tcp_synack_retries=1 | sysctl -w  net.ipv4.tcp_syn_retries=1 | sysctl -w  net.ipv4.tcp_tw_recycle=1 | sysctl -w  net.ipv4.tcp_tw_reuse=1 | sysctl -w  net.ipv4.tcp_fin_timeout=1 |  sysctl -w  net.ipv4.tcp_keepalive_time=30 | sysctl -w  net.ipv4.ip_local_port_range=&quot;1024 65000&quot;<br>        command:<br>        - /bin/sh<br>        image: busybox:latest<br>        imagePullPolicy: Always<br>        name: initc<br>        securityContext:<br>          privileged: true<br><br></code></pre></td></tr></table></figure><h4 id="在TKE里面设置kubelet参数"><a href="#在TKE里面设置kubelet参数" class="headerlink" title="在TKE里面设置kubelet参数"></a>在TKE里面设置kubelet参数</h4><p>参考文档：<a href="https://cloud.tencent.com/document/product/457/47775">https://cloud.tencent.com/document/product/457/47775</a></p><p>1，需要提交工单申请加白名单（提供APPID，主账号UIN，需要修改的参数名称，组件，集群版本）</p><p>2，集群现存节点，需要先封锁节点，驱逐节点POD，然后将节点移出移入（移出移入会重装操作系统，记得做好备份，另外就是移出时候不要勾选销毁按量计费的节点，包年包月的节点不影响），添加已有节点加入时候设置参数，新增节点直接设置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">allowed-unsafe-sysctls=&#x27;kernel.msg*,kernel.shm*,net.*&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171524529.png" alt="image-20220917152451453"></p><p>更多参考K8S官方文档：<a href="https://kubernetes.io/zh/docs/tasks/administer-cluster/sysctl-cluster/">https://kubernetes.io/zh/docs/tasks/administer-cluster/sysctl-cluster/</a></p>]]></content>
      
      
      <categories>
          
          <category> TKE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> TKE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TKE集群NFS动态创建子目录挂载</title>
      <link href="/post/45e67b0c.html"/>
      <url>/post/45e67b0c.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner">NFS subdir external provisioner</a>组件是使用现有的和已配置的NFS服务器来支持通过持久卷声明动态分发Kubernetes持久卷。持久化卷按以下方式命名${namespace}-${pvcName}-${pvName}，在Kubernetes 环境中我们经常遇到是一个PV对应一个NFS实例场景，针对这种场景如果需要多个PVC&amp;PV使用一个NFS实例，就需要提前根据NFS不同子目录创建大量的PV等待PVC去绑定，不太好维护，可以使用<a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner">nfs-subdir-external-provisioner</a>插件来实现动态创建子目录的需求，下面主要来介绍下</p><h2 id="部署安装"><a href="#部署安装" class="headerlink" title="部署安装"></a>部署安装</h2><p>环境准备：</p><ul><li>kubernetes集群一个，我这里是使用的是腾讯云TKE集群</li><li>NFS服务器实例，或者使用云厂商提供的NFS产品</li><li>helm客户端，并且能够正常链接到集群</li></ul><h3 id="Helm方式安装"><a href="#Helm方式安装" class="headerlink" title="Helm方式安装"></a>Helm方式安装</h3><p>可以根据需求修改指定参数后部署</p><blockquote><p>确保您的NFS服务器可以从您的Kubernetes集群访问，并获取连接到它所需的信息。至少需要它的主机名和共享路径。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ helm repo add nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/<br><br><span class="hljs-comment"># helm repo list  #查看添加helm repo仓库情况</span><br>NAME                            URL                                                               <br>tcr-chen-helm                   https://tcr-chen.tencentcloudcr.com/chartrepo/helm                <br>nfs-subdir-external-provisioner https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/<br><br><span class="hljs-comment"># 【可选步骤，可以将helm chart 包下载下来 上传到自己的镜像仓库，方便后续其他集群安装】</span><br><span class="hljs-comment"># 下载 helm chart 文件至本地目录，查看可以指定的 values 选项（可选）</span><br>$ helm pull nfs-subdir-external-provisioner/nfs-subdir-external-provisioner --untar<br>$ tar  zcvf nfs-subdir-external-provisioner-1.0.0.tgz nfs-subdir-external-provisioner/<br>$ helm cm-push nfs-subdir-external-provisioner-1.0.0.tgz  tcr-chen-helm<br><span class="hljs-comment"># 默认镜像是国外镜像，可以下载下来上传到自己的镜像仓库里面</span><br>$ docker pull k8s.gcr.io/sig-storage/nfs-subdir-external-provisioner:v4.0.2<br>$ docker tag 932b0bface75 ccr.ccs.tencentyun.com/chenjingwei/nfs-subdir-external-provisioner:v4.0.2<br>$ docker push ccr.ccs.tencentyun.com/chenjingwei/nfs-subdir-external-provisioner:v4.0.2<br><br><br><br><span class="hljs-comment"># 使用类似下面命令安装 nfs-subdir-external-provisioner 资源</span><br><span class="hljs-comment">#  helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner  \</span><br>--<span class="hljs-built_in">set</span> nfs.server=172.16.0.33  \<br>--<span class="hljs-built_in">set</span> nfs.path=/nfs  \<br>--<span class="hljs-built_in">set</span> image.repository=ccr.ccs.tencentyun.com/chenjingwei/nfs-subdir-external-provisioner \<br>--<span class="hljs-built_in">set</span> image.tag=v4.0.2<br><br><span class="hljs-comment">#出现如下提示 表示安装成功</span><br>NAME: nfs-subdir-external-provisioner<br>LAST DEPLOYED: Tue Feb 15 13:22:03 2022<br>NAMESPACE: default<br>STATUS: deployed<br>REVISION: 1<br>TEST SUITE: Non<br></code></pre></td></tr></table></figure><h3 id="手动YAML安装"><a href="#手动YAML安装" class="headerlink" title="手动YAML安装"></a>手动YAML安装</h3><p>1，创建账号ServiceAccount</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: v1<br>kind: ServiceAccount<br>metadata:<br>  name: nfs-client-provisioner<br>  # replace with namespace where provisioner is deployed<br>  namespace: default<br>---<br>kind: ClusterRole<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: nfs-client-provisioner-runner<br>rules:<br>  - apiGroups: [&quot;&quot;]<br>    resources: [&quot;nodes&quot;]<br>    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]<br>  - apiGroups: [&quot;&quot;]<br>    resources: [&quot;persistentvolumes&quot;]<br>    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;delete&quot;]<br>  - apiGroups: [&quot;&quot;]<br>    resources: [&quot;persistentvolumeclaims&quot;]<br>    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]<br>  - apiGroups: [&quot;storage.k8s.io&quot;]<br>    resources: [&quot;storageclasses&quot;]<br>    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]<br>  - apiGroups: [&quot;&quot;]<br>    resources: [&quot;events&quot;]<br>    verbs: [&quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]<br>---<br>kind: ClusterRoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: run-nfs-client-provisioner<br>subjects:<br>  - kind: ServiceAccount<br>    name: nfs-client-provisioner<br>    # replace with namespace where provisioner is deployed<br>    namespace: default<br>roleRef:<br>  kind: ClusterRole<br>  name: nfs-client-provisioner-runner<br>  apiGroup: rbac.authorization.k8s.io<br>---<br>kind: Role<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: leader-locking-nfs-client-provisioner<br>  # replace with namespace where provisioner is deployed<br>  namespace: default<br>rules:<br>  - apiGroups: [&quot;&quot;]<br>    resources: [&quot;endpoints&quot;]<br>    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]<br>---<br>kind: RoleBinding<br>apiVersion: rbac.authorization.k8s.io/v1<br>metadata:<br>  name: leader-locking-nfs-client-provisioner<br>  # replace with namespace where provisioner is deployed<br>  namespace: default<br>subjects:<br>  - kind: ServiceAccount<br>    name: nfs-client-provisioner<br>    # replace with namespace where provisioner is deployed<br>    namespace: default<br>roleRef:<br>  kind: Role<br>  name: leader-locking-nfs-client-provisioner<br>  apiGroup: rbac.authorization.k8s.io<br></code></pre></td></tr></table></figure><p>2，部署应用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  name: nfs-client-provisioner<br>  labels:<br>    app: nfs-client-provisioner<br>  # replace with namespace where provisioner is deployed<br>  namespace: default<br>spec:<br>  replicas: 1<br>  strategy:<br>    type: Recreate<br>  selector:<br>    matchLabels:<br>      app: nfs-client-provisioner<br>  template:<br>    metadata:<br>      labels:<br>        app: nfs-client-provisioner<br>    spec:<br>      serviceAccountName: nfs-client-provisioner<br>      containers:<br>        - name: nfs-client-provisioner<br>          image: ccr.ccs.tencentyun.com/chenjingwei/nfs-subdir-external-provisioner:v4.0.2<br>          volumeMounts:<br>            - name: nfs-client-root<br>              mountPath: /persistentvolumes<br>          env:<br>            - name: PROVISIONER_NAME<br>              value: cluster.local/nfs-subdir-external-provisioner<br>            - name: NFS_SERVER<br>              value: 172.16.0.33              #替换成自己的NFS服务器地址<br>            - name: NFS_PATH<br>              value: /nfs                     #NFS上面的目录<br>      volumes:<br>        - name: nfs-client-root<br>          nfs:<br>            server: 172.16.0.33<br>            path: /nfs<br></code></pre></td></tr></table></figure><p>3，创建storageClass</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: storage.k8s.io/v1<br>kind: StorageClass<br>metadata:<br>  name: nfs-client<br>provisioner: cluster.local/nfs-subdir-external-provisioner # or choose another name, must match deployment&#x27;s env PROVISIONER_NAME&#x27;<br>parameters:<br>  archiveOnDelete: &quot;false&quot;<br></code></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><blockquote><p>前提是nfs-subdir-external-provisioner组件已经正常运行</p></blockquote><p>1，配置使用 CFS 文件系统子目录的 PVC </p><p>使用上一步部署的<code>nfs-subdir-external-provisioner</code>动态创建存储卷。</p><p>部署后会默认生成一个<strong>StorageClass</strong>，默认存储类名是”nfs-client”(也可以在部署时自定义指定)，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># kubectl  get StorageClass | grep nfs-client<br>nfs-client          cluster.local/nfs-subdir-external-provisioner   4m8s<br></code></pre></td></tr></table></figure><p>2，使用上面的<strong>StorageClass</strong>创建PVC</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kind: PersistentVolumeClaim<br>apiVersion: v1<br>metadata:<br>  name: nfs-subdir-pvc<br>  namespace: cjweichen<br>spec:<br>  storageClassName: nfs-client<br>  accessModes:<br>    - ReadWriteMany<br>  resources:<br>    requests:<br>      storage: 10Gi<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># kubectl  get pvc<br>NAME              STATUS   VOLUME                                   CAPACITY   ACCESS MODES   STORAGECLASS    AGE<br>nfs-subdir-pvc    Bound    pvc-5fdb9f45-6e98-4a9b-b6e0-920a6c7a6edc   10Gi       RWX           nfs-client    76s<br></code></pre></td></tr></table></figure><p>会自动创建命令，命令命名方式是${namespace}-${pvcName}-${pvName}</p><p>3，查看自动创建的PV配置</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209191352233.png" alt="image-20220919135239146"></p><p>4，创建workload 挂载对应PVC</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">centos</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">centos</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">cjweichen</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">centos</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">centos</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">args:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span> <span class="hljs-number">360000</span><br>        <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/bin/sh</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">centos:latest</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">centos</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/mnt</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br>        <span class="hljs-attr">persistentVolumeClaim:</span><br>          <span class="hljs-attr">claimName:</span> <span class="hljs-string">nfs-subdir-pvc</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># pwd</span><br>/nfs/cjweichen-nfs-subdir-pvc-pvc-5fdb9f45-6e98-4a9b-b6e0-920a6c7a6edc<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209191359304.png" alt="image-20220919135928232"></p>]]></content>
      
      
      <categories>
          
          <category> TKE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> NFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TKE集群使用自建NFS挂载</title>
      <link href="/post/4588d79d.html"/>
      <url>/post/4588d79d.html</url>
      
        <content type="html"><![CDATA[<p><code>NFS</code>是<code>Network File System</code>的缩写，即<strong>网络文件系统</strong>，是一种使用于分散式文件系统的协定。主要是通过网络让不同的机器、不同的操作系统能够彼此分享个别的数据，让应用程序在客户端通过网络访问位于服务器磁盘中的数据，是在类<code>Unix</code>系统间实现磁盘文件共享的一种方法。这个<code>NFS</code>服务器可以让你的<code>PC</code>来将网络远程的<code>NFS</code>服务器分享的目录，挂载到本地端的机器当中， 在本地端的机器看起来，那个远程主机的目录就好像是自己的一个磁盘分区槽一样。</p><p>更多NFS相关原理网上有很多，这里就不做多介绍，这里我们主要说下NFS安装和腾讯云TKE里面如何使用自建NFS进行POD的持久化存储</p><h2 id="NFS-服务搭建"><a href="#NFS-服务搭建" class="headerlink" title="NFS 服务搭建"></a>NFS 服务搭建</h2><p>环境准备</p><blockquote><p><code>CentOS7</code>以<code>NFSv4</code>作为默认版本，<code>NFSv4</code>使用<code>TCP</code>协议（端口号是<code>2049</code>）和<code>NFS</code>服务器建立连接。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 系统环境</span><br>系统平台：CentOS Linux release 7.9 (Final)<br>NFS Server IP：192.168.0.17<br><br>防火墙已关闭/iptables: Firewall is not running.<br>SELINUX=disabled<br></code></pre></td></tr></table></figure><h3 id="安装-NFS-服务"><a href="#安装-NFS-服务" class="headerlink" title="安装 NFS 服务"></a>安装 NFS 服务</h3><ul><li><p>NFS服务端</p><p>服务端，程序包名<code>nfs-utils</code>、<code>rpcbind</code>，默认都已经安装了</p><p>可以通过<code>rpm -ql nfs-utils</code>查看帮助文档等信息</p></li><li><p>NFS客户端</p><p>客户端，需要安装程序包名<code>nfs-utils</code>，提供基本的客户端命令工具</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/nfs]<span class="hljs-comment"># yum install nfs-utils -y</span><br></code></pre></td></tr></table></figure><ul><li><p>查看<code>NFS</code>服务端口</p><p><code>NFS</code>启动时会随机启动多个端口并向<code>RPC</code>注册，为了方便配置防火墙，需要固定<code>NFS</code>服务端口。</p><p>这样如果使用<code>iptables</code>对<code>NFS</code>端口进行限制就会有点麻烦，可以更改配置文件固定<code>NFS</code>服务相关端口</p><p>分配端口，编辑配置文件<code>/etc/sysconfig/nfs</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 使用rpcinfo -P会发现rpc启动了很多监听端口<br><br>[root@VM-0-17-tlinux ~/nfs]#  vim /etc/sysconfig/nfs<br>RQUOTAD_PORT=30001<br>LOCKD_TCPPORT=30002<br>LOCKD_UDPPORT=30002<br>MOUNTD_PORT=30003<br>STATD_PORT=30004<br></code></pre></td></tr></table></figure><p>启动NFS服务：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~/nfs]# systemctl start nfs.service<br></code></pre></td></tr></table></figure><h3 id="NFS配置"><a href="#NFS配置" class="headerlink" title="NFS配置"></a>NFS配置</h3><p>相关文件和命令</p><table><thead><tr><th align="left">文件名</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong><code>/etc/exports</code></strong></td><td align="left">NFS 服务器端需要设定的内容，其作用是设定谁拥有什么样的权限去访问此机器的哪个目录</td></tr><tr><td align="left"><code>/var/lib/nfs/etab</code></td><td align="left">无需设定，用于纪录 NFS 服务器完整的权限设定，exports 中没有设定的缺省值也会被列出</td></tr><tr><td align="left"><code>/var/lib/nfs/xtab</code></td><td align="left">纪录 NFS 连接的相关信息</td></tr><tr><td align="left"><code>/usr/sbin/exportfs</code></td><td align="left">NFS 设定管理命令，用于 Server 侧设定，通过此条命令使得 exports 的设定变得有效或者无效</td></tr><tr><td align="left"><code>/usr/sbin/showmount</code></td><td align="left">用于显示 NFS 设定的相关信息，Server 端和 Client 端均可</td></tr></tbody></table><p><strong>配置文件<code>/etc/exports</code></strong></p><p>我们可以按照<strong>“共享目录的路径 允许访问的 NFS 客户端(共享权限参数)”</strong>的格式，定义要共享的目录与相应的权限</p><table><thead><tr><th align="left">常用参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>ro</code></td><td align="left">只读</td></tr><tr><td align="left"><code>rw</code></td><td align="left">读写</td></tr><tr><td align="left"><code>sync</code></td><td align="left">同时将数据写入到内存与硬盘中，保证不丢失数据</td></tr><tr><td align="left"><code>async</code></td><td align="left">优先将数据保存到内存，然后再写入硬盘；这样效率更高，但可能会丢失数据</td></tr><tr><td align="left"><code>root_squash</code></td><td align="left">当 NFS 客户端以 root 管理员访问时，映射为 NFS 服务器的匿名用户</td></tr><tr><td align="left"><code>all_squash</code></td><td align="left">无论 NFS 客户端使用什么账户访问，均映射为 NFS 服务器的匿名用户</td></tr><tr><td align="left"><code>no_root_squash</code></td><td align="left">当 NFS 客户端以 root 管理员访问时，映射为 NFS 服务器的 root 管理员</td></tr><tr><td align="left"><code>secure</code></td><td align="left">这个选项是缺省选项，它使用了 1024 以下的 TCP&#x2F;IP 端口实现 NFS 的连接</td></tr><tr><td align="left"><code>insecure</code></td><td align="left">禁止使用了 1024 以下的 TCP&#x2F;IP 端口实现 NFS 的连接</td></tr><tr><td align="left"><code>no_wdelay</code></td><td align="left">这个选项关闭写延时，如果设置了 async，那么 NFS 就会忽略这个选项</td></tr><tr><td align="left"><code>nohide</code></td><td align="left">如果将一个目录挂载到另外一个目录之上，那么原来的目录通常就被隐藏起来或看起来像空的一样。要禁用这种行为，需启用 hide 选项</td></tr><tr><td align="left"><code>no_subtree_check</code></td><td align="left">这个选项关闭子树检查，子树检查会执行一些不想忽略的安全性检查，缺省选项是启用子树检查</td></tr><tr><td align="left"><code>no_auth_nlm</code></td><td align="left">这个选项也可以作为<code>insecure_locks</code>指定，它告诉 NFS 守护进程不要对加锁请求进行认证。如果关心安全性问题，就要避免使用这个选项。缺省选项是<code>auth_nlm</code>或<code>secure_locks</code>。</td></tr><tr><td align="left"><code>mp(mountpoint=path)</code></td><td align="left">通过显式地声明这个选项，NFS 要求挂载所导出的目录</td></tr><tr><td align="left"><code>fsid=num</code></td><td align="left">这个选项通常都在 NFS 故障恢复的情况中使用，如果希望实现 NFS 的故障恢复，请参考 NFS 文</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/nfs]<span class="hljs-comment"># cat /etc/exports</span><br>/nfs 192.168.*.*(rw,<span class="hljs-built_in">sync</span>,root_squash)<br><br><span class="hljs-comment">#修改完配置后 重新启动nfs服务</span><br>[root@VM-0-17-tlinux ~/nfs]<span class="hljs-comment"># systemctl   restart nfs</span><br>[root@VM-0-17-tlinux ~/nfs]<span class="hljs-comment"># systemctl   status  nfs</span><br></code></pre></td></tr></table></figure><hr><h2 id="TKE使用NFS持久化挂载"><a href="#TKE使用NFS持久化挂载" class="headerlink" title="TKE使用NFS持久化挂载"></a>TKE使用NFS持久化挂载</h2><blockquote><p>将NFS挂在到K8S容器服务的POD里面</p></blockquote><h3 id="示例一-inline方式挂载"><a href="#示例一-inline方式挂载" class="headerlink" title="示例一 inline方式挂载"></a>示例一 inline方式挂载</h3><p>完整yaml：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  labels:<br>    k8s-app: centos<br>  name: centos<br>  namespace: default<br>spec:<br>  replicas: 1<br>  selector:<br>    matchLabels:<br>      k8s-app: centos<br>  template:<br>    metadata:<br>      labels:<br>        k8s-app: centos<br>    spec:<br>      containers:<br>      - args:<br>        - -c<br>        - <span class="hljs-built_in">sleep</span> 360000<br>        <span class="hljs-built_in">command</span>:<br>        - /bin/sh<br>        image: centos:latest<br>        imagePullPolicy: IfNotPresent<br>        name: centos<br>        resources: &#123;&#125;<br>        volumeMounts:<br>        - mountPath: /mnt           <span class="hljs-comment">#POD里面的挂载路径</span><br>          name: nfs<br>      volumes:<br>      - name: nfs<br>        nfs:<br>          path: /nfs                       <span class="hljs-comment">#nfs文件里面目录</span><br>          server: 192.168.0.17             <span class="hljs-comment">#NFS服务器IP</span><br></code></pre></td></tr></table></figure><p>登陆NFS服务 创建个临时文件，然后登陆POD里查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux ~/nfs]<span class="hljs-comment"># cd /nfs/</span><br>[root@VM-0-17-tlinux /nfs]<span class="hljs-comment"># echo  hello worload &gt; hello.txt</span><br>[root@VM-0-17-tlinux /nfs]<span class="hljs-comment"># cat hello.txt </span><br>hello worload<br><br><span class="hljs-comment">#登录容器查看挂着情况</span><br>[root@VM-0-17-tlinux /nfs]<span class="hljs-comment"># kubectl  exec -it centos-54db87ccc9-nkx86 -- /bin/bash</span><br>[root@centos-54db87ccc9-nkx86 /]<span class="hljs-comment"># </span><br>[root@centos-54db87ccc9-nkx86 /]<span class="hljs-comment"># df -h</span><br>Filesystem         Size  Used Avail Use% Mounted on<br>overlay             50G   11G   37G  23% /<br>tmpfs               64M     0   64M   0% /dev<br>tmpfs              3.9G     0  3.9G   0% /sys/fs/cgroup<br>192.168.0.17:/nfs   50G   32G   16G  67% /mnt                        <span class="hljs-comment">#挂载点，可以看到已经挂载成功的</span><br>/dev/vda1           50G   11G   37G  23% /etc/hosts<br>shm                 64M     0   64M   0% /dev/shm<br>tmpfs              3.9G   12K  3.9G   1% /run/secrets/kubernetes.io/serviceaccount<br>tmpfs              3.9G     0  3.9G   0% /proc/acpi<br>tmpfs              3.9G     0  3.9G   0% /proc/scsi<br>tmpfs              3.9G     0  3.9G   0% /sys/firmware<br>[root@centos-54db87ccc9-nkx86 /]<span class="hljs-comment"># cd /mnt/</span><br>[root@centos-54db87ccc9-nkx86 mnt]<span class="hljs-comment"># cat hello.txt </span><br>hello worload<br>[root@centos-54db87ccc9-nkx86 mnt]<span class="hljs-comment"># echo 1111&gt;&gt; hello.txt         #在POD往文件系统里面写文件</span><br>bash: hello.txt: Permission denied                                <span class="hljs-comment">#没有权限</span><br>[root@centos-54db87ccc9-nkx86 mnt]<span class="hljs-built_in">ls</span> -lrt<br>total 4<br>-rw-r--r-- 1 root root 14 Oct 17 13:14 hello.txt<br></code></pre></td></tr></table></figure><p>可以看到 上面我们的 NFS配置的是root_squash</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/etc/exports<br>/nfs 192.168.*.*(rw,<span class="hljs-built_in">sync</span>,root_squash)<br><span class="hljs-comment">#是没有权限修改文件</span><br></code></pre></td></tr></table></figure><p>下面我们将配置文件修改成如下配置进行测试</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-17-tlinux /nfs]<span class="hljs-comment"># cat /etc/exports</span><br>/nfs 192.168.*.*(rw,<span class="hljs-built_in">sync</span>,no_root_squash)<br><br><span class="hljs-comment">#重启NFS 服务</span><br>[root@VM-0-17-tlinux /nfs]<span class="hljs-comment"># systemctl  restart nfs</span><br>[root@VM-0-17-tlinux /nfs]<span class="hljs-comment"># systemctl status nfs</span><br></code></pre></td></tr></table></figure><p>将POD销毁重建后登录POD里测试。可以修改文件 并且可以创建文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@centos-54db87ccc9-rgnk8 mnt]<span class="hljs-comment"># touch 222</span><br>[root@centos-54db87ccc9-rgnk8 mnt]<span class="hljs-comment"># ls</span><br>222  hello.txt<br>[root@centos-54db87ccc9-rgnk8 mnt]<span class="hljs-comment"># echo &quot;1111&quot;&gt;&gt; hello.txt </span><br>[root@centos-54db87ccc9-rgnk8 mnt]<span class="hljs-comment"># cat hello.txt </span><br>hello worloada<br>1111<br>[root@centos-54db87ccc9-rgnk8 mnt]<span class="hljs-comment"># ls -lrt</span><br>total 4<br>-rw-r--r-- 1 root root  0 Oct 17 13:24 222<br>-rw-r--r-- 1 root root 20 Oct 17 13:28 hello.txt<br></code></pre></td></tr></table></figure><h3 id="示例二-PVC-amp-PV方式挂载"><a href="#示例二-PVC-amp-PV方式挂载" class="headerlink" title="示例二 PVC&amp;PV方式挂载"></a>示例二 PVC&amp;PV方式挂载</h3><p>使用PVC和PV方式创建并挂载，示例如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pv-operationdata</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">capacity:</span><br>     <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span>                    <span class="hljs-comment">#针对NFS类文件存储，storage大小没有实际意义</span><br>  <span class="hljs-attr">csi:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">com.tencent.cloud.csi.cfs</span><br>    <span class="hljs-attr">volumeAttributes:</span><br>       <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.17</span>                <span class="hljs-comment">#替换成自己的NFS</span><br>       <span class="hljs-attr">path:</span> <span class="hljs-string">/nfs</span>                         <span class="hljs-comment">#替换成自己的目录</span><br>    <span class="hljs-attr">volumeHandle:</span> <span class="hljs-string">pv-operationdata</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Retain</span><br>  <span class="hljs-attr">volumeMode:</span> <span class="hljs-string">Filesystem</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pvc-operationdata</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">volumeMode:</span> <span class="hljs-string">Filesystem</span><br>  <span class="hljs-attr">volumeName:</span> <span class="hljs-string">pv-operationdata</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">centos</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">centos</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">centos</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">centos</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">args:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span> <span class="hljs-number">360000</span><br>        <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/bin/sh</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">centos:latest</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">centos</span><br>        <span class="hljs-attr">resources:</span> &#123;&#125;<br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/mnt</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br>        <span class="hljs-attr">persistentVolumeClaim:</span><br>          <span class="hljs-attr">claimName:</span> <span class="hljs-string">pvc-operationdata</span><br><br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209191031509.png" alt="1634478174556"></p><h3 id="示例三-CVM服务器端挂载"><a href="#示例三-CVM服务器端挂载" class="headerlink" title="示例三  CVM服务器端挂载"></a>示例三  CVM服务器端挂载</h3><ul><li>使用<code>showmount</code>命令查询<code>NFS</code>服务器的远程共享信息</li><li><code>showmount</code>命令输出格式为<strong>“共享的目录名称 允许使用客户端地址”</strong></li></ul><p>showmount&#96;命令**</p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>-e</code></td><td align="left">显示 NFS 服务器的共享列表</td></tr><tr><td align="left"><code>-a</code></td><td align="left">显示本机挂载的文件资源的情况 NFS 资源的情况</td></tr><tr><td align="left"><code>-v</code></td><td align="left">显示版本号</td></tr></tbody></table><p><strong><code>exportfs</code>命令</strong></p><ul><li>维护<code>exports</code>文件导出的文件系统表的专用工具，可以修改配置之后不重启<code>NFS</code>服务</li><li><code>export -ar</code>：重新导出所有的文件系统</li><li><code>export -au</code>：关闭导出的所有文件系统</li><li><code>export -u FS</code>:：关闭指定的导出的文件系统</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看NFS服务器端共享的文件系统</span><br><span class="hljs-comment"># showmount -e NFSSERVER_IP</span><br>[root@VM-0-17-tlinux ~/nfs]<span class="hljs-comment">#  showmount -e 192.168.0.17</span><br>Export list <span class="hljs-keyword">for</span> 192.168.0.17:<br>/nfs 192.168.*.*<br><br><span class="hljs-comment"># NFS客户端创建一个挂载目录，挂载服务端NFS文件系统到本地</span><br><span class="hljs-comment"># mount -t nfs SERVER:/path/to/sharedfs  /path/to/mount_point</span><br>[root@VM-0-11-tlinux ~]<span class="hljs-comment"># mkdir /nfsfile</span><br>[root@VM-0-11-tlinux ~]<span class="hljs-comment"># mount -t nfs 192.168.0.17:/nfs /nfsfile</span><br>[root@VM-0-11-tlinux ~]<span class="hljs-comment"># df -h | grep nfsfile</span><br>192.168.0.17:/nfs    50G   32G   16G  67% /nfsfile<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 挂载成功后就应该能够顺利地看到在执行前面的操作时写入的文件内容了</span><br>[root@VM-0-11-tlinux ~]<span class="hljs-comment"># cat /nfsfile/hello.txt </span><br>hello worloada<br>1111<br><br><span class="hljs-comment"># 如果希望NFS文件共享服务能一直有效，则需要将其写入到fstab文件中</span><br><span class="hljs-comment"># SERVER:/PATH/TO/EXPORTED_FS  /mount_point  nfs  defaults,_netdev  0  0</span><br>[root@VM-0-11-tlinux ~]<span class="hljs-comment">#  vim /etc/fstab</span><br>192.168.0.17:/nfs  /nfsfile nfs defaults 0 0<br></code></pre></td></tr></table></figure><h3 id="示例四-TKE部署mysql挂载"><a href="#示例四-TKE部署mysql挂载" class="headerlink" title="示例四  TKE部署mysql挂载"></a>示例四  TKE部署mysql挂载</h3><blockquote><p>以下示例使用的是另外搭建的NFS实例</p></blockquote><p>部署mysql服务挂载自建NFS，这里是在NFS里面创建了子目录，通过子目录挂载到mysql的数据目录里面</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">mysql</span><br>      <span class="hljs-attr">qcloud-app:</span> <span class="hljs-string">mysql</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">mysql</span><br>        <span class="hljs-attr">qcloud-app:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;123456&quot;</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>        <span class="hljs-attr">resources:</span> &#123;&#125;<br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/lib/mysql</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br>          <span class="hljs-attr">subPath:</span> <span class="hljs-string">mysql_docker/data</span>   <span class="hljs-comment">#挂载的是NFS子目录</span><br>      <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br>        <span class="hljs-attr">nfs:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/nfs</span>           <br>          <span class="hljs-attr">server:</span> <span class="hljs-number">172.16</span><span class="hljs-number">.0</span><span class="hljs-number">.33</span>           <span class="hljs-comment">#NFS服务器</span><br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209191200093.png" alt="image-20220919120020874"></p><h3 id="示例五-超级节点POD挂载"><a href="#示例五-超级节点POD挂载" class="headerlink" title="示例五 超级节点POD挂载"></a>示例五 超级节点POD挂载</h3><p>挂载自建的 nfs 时，事件可能会报 Operation not permitted</p><p>如果使用自建的 nfs 实现持久化存储时，连接时事件报 Operation not permitted。需要修改自建 nfs 的 &#x2F;etc&#x2F;exports 文件，添加 &#x2F;<path><ip-range>(rw,insecure) 参数，示例如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/nfs  172.16.*.*(rw,insecure)<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">centos</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">centos</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">cjweichen</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">centos</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">centos</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">affinity:</span><br>        <span class="hljs-attr">nodeAffinity:</span><br>          <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>            <span class="hljs-attr">nodeSelectorTerms:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">matchExpressions:</span><br>              <span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">kubernetes.io/hostname</span><br>                <span class="hljs-attr">operator:</span> <span class="hljs-string">In</span><br>                <span class="hljs-attr">values:</span><br>                <span class="hljs-bullet">-</span> <span class="hljs-string">eklet-subnet-myqjfu7t</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">args:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">sleep</span> <span class="hljs-number">360000</span><br>        <span class="hljs-attr">command:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">/bin/sh</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">centos:latest</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">centos</span><br>        <span class="hljs-attr">resources:</span> &#123;&#125;<br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/mnt</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br>      <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Always</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs</span><br>        <span class="hljs-attr">persistentVolumeClaim:</span><br>          <span class="hljs-attr">claimName:</span> <span class="hljs-string">pvc-operationdata</span><br></code></pre></td></tr></table></figure><p>mysql挂载自建NFS 使用inline方式</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">mysql-nfs-eks</span><br>    <span class="hljs-attr">qcloud-app:</span> <span class="hljs-string">mysql-nfs-eks</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mysql-nfs-eks</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">mysql-nfs-eks</span><br>      <span class="hljs-attr">qcloud-app:</span> <span class="hljs-string">mysql-nfs-eks</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">mysql-nfs-eks</span><br>        <span class="hljs-attr">qcloud-app:</span> <span class="hljs-string">mysql-nfs-eks</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">env:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">MYSQL_ROOT_PASSWORD</span><br>          <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;12345&quot;</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>        <span class="hljs-attr">resources:</span> &#123;&#125;<br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/lib/mysql</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-vol</span><br>          <span class="hljs-attr">subPath:</span> <span class="hljs-string">mysql_docker/data</span><br>      <span class="hljs-attr">dnsPolicy:</span> <span class="hljs-string">ClusterFirst</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-vol</span><br>        <span class="hljs-attr">nfs:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">/nfs</span><br>          <span class="hljs-attr">server:</span> <span class="hljs-number">172.16</span><span class="hljs-number">.0</span><span class="hljs-number">.33</span><br><br><br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209191240338.png" alt="image-20220919124024264"></p><p>TKE里面使用NFS介绍就到这里，下一篇介绍下如何为NFS 动态创建不同子目录的 PVC用于POD挂载</p><p>感谢！</p>]]></content>
      
      
      <categories>
          
          <category> TKE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> NFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kube-state-metrics部署安装</title>
      <link href="/post/b9437839.html"/>
      <url>/post/b9437839.html</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在kubernetes集群中已经有了 cadvisor、heapster、metric-server，基本上容器运行的所有指标都能拿到，但是针对下面这种情况获取不到：</p><ul><li>比如调度了多少个 replicasset ，现在可用的有几个？</li><li>多少个 Pod 是 running&#x2F;stopped&#x2F;terminated 状态？</li><li>Pod 重启了多少次？</li><li>有多少 job 在运行中</li></ul><p>而这些指标采集则需要 kube-state-metrics 进行采集，它基于 client-go 开发，负责监听 K8s apiserver 从而生成metrics数据，指标数据通过 <code>/metrics</code> Endpoint 暴露，主要是适配 Prometheus</p><h2 id="部署安装"><a href="#部署安装" class="headerlink" title="部署安装"></a>部署安装</h2><p><strong>1，下载将 <a href="https://github.com/kubernetes/kube-state-metrics/blob/master/examples/standard">kube-state-metrics examples</a> 几个文件，分别为</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kube-state-metrics/    <br>├── cluster-role-binding.yaml  <br>├── cluster-role-binding.yaml   <br>├── deployment.yaml    <br>├── service-account.yaml   <br>├── service.yaml    <br></code></pre></td></tr></table></figure><p><strong>2，修改镜像地址</strong>（默认镜像地址k8s.gcr.io 在国外。可以找个海外机器拉取下来上传到国内镜像仓库进行拉取上传到自己的镜像仓库里面）</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">- image: registry.k8s.io/kube-state-metrics/kube-state-metrics:v2.6.0<br><br><span class="hljs-comment">#本人已经拉取到自己镜像仓库 可以修改成</span><br>- image: ccr.ccs.tencentyun.com/chenjingwei/kube-state-metrics:v2.6.0<br></code></pre></td></tr></table></figure><p><strong>3，安装kube-state-metrics</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">kubectl apply -f ./<br></code></pre></td></tr></table></figure><p><strong>4，查看是否安装成功</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># kubectl get pods -n kube-system -o wide | grep kube-state-metrics</span><br>kube-state-metrics-57768576b6-mh5d8   1/1     Running   0   2m19s   172.16.0.12      172.30.249.130   &lt;none&gt;      &lt;none&gt;<br><br><span class="hljs-comment">#通过 /healthz 健康检查端口查看Pod状态。</span><br><span class="hljs-comment"># curl  172.16.0.12:8080/healthz</span><br>OK<br><br><br><span class="hljs-comment">#通过 /metrics 接口可查看其采集的全量数据</span><br><span class="hljs-comment"># curl 172.16.0.12:8080/metrics</span><br><br><span class="hljs-comment">#登陆启动POD里面访问测试</span><br>[root@centos-777bdddd57-zv7bv /]<span class="hljs-comment"># curl kube-state-metrics.kube-system.svc.cluster.local:8080</span><br>&lt;html&gt;<br>             &lt;<span class="hljs-built_in">head</span>&gt;&lt;title&gt;Kube Metrics Server&lt;/title&gt;&lt;/head&gt;<br>             &lt;body&gt;<br>             &lt;h1&gt;Kube Metrics&lt;/h1&gt;<br>                         &lt;ul&gt;<br>             &lt;li&gt;&lt;a href=<span class="hljs-string">&#x27;/metrics&#x27;</span>&gt;metrics&lt;/a&gt;&lt;/li&gt;<br>             &lt;li&gt;&lt;a href=<span class="hljs-string">&#x27;/healthz&#x27;</span>&gt;healthz&lt;/a&gt;&lt;/li&gt;<br>                         &lt;/ul&gt;<br>             &lt;/body&gt;<br>&lt;/html&gt;<br><span class="hljs-comment">#表示安装成功</span><br></code></pre></td></tr></table></figure><blockquote><p>启动时候有可能端口冲突 可以按照如下文档 添加启动参数，<a href="https://github.com/bitnami/bitnami-docker-kube-state-metrics/blob/2.1.0-debian-10-r15/2/debian-10/Dockerfile">参考文档</a></p></blockquote><h2 id="与prometheus集成"><a href="#与prometheus集成" class="headerlink" title="与prometheus集成"></a>与prometheus集成</h2><p>修改prometheus配置文件，添加job_name</p><blockquote><p>kube-state-metrics是部署在kube-system命名空间下的，因此在正则匹配上，命名空间为kube-system，svc名称为kube-state-metrics，否则就不进行监控，k8s kube-state-metrics监控任务</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml">  <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;kube-state-metrics&quot;</span><br>  <span class="hljs-attr">kubernetes_sd_configs:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">endpoints</span><br>  <span class="hljs-attr">relabel_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_namespace</span>, <span class="hljs-string">__meta_kubernetes_endpoints_name</span>]<br>    <span class="hljs-attr">regex:</span> <span class="hljs-string">kube-system;kube-state-metrics</span><br>    <span class="hljs-attr">action:</span> <span class="hljs-string">keep</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">bearer_token_file:</span> <span class="hljs-string">/var/run/secrets/kubernetes.io/serviceaccount/token</span><br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172207163.png" alt="image-20220917220729053"></p><p><strong>6，查看prometheus的targets</strong></p><p>部署成功后，prometheus的target会出现如下标志</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172153353.png" alt="image-20220917215311281"></p><p>可以看到kube-state-metrics监控任务下已经有两个Targets实例了。我们可以到grup界面通过PromQL语句查询相关监控数据。</p><p>示例： 查看当前K8s集群有多少configmap资源对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">count(kube_configmap_created)<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172156719.png" alt="image-20220917215648632"></p><p>使用 kube-state-metrics 后的常用场景有：</p><ul><li><p>存在执行失败的 Job</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">kube_job_status_failed&#123;job=&quot;kubernetes-service-endpoints&quot;,k8s_app=&quot;kube-state-metrics&quot;&#125;==1</span><br></code></pre></td></tr></table></figure></li><li><p>集群节点状态错误</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">kube_node_status_condition&#123;condition=&quot;Ready&quot;,status!=&quot;true&quot;&#125;==1</span><br></code></pre></td></tr></table></figure></li><li><p>集群中存在启动失败的 Pod</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">kube_pod_status_phase&#123;phase=~&quot;Failed|Unknown|Pending&quot;&#125;==1</span><br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172218318.png" alt="image-20220917221857125"></p></li><li><p>最近30分钟内有 Pod 容器重启</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">changes(kube_pod_container_status_restarts[30m])&gt;0</span><br></code></pre></td></tr></table></figure></li><li><p>查看当前集群有多少个Pod正在运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">count (kube_pod_container_state_started)<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172202253.png" alt="image-20220917220259158"></p></li></ul><p>配合报警alertmanager可以更好地监控集群的运行</p><h2 id="与metric-server的对比"><a href="#与metric-server的对比" class="headerlink" title="与metric-server的对比"></a>与metric-server的对比</h2><ul><li>metric-server（或heapster）是从 api-server 中获取 cpu、内存使用率这种监控指标，并把他们发送给存储后端，如 influxdb 或云厂商，他当前的核心作用是：为 HPA 等组件提供决策指标支持。</li><li>kube-state-metrics 关注于获取 k8s 各种资源的最新状态，如 deployment 或者 daemonset，之所以没有把kube-state-metrics 纳入到 metric-server 的能力中，是因为他们的关注点本质上是不一样的。metric-server仅仅是获取、格式化现有数据，写入特定的存储，实质上是一个监控系统。而 kube-state-metrics 是将 k8s 的运行状况在内存中做了个快照，并且获取新的指标，但他没有能力导出这些指标</li><li>换个角度讲，kube-state-metrics 本身是 metric-server 的一种数据来源，虽然现在没有这么做。</li><li>另外，像 Prometheus 这种监控系统，并不会去用 metric-server 中的数据，他都是自己做指标收集、集成的（Prometheus包含了metric-server的能力），但 Prometheus 可以监控 metric-server 本身组件的监控状态并适时报警，这里的监控就可以通过 kube-state-metrics 来实现，如 metric-server pod 的运行状态。</li></ul><h2 id="优化点和问题"><a href="#优化点和问题" class="headerlink" title="优化点和问题"></a>优化点和问题</h2><ul><li>因为 kube-state-metrics 是监听资源的 add、delete、update 事件，那么在 kube-state-metrics 部署之前已经运行的资源，岂不是拿不到数据？kube-state-metric 利用 client-go 可以初始化所有已经存在的资源对象，确保没有任何遗漏</li><li>kube-state-metrics 当前不会输出 metadata 信息(如 help 和 description）</li><li>缓存实现是基于 golang 的 map，解决并发读问题当期是用了一个简单的互斥锁，可以解决问题，后续会考虑golang 的 sync.Map 安全 map。</li><li>kube-state-metrics 通过比较 resource version 来保证 event 的顺序</li><li>kube-state-metrics 并不保证包含所有资源</li></ul><h2 id="相关yaml文件"><a href="#相关yaml文件" class="headerlink" title="相关yaml文件"></a>相关yaml文件</h2><p>附上部署的yaml：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app.kubernetes.io/component:</span> <span class="hljs-string">exporter</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">kube-state-metrics</span><br>    <span class="hljs-attr">app.kubernetes.io/version:</span> <span class="hljs-number">2.6</span><span class="hljs-number">.0</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-state-metrics</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app.kubernetes.io/component:</span> <span class="hljs-string">exporter</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">kube-state-metrics</span><br>    <span class="hljs-attr">app.kubernetes.io/version:</span> <span class="hljs-number">2.6</span><span class="hljs-number">.0</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-state-metrics</span><br><span class="hljs-attr">rules:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;&quot;</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">configmaps</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">secrets</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">nodes</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">pods</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">services</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">serviceaccounts</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">resourcequotas</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">replicationcontrollers</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">limitranges</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">persistentvolumeclaims</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">persistentvolumes</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">namespaces</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">endpoints</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">apps</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">statefulsets</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">daemonsets</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">deployments</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">replicasets</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">batch</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">cronjobs</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">jobs</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">autoscaling</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">horizontalpodautoscalers</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">authentication.k8s.io</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">tokenreviews</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">create</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">authorization.k8s.io</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">subjectaccessreviews</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">create</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">policy</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">poddisruptionbudgets</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">certificates.k8s.io</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">certificatesigningrequests</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">storage.k8s.io</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">storageclasses</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">volumeattachments</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">admissionregistration.k8s.io</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">mutatingwebhookconfigurations</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">validatingwebhookconfigurations</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">networking.k8s.io</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">networkpolicies</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">ingresses</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">coordination.k8s.io</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">leases</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br>  <span class="hljs-attr">resources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">clusterrolebindings</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">clusterroles</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">rolebindings</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">roles</span><br>  <span class="hljs-attr">verbs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br>  <br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app.kubernetes.io/component:</span> <span class="hljs-string">exporter</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">kube-state-metrics</span><br>    <span class="hljs-attr">app.kubernetes.io/version:</span> <span class="hljs-number">2.6</span><span class="hljs-number">.0</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-state-metrics</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-state-metrics</span><br><span class="hljs-attr">subjects:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-state-metrics</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br> <br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app.kubernetes.io/component:</span> <span class="hljs-string">exporter</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">kube-state-metrics</span><br>    <span class="hljs-attr">app.kubernetes.io/version:</span> <span class="hljs-number">2.6</span><span class="hljs-number">.0</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-state-metrics</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">kube-state-metrics</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app.kubernetes.io/component:</span> <span class="hljs-string">exporter</span><br>        <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">kube-state-metrics</span><br>        <span class="hljs-attr">app.kubernetes.io/version:</span> <span class="hljs-number">2.6</span><span class="hljs-number">.0</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">automountServiceAccountToken:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">ccr.ccs.tencentyun.com/chenjingwei/kube-state-metrics:v2.6.0</span><br>        <span class="hljs-attr">livenessProbe:</span><br>          <span class="hljs-attr">httpGet:</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/healthz</span><br>            <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span><br>          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">kube-state-metrics</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">http-metrics</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8081</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">telemetry</span><br>        <span class="hljs-attr">readinessProbe:</span><br>          <span class="hljs-attr">httpGet:</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>            <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br>          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span><br>          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">allowPrivilegeEscalation:</span> <span class="hljs-literal">false</span><br>          <span class="hljs-attr">capabilities:</span><br>            <span class="hljs-attr">drop:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">ALL</span><br>          <span class="hljs-attr">readOnlyRootFilesystem:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">65534</span><br>      <span class="hljs-attr">nodeSelector:</span><br>        <span class="hljs-attr">kubernetes.io/os:</span> <span class="hljs-string">linux</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">kube-state-metrics</span><br>      <br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app.kubernetes.io/component:</span> <span class="hljs-string">exporter</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">kube-state-metrics</span><br>    <span class="hljs-attr">app.kubernetes.io/version:</span> <span class="hljs-number">2.6</span><span class="hljs-number">.0</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube-state-metrics</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http-metrics</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-string">http-metrics</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">telemetry</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-string">telemetry</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">kube-state-metrics</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>missing-container-metrics部署安装和使用</title>
      <link href="/post/1ed7eb83.html"/>
      <url>/post/1ed7eb83.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文主要介绍missing-container-metrics监控pod OOMKilled</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Kubernetes 默认情况下使用 cAdvisor 以及 kube-state-metrics 来收集容器的各项指标，绝大多数场景下能够满足业务的基本的需求，但还是有所欠缺，比如缺少对以下几个指标的收集 </p><ul><li>OOM kill</li><li>容器重启的次数</li><li>容器的退出码</li></ul><p>missing-container-metrics 这个metrics 弥补了 cAdvisor 的缺陷，新增了以上几个指标，用户可以利用这些指标迅速定位某些故障。例如，假设某个容器有多个子进程，其中某个子进程被 OOM kill，但容器还在运行，如果不对 OOM kill 进行监控，用户很难对故障进行定位 </p><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><blockquote><p><a href="https://artifacthub.io/packages/helm/missing-container-metrics/missing-container-metrics">missing-container-metrics项目介绍</a></p></blockquote><p><strong>1，添加helm仓库</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">helm repo add missing-container-metrics https://draganm.github.io/missing-container-metrics<br></code></pre></td></tr></table></figure><p><strong>2， 下载helm到本地，可以修改对应的 value.yaml</strong> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">helm pull missing-container-metrics/missing-container-metrics<br>tar xvf missing-container-metrics-0.1.1.tgz<br>cd  missing-container-metrics <br>ls <br>Chart.yaml  README.md  templates  values.yaml<br></code></pre></td></tr></table></figure><p><strong>3， 可配置项</strong> </p><table><thead><tr><th align="left">变量</th><th align="left">描述说明</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">image.repository</td><td align="left">镜像名称</td><td align="left"><code>dmilhdef/missing-container-metrics</code></td></tr><tr><td align="left">image.pullPolicy</td><td align="left">镜像拉取策略</td><td align="left"><code>IfNotPresent</code></td></tr><tr><td align="left">image.tag</td><td align="left">镜像tag</td><td align="left"><code>v0.21.0</code></td></tr><tr><td align="left">imagePullSecrets</td><td align="left">拉取镜像的secret</td><td align="left"><code>[]</code></td></tr><tr><td align="left">nameOverride</td><td align="left">覆盖生成的图表名称。默认为 .Chart.Name。</td><td align="left"></td></tr><tr><td align="left">fullnameOverride</td><td align="left">覆盖生成的版本名称。默认为 .Release.Name。</td><td align="left"></td></tr><tr><td align="left">podAnnotations</td><td align="left">Pod 的Annotations</td><td align="left"><code>&#123;&quot;prometheus.io/scrape&quot;: &quot;true&quot;, &quot;prometheus.io/port&quot;: &quot;3001&quot;&#125;</code></td></tr><tr><td align="left">podSecurityContext</td><td align="left">为 pod 设置安全上下文</td><td align="left"></td></tr><tr><td align="left">securityContext</td><td align="left">为 pod 中的容器设置安全上下文</td><td align="left"></td></tr><tr><td align="left">resources</td><td align="left">PU&#x2F;内存资源请求&#x2F;限制</td><td align="left"><code>&#123;&#125;</code></td></tr><tr><td align="left">useDocker</td><td align="left">从 Docker 获取容器信息,如果容器运行时为docker ,设置为true</td><td align="left"><code>false</code></td></tr><tr><td align="left">useContainerd</td><td align="left">从 Containerd 获取容器信息,如果容器运行时为containers ,设置为true</td><td align="left"><code>true</code></td></tr></tbody></table><p>由于我们集群的运行时是docker的 所以需要修改<code>missing-container-metrics/values.yaml</code>  中&#96;&#96;useDocker<code>为</code><br>true&#96;，然后安装</p><p><strong>4，执行安装</strong> </p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># kubectl create namespace missing-container-metrics</span><br><span class="hljs-comment"># helm install missing-container-metrics  missing-container-metrics -n missing-container-metrics</span><br>NAME: missing-container-metrics<br>LAST DEPLOYED: Sun Jun 26 13:32:43 2022<br>NAMESPACE: missing-container-metrics<br>STATUS: deployed<br>REVISION: 1<br>TEST SUITE: None<br><br><br><span class="hljs-comment">#helm  -n missing-container-metrics list</span><br>NAME     NAMESPACE       REVISION        UPDATED     STATUS          CHART                           APP VERSION<br>missing-container-metrics       missing-container-metrics     1               2022-09-17 22:43:56.998806908 +0800 CST deployed        missing-container-metrics-0.1.1 0.21.0     <br><br><br>[root@VM-249-130-tlinux ~]<span class="hljs-comment"># kubectl  -n missing-container-metrics  get  pods | grep missing-container-metrics</span><br>missing-container-metrics-bf7gq       1/1     Running   0          60s<br></code></pre></td></tr></table></figure><p> 可以通过访问服务的3001端口查看metrics,例如 </p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#curl 172.16.0.29:3001/metrics   | grep memory-request-limit</span><br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172250764.png" alt="image-20220917225037666"></p><p>服务公开了如下的指标：</p><table><thead><tr><th>指标</th><th>说明</th></tr></thead><tbody><tr><td>container_restarts</td><td>容器的重启次数</td></tr><tr><td>container_ooms</td><td>容器的 OOM 杀死数。这涵盖了容器 cgroup 中任何进程的 OOM 终止</td></tr><tr><td>container_last_exit_code</td><td>容器的最后退出代码</td></tr></tbody></table><p>每一个指标包含如下标签：</p><table><thead><tr><th>指标ID</th><th>说明</th></tr></thead><tbody><tr><td>docker_container_id</td><td>容器的完整 ID</td></tr><tr><td>container_short_id</td><td>Docker 容器 ID 的前 6 个字节</td></tr><tr><td>docker_container_id</td><td>容器 id 以与 kubernetes pod 指标相同的格式表示 - 以容器运行时为前缀<code>docker://</code><br />并<code>containerd://取决于容器运行时。这使得 Prometheus 中的</code>kube_pod_container_info&#96;&#96;</td></tr><tr><td>name</td><td>容器的名称</td></tr><tr><td>image_id</td><td>镜像id 以与 k8s pod 的指标相同的格式表示。这使得 Prometheus 中的<code>kube_pod_container_info</code></td></tr><tr><td>pod</td><td>如果<code>io.kubernetes.pod.name</code>在容器上设置了<code>pod </code>标签，则其值将设置为指标中的标签</td></tr><tr><td>namespace</td><td>如果<code>io.kubernetes.pod.namespace容器上设置了</code>namespace&#96;标签，则其值将设置为指标的标签</td></tr></tbody></table><h2 id="与自建prometheus集成"><a href="#与自建prometheus集成" class="headerlink" title="与自建prometheus集成"></a>与自建prometheus集成</h2><p>1，修改prometheus配置文件</p><blockquote><p>kube-state-metrics是部署在kube-system命名空间下的，因此在正则匹配上，命名空间为kube-system，svc名称为missing-container-metrics，否则就不进行监控</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml">  <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;missing-container-metrics&quot;</span><br>  <span class="hljs-attr">kubernetes_sd_configs:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">endpoints</span><br>  <span class="hljs-attr">relabel_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span> [<span class="hljs-string">__meta_kubernetes_namespace</span>, <span class="hljs-string">__meta_kubernetes_endpoints_name</span>]<br>    <span class="hljs-attr">regex:</span> <span class="hljs-string">missing-container-metrics;missing-container-metrics</span><br>    <span class="hljs-attr">action:</span> <span class="hljs-string">keep</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">bearer_token_file:</span> <span class="hljs-string">/var/run/secrets/kubernetes.io/serviceaccount/token</span><br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172307683.png" alt="image-20220917230740611"></p><p>由于helm部署只部署了<strong>DaemonSet</strong> ，可以手动创建一个svc</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">missing-container-metrics</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">missing-container-metrics</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-number">3001</span><span class="hljs-number">-3001</span><span class="hljs-string">-tcp-2tsffjchpoi</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">3001</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">3001</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app.kubernetes.io/instance:</span> <span class="hljs-string">missing-container-metrics</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">missing-container-metrics</span><br>  <span class="hljs-attr">sessionAffinity:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br><br></code></pre></td></tr></table></figure><p>查看prometheus的targets</p><p>部署成功后，prometheus的target会出现如下标志</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172310497.png" alt="image-20220917231019436"></p><p>创建告警规则</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">###添加<br>prometheusOperator:<br>  podMonitor:<br>    # Create a Prometheus Operator PodMonitor resource<br>    enabled: true<br>    # Namespace defaults to the Release namespace but can be overridden<br>    namespace: &quot;&quot;<br>    # Additional labels to add to the PodMonitor so it matches the Operator&#x27;s podMonitorSelector<br>    selector:<br>      app.kubernetes.io/name: missing-container-metrics<br><br>  prometheusRule:<br>    # Create a Prometheus Operator PrometheusRule resource<br>    enabled: true<br>    # Namespace defaults to the Release namespace but can be overridden<br>    namespace: &quot;&quot;<br>    # Additional labels to add to the PrometheusRule so it matches the Operator&#x27;s ruleSelector<br>    selector:<br>      prometheus: k8s<br>      role: alert-rules<br>    # The rules can be set here. An example is defined here but can be overridden.<br>    rules:<br>    - alert: ContainerOOMObserved<br>      annotations:<br>        message: A process in this Pod has been OOMKilled due to exceeding the Kubernetes memory limit at least twice in the last 15 minutes. Look at the metrics to determine if a memory limit increase is required.<br>      expr: sum(increase(container_ooms[15m])) by (exported_namespace, exported_pod) &gt; 2<br>      labels:<br>        severity: warning<br>    - alert: ContainerOOMObserved<br>      annotations:<br>        message: A process in this Pod has been OOMKilled due to exceeding the Kubernetes memory limit at least ten times in the last 15 minutes. Look at the metrics to determine if a memory limit increase is required.<br>      expr: sum(increase(container_ooms[15m])) by (exported_namespace, exported_pod) &gt; 10<br>      labels:<br>        severity: critical<br></code></pre></td></tr></table></figure><p>2，模拟OOM</p><p>创建一个 Pod，尝试分配超出其限制的内存。 这是一个 Pod 的配置文件，其拥有一个容器，该容器的内存请求为 50 MiB，内存限制为 100 MiB：<br>在配置文件的 <code>args</code> 部分中，你可以看到容器会尝试分配 250 MiB 内存，这远高于 100 MiB 的限制。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  labels:<br>    k8s-app: memory-request-limit<br>    qcloud-app: memory-request-limit<br>  name: memory-request-limit<br>  namespace: default<br>spec:<br>  replicas: 1<br>  selector:<br>    matchLabels:<br>      k8s-app: memory-request-limit<br>      qcloud-app: memory-request-limit<br>  template:<br>    metadata:<br>      labels:<br>        k8s-app: memory-request-limit<br>        qcloud-app: memory-request-limit<br>    spec:<br>      containers:<br>      - args:<br>        - --vm<br>        - &quot;1&quot;<br>        - --vm-bytes<br>        - 250M<br>        - --vm-hang<br>        - &quot;1&quot;<br>        command:<br>        - stress<br>        image: polinux/stress:latest<br>        imagePullPolicy: IfNotPresent<br>        name: memory-demo-ctr<br>        resources:<br>          limits:<br>            memory: 100Mi<br>          requests:<br>            memory: 50Mi<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209180008639.png" alt="image-20220918000817592"></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sum</span>(increase(container_ooms[15m])) by (exported_namespace, exported_pod) &gt; 3<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172323238.png" alt="image-20220917232300114"></p><h2 id="云原生监控TMP使用missing-container-metrics"><a href="#云原生监控TMP使用missing-container-metrics" class="headerlink" title="云原生监控TMP使用missing-container-metrics"></a>云原生监控TMP使用missing-container-metrics</h2><p>1，添加数据采集配置  </p><p>登陆Promtheus 监控控制台，选择集群监控&gt; 数据采集配置&gt;自定义监控&gt; 新增数据采集配置</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172332533.png" alt="image-20220917233213424"></p><p>2，查看当前采集，如下图所示，表示已经采集到监控数据</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172335898.png" alt="image-20220917233503809"></p><p>3， 配置告警规则prometheusRule </p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209172345261.png" alt="image-20220917234532164"></p><p>查看告警历史</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209180036206.png" alt="image-20220918003616097"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209180050304.png" alt="image-20220918005055241"></p><p>参考文档：<a href="https://github.com/draganm/missing-container-metrics">https://github.com/draganm/missing-container-metrics</a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Prometheus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在TKE里安装和使用Traefik Ingress</title>
      <link href="/post/94ad787b.html"/>
      <url>/post/94ad787b.html</url>
      
        <content type="html"><![CDATA[<h2 id="在TKE里安装和使用Traefik-Ingress"><a href="#在TKE里安装和使用Traefik-Ingress" class="headerlink" title="在TKE里安装和使用Traefik Ingress"></a>在TKE里安装和使用Traefik Ingress</h2><blockquote><p><a href="https://doc.traefik.io/traefik/">Traefik 官方文档</a></p></blockquote><p>Traefik 是一个为了让部署微服务更加便捷而诞生的现代HTTP反向代理、负载均衡工具</p><ul><li><p>Traefik的与众不同之处在于，除了它的许多特性之外，它还能自动发现服务的正确配置。当Traefik检查您的基础设施时，它会发现相关信息并发现哪个服务服务于哪个请求。</p></li><li><p>Traefik从根本上兼容所有主要的集群技术，如Kubernetes、Docker、Docker Swarm、AWS、Mesos、Marathon等，并且可以同时处理很多问题。</p></li><li><p>使用Traefik，不需要维护和同步单独的配置文件，所有事情都是自动实时发生的(没有重启，没有连接中断)。使用Traefik，用户可以将时间花在开发和部署系统新功能上，而不是配置和维护系统的工作状态上。</p></li></ul><p><strong>环境准备</strong></p><ul><li>TKE集群，版本1.18</li></ul><h3 id="安装Traefik方式一-YAML"><a href="#安装Traefik方式一-YAML" class="headerlink" title="安装Traefik方式一 YAML"></a>安装Traefik方式一 YAML</h3><blockquote><p>本文介绍两种安装方式，yaml和helm chart方式，根据自己情况 只需要选一种即可</p></blockquote><p>本文介绍如何在 TKE 环境中使用Traefik Ingress，目标是学习如何在Kubernetes中运行Traefik反向代理后的应用程序。它介绍并解释了开始使用Traefik所需的基本块，如入口控制器、入口、部署、静态和动态配置。</p><p>Traefik使用Kubernetes API来发现正在运行的服务，为了使用Kubernetes API, Traefik需要一些权限。此权限机制基于集群管理员定义的角色。然后将角色绑定到应用程序使用的帐户</p><p><strong>创建角色</strong> </p><p>traefik-role.yaml示例：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">traefik-role</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">services</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">endpoints</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">secrets</span><br>    <span class="hljs-attr">verbs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">get</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">extensions</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">networking.k8s.io</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ingresses</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ingressclasses</span><br>    <span class="hljs-attr">verbs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">get</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">list</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">watch</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">extensions</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">networking.k8s.io</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ingresses/status</span><br>    <span class="hljs-attr">verbs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">update</span><br></code></pre></td></tr></table></figure><p>创建服务账号：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">traefik-account</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br></code></pre></td></tr></table></figure><p>创建ClusterRoleBinding</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">traefik-role-binding</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">traefik-role</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">traefik-account</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span>  <span class="hljs-comment"># Using &quot;default&quot; because we did not specify a namespace when creating the ClusterAccount.</span><br></code></pre></td></tr></table></figure><p><strong>部署 ingress controller</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">traefik-ingress-controller</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">traefik</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">traefik</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">traefik</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">traefik-account</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">traefik</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">traefik:v2.8</span><br>          <span class="hljs-attr">args:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--api.insecure</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--providers.kubernetesingress.ingressclass=traefik</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">--log.level=DEBUG</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">dashboard</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><p>一个workload可以运行多个Traefik代理Pods，需要一个片段将流量转发到任何实例： 即一个服务。创建名为traefik-ingress-controller-services的文件。yaml并插入两个Service资源:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">traefik-dashboard-service</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-string">dashboard</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">traefik</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">traefik-ingress-controller-services</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">LoadBalancer</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targetPort:</span> <span class="hljs-string">web</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">traefik</span><br></code></pre></td></tr></table></figure><p>执行以下命令将 Traefik 安装到 TKE 集群</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-249-130-tlinux ~/traefik]<span class="hljs-comment"># kubectl  apply -f .</span><br>serviceaccount/traefik-account created<br>service/traefik-dashboard-service created<br>service/traefik-ingress-controller-services created<br>deployment.apps/traefik-ingress-controller created<br>clusterrolebinding.rbac.authorization.k8s.io/traefik-role-binding created<br>clusterrole.rbac.authorization.k8s.io/traefik-role created<br></code></pre></td></tr></table></figure><p>获取流量入口的 IP 地址（如下为 EXTERNAL-IP 字段），以及Dashboard,示例如下</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-249-130-tlinux ~/traefik]<span class="hljs-comment"># kubectl -n kube-system get pods,svc  | grep traefik</span><br>pod/traefik-ingress-controller-5b6dd45cfb-pvddr   1/1     Running            0          3m29s<br>service/traefik-dashboard-service             LoadBalancer   172.16.255.160   118.24.226.193    8080:30299/TCP   3m29s<br>service/traefik-ingress-controller-services   LoadBalancer   172.16.253.56    114.117.220.253   80:31292/TCP     3m29s<br></code></pre></td></tr></table></figure><h3 id="安装Traefik方式二-Helm"><a href="#安装Traefik方式二-Helm" class="headerlink" title="安装Traefik方式二 Helm"></a>安装Traefik方式二 Helm</h3><blockquote><p>Traefik可以安装在Kubernetes使用Helm 仓库从<a href="https://github.com/traefik/traefik-helm-chart%E3%80%82">https://github.com/traefik/traefik-helm-chart。</a></p></blockquote><p>确保满足以下要求:</p><ul><li><p>已创建TKE集群 Kubernetes 1.14 +</p></li><li><p>已安装helm客户端  版本3.x以上 ，<a href="https://blog.chen1900s.cn/post/e3ad72ca.html">helm安装参考</a></p></li></ul><p>添加Traefik的helm chart 仓库</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">helm repo add traefik https://helm.traefik.io/traefik<br></code></pre></td></tr></table></figure><p>准备配置文件values.yaml：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">providers:</span> <br>  <span class="hljs-attr">kubernetesIngress:</span> <br>    <span class="hljs-attr">publishedService:</span> <br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>   <span class="hljs-comment">#让 Ingress的外部 IP 地址状态显示为 Traefik 的 LB IP 地址</span><br><span class="hljs-attr">additionalArguments:</span> <br><span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--providers.kubernetesingress.ingressclass=traefik&quot;</span> <span class="hljs-comment"># 指定 ingress class 名称 </span><br><span class="hljs-bullet">-</span> <span class="hljs-string">&quot;--log.level=DEBUG&quot;</span> <br><span class="hljs-attr">ports:</span> <br>  <span class="hljs-attr">web:</span> <br>    <span class="hljs-attr">expose:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">exposedPort:</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 对外的 HTTP 端口号，使用标准端口号在国内需备案</span><br>  <span class="hljs-attr">websecure:</span> <br>    <span class="hljs-attr">expose:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">exposedPort:</span> <span class="hljs-number">443</span> <span class="hljs-comment"># 对外的 HTTPS 端口号，使用标准端口号在国内需备案</span><br>  <span class="hljs-attr">traefik:</span><br>    <span class="hljs-attr">expose:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">exposedPort:</span> <span class="hljs-number">9000</span><br><span class="hljs-attr">deployment:</span> <br>  <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><blockquote><p>完整的默认配置可执行 <code>helm show values traefik/traefik</code> 命令查看</p></blockquote><p>用helm命令行安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">helm install traefik -f values.yaml traefik/traefik  <span class="hljs-comment">#默认是安装在default命名空间下的</span><br><br><span class="hljs-comment">#可以指定命名命名空间进行安装</span><br>kubectl create ns traefik-v2<br><span class="hljs-comment"># Install in the namespace &quot;traefik-v2&quot;</span><br>helm install --namespace=traefik-v2 -f values.yaml    traefik traefik/traefik<br><br><span class="hljs-comment">#后续如果修改配置使用如下命令进行更新</span><br>helm upgrade --install traefik -f values.yaml traefik/traefik<br></code></pre></td></tr></table></figure><p>查看部署的资源</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-249-130-tlinux ~]<span class="hljs-comment"># kubectl   get pods,svc</span><br>NAME                           READY   STATUS    RESTARTS   AGE<br>pod/traefik-7bb76c56fb-skzvq   1/1     Running   0          5m22s<br><br>NAME                 TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)                      AGE<br>service/kubernetes   ClusterIP      172.16.252.1     &lt;none&gt;          443/TCP                      95m<br>service/traefik      LoadBalancer   172.16.252.238   118.24.225.19   80:32467/TCP,443:30353/TCP   5m22s<br></code></pre></td></tr></table></figure><h3 id="使用-Ingress"><a href="#使用-Ingress" class="headerlink" title="使用 Ingress"></a>使用 Ingress</h3><p>我们使用示例应用程序traefik&#x2F;whoami，但其原则适用于任何其他应用程序。</p><p>whoami应用程序是一个简单的HTTP服务器，运行在端口80上，它向传入的请求应答与主机相关的信息。和往常一样，首先创建一个名为whoami的文件。yml并粘贴以下部署资源:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">whoami</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">whoami</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">traefik/whoami</span><br>          <span class="hljs-attr">ports:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>              <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>创建service</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">whoami</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">whoami</span><br></code></pre></td></tr></table></figure><p>Traefik 支持使用 Kubernetes 的 Ingress 资源作为动态配置，可直接在集群中创建 Ingress 资源用于对外暴露集群，需要加上指定的 Ingress class（安装 Traefik 时定义）。示例如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span> <br>  <span class="hljs-attr">name:</span> <span class="hljs-string">whoami-ingress</span><br>  <span class="hljs-attr">annotations:</span> <br>    <span class="hljs-attr">kubernetes.io/ingress.class:</span> <span class="hljs-string">traefik</span> <span class="hljs-comment"># 这里指定 ingress class 名称</span><br><span class="hljs-attr">spec:</span> <br>  <span class="hljs-attr">rules:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">traefik.chen1900s.cn</span><br>    <span class="hljs-attr">http:</span> <br>      <span class="hljs-attr">paths:</span> <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">backend:</span> <br>          <span class="hljs-attr">serviceName:</span> <span class="hljs-string">whoami</span><br>          <span class="hljs-attr">servicePort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><blockquote><p>TKE 暂未将 Traefik 产品化，无法直接在 TKE 控制台进行可视化创建 Ingress，需要使用 YAML 进行创建。</p></blockquote><p><strong>使用安装方式一 部署后访问测试如下</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-249-130-tlinux ~/traefik]<span class="hljs-comment"># nslookup traefik.chen1900s.cn  #解析到traefik-ingress-controller的service VIP上</span><br>Server:         183.60.82.98<br>Address:        183.60.82.98<span class="hljs-comment">#53</span><br><br>Non-authoritative answer:<br>Name:   traefik.chen1900s.cn<br>Address: 114.117.220.253<br><br>[root@VM-249-130-tlinux ~/traefik]<span class="hljs-comment"># curl http://traefik.chen1900s.cn/</span><br>Hostname: whoami-5db58df676-vwvzv<br>IP: 127.0.0.1<br>IP: 172.16.0.5<br>RemoteAddr: 172.16.0.7:49846<br>GET / HTTP/1.1<br>Host: traefik.chen1900s.cn<br>User-Agent: curl/7.29.0<br>Accept: */*<br>Accept-Encoding: gzip<br>X-Forwarded-For: 172.16.0.1<br>X-Forwarded-Host: traefik.chen1900s.cn<br>X-Forwarded-Port: 80<br>X-Forwarded-Proto: http<br>X-Forwarded-Server: traefik-ingress-controller-745b557778-jrjzn<br>X-Real-Ip: 172.16.0.1<br></code></pre></td></tr></table></figure><p><strong>使用安装方式二  部署后访问测试如下：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-0-33-tlinux ~]<span class="hljs-comment"># curl http://traefik.chen1900s.cn/</span><br>Hostname: whoami-5db58df676-856ss<br>IP: 127.0.0.1<br>IP: 172.16.0.10<br>RemoteAddr: 172.16.0.9:58498<br>GET / HTTP/1.1<br>Host: traefik.chen1900s.cn<br>User-Agent: curl/7.29.0<br>Accept: */*<br>Accept-Encoding: gzip<br>X-Forwarded-For: 172.16.0.1<br>X-Forwarded-Host: traefik.chen1900s.cn<br>X-Forwarded-Port: 80<br>X-Forwarded-Proto: http<br>X-Forwarded-Server: traefik-7bb76c56fb-skzvq<br>X-Real-Ip: 172.16.0.1<br><br>[root@VM-0-33-tlinux ~]<span class="hljs-comment"># nslookup traefik.chen1900s.cn   #正常解析到 方式二 对应的service VIP上</span><br>Server:         183.60.83.19<br>Address:        183.60.83.19<span class="hljs-comment">#53</span><br><br>Non-authoritative answer:<br>Name:   traefik.chen1900s.cn<br>Address: 118.24.225.19<br></code></pre></td></tr></table></figure><h3 id="使用Traefik-Dashboard"><a href="#使用Traefik-Dashboard" class="headerlink" title="使用Traefik Dashboard"></a>使用Traefik Dashboard</h3><p>使用第一种方式安装时候默认安装了Traefik Dashboard，使用方式二Helm chart 方式安装，出于安全考虑，这个Helm Chart默认情况下不公开Traefik Dashboard。因此，如果需要暴露Dashboard端口，需要在values.yaml里面添加</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">traefik:</span><br>  <span class="hljs-attr">expose:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">exposedPort:</span> <span class="hljs-number">9000</span><br></code></pre></td></tr></table></figure><blockquote><p>还有更多参数可以通过<code>helm show values traefik/traefik</code> 命令查看， 比如暴露metrics端口等等</p></blockquote><p>或者使用IngressRoute CRD</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">traefik.containo.us/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">IngressRoute</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dashboard</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">entryPoints:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span> <span class="hljs-string">Host(`traefikdashboard.chen1900s.cn`)</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">(PathPrefix(`/dashboard`)</span> <span class="hljs-string">||</span> <span class="hljs-string">PathPrefix(`/api`))</span><br>      <span class="hljs-attr">kind:</span> <span class="hljs-string">Rule</span><br>      <span class="hljs-attr">services:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">api@internal</span><br>          <span class="hljs-attr">kind:</span> <span class="hljs-string">TraefikService</span><br></code></pre></td></tr></table></figure><p>方式一安装默认是8080端口</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171716193.png" alt="image-20220917171631043"></p><p>方式二helm方式安装，端口设置的是9000</p><p><a href="http://external-ip:9000/dashboard/#/">http://EXTERNAL-IP:9000/dashboard/#/</a></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209171804625.png" alt="image-20220917180436515"></p><h3 id="使用-IngressRoute"><a href="#使用-IngressRoute" class="headerlink" title="使用 IngressRoute"></a>使用 IngressRoute</h3><p>Traefik 不仅支持标准的 Kubernetes Ingress 资源，也支持 Traefik 特有的 CRD 资源，例如 IngressRoute，可以支持更多 Ingress 不具备的高级功能。IngressRoute 使用示例如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">traefik.containo.us/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">IngressRoute</span><br><span class="hljs-attr">metadata:</span> <br>  <span class="hljs-attr">name:</span> <span class="hljs-string">whoami-ingressroute</span><br><span class="hljs-attr">spec:</span> <br>  <span class="hljs-attr">entryPoints:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">web</span><br>  <span class="hljs-attr">routes:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">match:</span> <span class="hljs-string">Host(`traefikroute.chen1900s.cn`)</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">PathPrefix(`/`)</span><br>      <span class="hljs-attr">kind:</span> <span class="hljs-string">Rule</span><br>      <span class="hljs-attr">services:</span> <br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">whoami</span><br>          <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>创建ingressroute</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#kubectl  apply -f whoami-ingressroute.yaml </span><br>ingressroute.traefik.containo.us/whoami-ingressroute created<br><br></code></pre></td></tr></table></figure><p>查看是否创建成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># kubectl   get ingressroute</span><br>NAME                  AGE<br>whoami-ingressroute   48s<br></code></pre></td></tr></table></figure><p>访问验证</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@VM-249-130-tlinux ~]<span class="hljs-comment"># curl  http://traefikroute.chen1900s.cn</span><br>Hostname: whoami-5db58df676-856ss<br>IP: 127.0.0.1<br>IP: 172.16.0.10<br>RemoteAddr: 172.16.0.9:57430<br>GET / HTTP/1.1<br>Host: traefikroute.chen1900s.cn<br>User-Agent: curl/7.29.0<br>Accept: */*<br>Accept-Encoding: gzip<br>X-Forwarded-For: 172.16.0.1<br>X-Forwarded-Host: traefikroute.chen1900s.cn<br>X-Forwarded-Port: 80<br>X-Forwarded-Proto: http<br>X-Forwarded-Server: traefik-7bb76c56fb-skzvq<br>X-Real-Ip: 172.16.0.1<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TKE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> TKE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自建Harbor镜像仓库</title>
      <link href="/post/6763f77d.html"/>
      <url>/post/6763f77d.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Harbor"><a href="#什么是Harbor" class="headerlink" title="什么是Harbor"></a>什么是Harbor</h2><p>Harbor 是由 VMware 公司中国团队为企业用户设计的 Registry server 开源项目，包括了权限管理(RBAC)、LDAP、审计、管理界面、自我注册、HA 等企业必需的功能，同时针对中国用户的特点，设计镜像复制和中文支持等功能</p><blockquote><p><a href="https://goharbor.io/">Harbor官方文档</a></p></blockquote><blockquote><p><a href="https://github.com/goharbor/harbor">Harbor Github项目</a></p></blockquote><h2 id="部署安装"><a href="#部署安装" class="headerlink" title="部署安装"></a>部署安装</h2><ol><li>CentOS Linux release 7.8.2003 (Core)</li><li>Docker version 19.03.13</li><li>docker-compose version 1.24.1</li></ol><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><h4 id="二进制方式安装"><a href="#二进制方式安装" class="headerlink" title="二进制方式安装"></a>二进制方式安装</h4><blockquote><p><a href="https://download.docker.com/linux/static/stable/x86_64/docker-19.03.9.tgz">二进制安装包下载地址</a></p></blockquote><p><strong>1，下载安装包</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">wget https://download.docker.com/linux/static/stable/x86_64/docker-19.03.9.tgz<br>tar zxvf docker-19.03.9.tgz<br>mv docker/* /usr/bin<br></code></pre></td></tr></table></figure><p><strong>2，systemd管理docker</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cat &gt; /usr/lib/systemd/system/docker.service &lt;&lt; EOF<br>[Unit]<br>Description=Docker Application Container Engine<br>Documentation=https://docs.docker.com<br>After=network-online.target firewalld.service<br>Wants=network-online.target<br><br>[Service]<br>Type=notify<br>ExecStart=/usr/bin/dockerd<br>ExecReload=/bin/kill -s HUP $MAINPID<br>LimitNOFILE=infinity<br>LimitNPROC=infinity<br>LimitCORE=infinity<br>TimeoutStartSec=0<br>Delegate=yes<br>KillMode=process<br>Restart=on-failure<br>StartLimitBurst=3<br>StartLimitInterval=60s<br><br>[Install]<br>WantedBy=multi-user.target<br>EOF<br><br></code></pre></td></tr></table></figure><h4 id="yum方式安装"><a href="#yum方式安装" class="headerlink" title="yum方式安装"></a><strong>yum方式安装</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#卸载旧版本<br>yum remove docker docker-common docker-selinux docker-engine -y<br><br># 安装需要的软件包<br>sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br><br># 设置yum源为阿里云<br>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><br>#或者设置官方源<br>#sudo yum-config-manager \--add-repo \https://download.docker.com/linux/centos/docker-ce.repo<br><br><br># 安装docker<br>sudo yum install docker-ce -y<br></code></pre></td></tr></table></figure><p>以上两种方式任选一种安装即可</p><h4 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mkdir -p /etc/docker<br>cat &gt; /etc/docker/daemon.json &lt;&lt; EOF<br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://mirror.ccs.tencentyun.com&quot;]<br>&#125;<br>EOF<br><br><br>#阿里云镜像加速器 也可以替换成腾讯云的镜像加速<br></code></pre></td></tr></table></figure><h4 id="启动并设置开机启动"><a href="#启动并设置开机启动" class="headerlink" title="启动并设置开机启动"></a>启动并设置开机启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">systemctl daemon-reload<br>systemctl start docker<br>systemctl enable docker<br>systemctl status docker<br><br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209042225199.png" alt="image-20210417194150567"></p><h3 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h3><blockquote><p><a href="https://docs.docker.com/compose/install/">docker-compose官网文档介绍</a></p></blockquote><h4 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h4><p>1，下载安装包</p><p>或者离线下载安装包我们可以从 Github 上下载它的二进制包来使用，<a href="https://github.com/docker/compose/releases">最新发行的版本地址</a></p><p>或通过命令行下载</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-(uname -s)−(uname -m)&quot; -o /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><p>2，安装docker-compose</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sudo chmod +x  /usr/local/bin/docker-compose<br>sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose<br><br>#docker-compose -v<br>Docker Compose version v2.10.2  #表示安装成功<br><br></code></pre></td></tr></table></figure><h4 id="yum源安装"><a href="#yum源安装" class="headerlink" title="yum源安装"></a>yum源安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">docker-compose version<br><br>[root@VM-249-124-tlinux ~]# docker-compose version<br>docker-compose version 1.18.0, build 8dd22a9<br>docker-py version: 2.6.1<br>CPython version: 3.6.8<br>OpenSSL version: OpenSSL 1.0.2k-fips  26 Jan 2017  #表示安装成功<br></code></pre></td></tr></table></figure><h3 id="安装Harbor"><a href="#安装Harbor" class="headerlink" title="安装Harbor"></a>安装Harbor</h3><p>通过命令行下载 或者直接在GIthub上里面下载好的离线安装包，<a href="https://github.com/goharbor/harbor">下载地址</a></p><p>下载完毕后，上传到需要安装harbor的服务器上，进行解压</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">wget https://github.com/goharbor/harbor/releases/download/v2.1.4/harbor-offline-installer-v2.1.4.tgz<br><br>tar xvf harbor-offline-installer-v2.1.4.tgz<br></code></pre></td></tr></table></figure><p>进入harbor 目录，根据需要修改相关参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cd harbor<br>cp harbor.yml.tmpl harbor.yml  #默认是harbor.yml.tmpl需要将这个文件重命名一下<br>vi harbor.yml<br></code></pre></td></tr></table></figure><p> 如果没有域名，使用IP去访问，需要修改以下几项内容</p><blockquote><p>hostname:  修改成自建服务器IP</p><p>http.</p><p>   port: 端口</p><p>注释掉https相关配置项</p><p>harbor_admin_password:  harbor登陆密码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Configuration file of Harbor<br><br># The IP address or hostname to access admin UI and registry service.<br># DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.<br>hostname: 94.191.122.37                         #需要修改成自己的域名，如果没有域名直接填写自己的 IP<br><br># http related config<br>http:<br>  # port for http, default is 80. If https enabled, this port will redirect to https port<br>  port: 80                                      #默认端口是80，如果想修改也可以修改成启动端口<br><br># https related config<br>#https:                                         #启用https, 如果不想要，需要注释掉<br>  # https port for harbor, default is 443<br>  #port: 443                                    #https的端口，默认是443<br>  #The path of cert and key files for nginx<br>  #certificate: /your/certificate/path            #需要将证书上传到对应路径下，根据情况可自行修改<br>  #private_key: /your/private/key/path            #需要将证书上传到对应路径下，根据情况可自行修改<br><br># # Uncomment following will enable tls communication between all harbor components<br># internal_tls:<br>#   # set enabled to true means internal tls is enabled<br>#   enabled: true<br>#   # put your cert and key files on dir<br>#   dir: /etc/harbor/tls/internal<br><br># Uncomment external_url if you want to enable external proxy<br># And when it enabled the hostname will no longer used<br># external_url: https://reg.mydomain.com:8433<br><br># The initial password of Harbor admin<br># It only works in first time to install harbor<br># Remember Change the admin password from UI after launching Harbor.<br>harbor_admin_password: xxxxxx密码                          #登陆镜像仓库的初始化密码，根据情况可自行修改<br><br># Harbor DB configuration<br>database:<br>  # The password for the root user of Harbor DB. Change this before any production use.<br>  password: xxxxxxx密码<br>  # The maximum number of connections in the idle connection pool. If it &lt;=0, no idle connections are retained.<br>  max_idle_conns: 50<br>  # The maximum number of open connections to the database. If it &lt;= 0, then there is no limit on the number of open connections.<br>  # Note: the default number of connections is 1024 for postgres of harbor.<br>  max_open_conns: 1000<br><br># The default data volume<br>data_volume: /data                          #默认是/data 根据情况自行修改，如果是生产环境使用，建议是修改下镜像存储的路径<br><br>###################下面其他内容保持默认就可以，这里就不累赘介绍了<br><br></code></pre></td></tr></table></figure><p>修改完配置后，确认无误执行如下命令进行安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">./install.sh<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[Step 5]: starting Harbor ...<br>[+] Running 10/10<br> ⠿ Network harbor_harbor        Created     0.0s<br> ⠿ Container harbor-log         Started     0.9s<br> ⠿ Container redis              Started     1.7s<br> ⠿ Container harbor-portal      Started     1.8s<br> ⠿ Container registryctl        Started     1.5s<br> ⠿ Container harbor-db          Started     1.6s<br> ⠿ Container registry           Started     1.8s<br> ⠿ Container harbor-core        Started     2.2s<br> ⠿ Container nginx              Started     2.9s<br> ⠿ Container harbor-jobservice  Started     2.9s<br>✔ ----Harbor has been installed and started successfully.----<br></code></pre></td></tr></table></figure><p>有如上提示表示安装成功</p><h2 id="harbor基本使用"><a href="#harbor基本使用" class="headerlink" title="harbor基本使用"></a>harbor基本使用</h2><p>然后我们访问一下这个地址，如果是http的则可以直接使用IP地址+端口访问，用户名默认是：admin，密码就是配置文件里面那个harbor.yml文件里面harbor_admin_password值</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209042225339.png" alt="image-20210510155124472"></p><h3 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h3><p>可以添加其他仓管，以腾讯云TCR镜像仓库为例</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209042225383.png" alt="image-20210510155336022"></p><h3 id="复制管理"><a href="#复制管理" class="headerlink" title="复制管理"></a>复制管理</h3><p>复制管理 可以将本地镜像复制到其他镜像仓库，也可以将其他镜像仓库复制到本地</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209042225424.png" alt="image-20210510155605740"></p><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p>您可以为不同类被镜像创建项目 或者为不同的项目组创建项目</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209042225472.png" alt="image-20210510155930055"></p><h3 id="仓库管理-1"><a href="#仓库管理-1" class="headerlink" title="仓库管理"></a>仓库管理</h3><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209042225508.png" alt="image-20210510160003817"></p><h3 id="镜像上传下载"><a href="#镜像上传下载" class="headerlink" title="镜像上传下载"></a>镜像上传下载</h3><p>登陆镜像仓库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#docker login  94.191.122.37:端口  （如果使用的是默认80端口，则可以不指定端口）<br><br></code></pre></td></tr></table></figure><p>如果默认docker配置登陆会报如下错误，不用担心，因为docker默认是使用https，而且要必须使用域名，只是用ip访问是不行的，可以通过添加信任列表解决</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-249-124-tlinux ~/harbor]# docker login 94.191.122.37<br>Username: admin<br>Password: <br>Error response from daemon: Get https://94.191.122.37/v2/: dial tcp 94.191.122.37:443: connect: connection refused<br></code></pre></td></tr></table></figure><p>修改docker的配置文件&#x2F;etc&#x2F;docker&#x2F;daemon.json，添加 insecure-registries配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cat /etc/docker/daemon.json<br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://mirror.ccs.tencentyun.com&quot;],<br>  &quot;insecure-registries&quot;: [&quot;94.191.122.37&quot;]    #添加这个配置，如果端口不是默认80记得要加下端口噢<br>&#125;<br></code></pre></td></tr></table></figure><p>然后重启docker 进程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">systemctl restart docker<br>systemctl status docker<br></code></pre></td></tr></table></figure><p>重启harbor服务（需要进入有harbor.yaml文件的目录执行）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-249-124-tlinux ~/harbor]# docker-compose  restart<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#1，登陆<br>[root@VM-249-124-tlinux ~/harbor]# docker login  94.191.122.37<br>Username: admin<br>Password: <br>WARNING! Your password will be stored unencrypted in /root/.docker/config.json.<br>Configure a credential helper to remove this warning. See<br>https://docs.docker.com/engine/reference/commandline/login/#credentials-store<br><br>Login Succeeded,<br>#2，从dockerhub下载一个测试镜像<br>[root@VM-249-124-tlinux ~/harbor]# docker pull busybox<br>Using default tag: latest<br>latest: Pulling from library/busybox<br>2c39bef88607: Pull complete <br>Digest: sha256:20142e89dab967c01765b0aea3be4cec3a5957cc330f061e5503ef6168ae6613<br>Status: Downloaded newer image for busybox:latest<br>docker.io/library/busybox:latest<br>[root@VM-249-124-tlinux ~/harbor]# docker  images | grep busy<br>busybox                                               latest              c98db043bed9        3 days ago          1.24MB<br>#3，重新打tag <br>[root@VM-249-124-tlinux ~/harbor]# docker tag  c98db043bed9  94.191.122.37/docker/busybox:harbor<br><br>#4，推送到自建的镜像仓库，需要主要的是项目需要添加创建好，我这里创建的是docker项目<br>[root@VM-249-124-tlinux ~/harbor]# docker push 94.191.122.37/docker/busybox:harbor<br>The push refers to repository [94.191.122.37/docker/busybox]<br>c1cf1676e7d0: Pushed <br>harbor: digest: sha256:15a3c8a1b44b5ef66f9b4b2e1875b50302d100e116f1d4d5ede71d5ac63177c3 size: 527<br><br>#5，在本地删除这个镜像，然后测试拉取<br>root@VM-249-124-tlinux ~/harbor]# docker rmi  94.191.122.37/docker/busybox:harbor<br>Untagged: 94.191.122.37/docker/busybox:harbor<br>Untagged: 94.191.122.37/docker/busybox@sha256:15a3c8a1b44b5ef66f9b4b2e1875b50302d100e116f1d4d5ede71d5ac63177c3<br>[root@VM-249-124-tlinux ~/harbor]# docker rmi busybox<br>Untagged: busybox:latest<br>Untagged: busybox@sha256:20142e89dab967c01765b0aea3be4cec3a5957cc330f061e5503ef6168ae6613<br>Deleted: sha256:c98db043bed913c5a7b59534cbf8d976122f98b75cb00baabf8af888041e4f9d<br>Deleted: sha256:c1cf1676e7d071645e67257fbb18db931a091c73a211f87bf4559c86e75bcdd3<br><br>#5，测试从自建镜像仓库拉取镜像<br>[root@VM-249-124-tlinux ~/harbor]# docker pull 94.191.122.37/docker/busybox:harbor<br>harbor: Pulling from docker/busybox<br>2c39bef88607: Pull complete <br>Digest: sha256:15a3c8a1b44b5ef66f9b4b2e1875b50302d100e116f1d4d5ede71d5ac63177c3<br>Status: Downloaded newer image for 94.191.122.37/docker/busybox:harbor<br>94.191.122.37/docker/busybox:harbor<br>[root@VM-249-124-tlinux ~/harbor]# docker images | grep busybox<br>94.191.122.37/docker/busybox                          harbor              c98db043bed9        3 days ago          1.24MB<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209052257175.png" alt="image-20220905225703981"></p><h2 id="自签名证书实现https"><a href="#自签名证书实现https" class="headerlink" title="自签名证书实现https"></a>自签名证书实现https</h2><p>一般情况下，Harbor是可以不用带CA证书认证的，直接通过http方式访问，建议是在测试环境，对应生产环境，为了安全起见，更推荐使用HTTPS，使用HTTPS，需要对应SSL证书。可以使用由受信任的第三方CA签名的证书，也可以使用openssl进行自签名证，下面主要介绍如何使用 opensll创建CA，以及如何使用CA签署服务器证书和客户端证书，搭建https方式访问的harbor镜像仓库</p><blockquote><p>预定义自建的镜像仓库域名是 harbor.chen1900s.cn</p></blockquote><h3 id="自签证书"><a href="#自签证书" class="headerlink" title="自签证书"></a>自签证书</h3><p>1，创建存放证书目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mkdir  -p /root/ssl<br>cd  /root/ssl<br></code></pre></td></tr></table></figure><p>2，创建 CA 根证书</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">openssl req  -newkey rsa:4096 -nodes -sha256 -keyout ca.key -x509 -days 365 -out ca.crt -subj &quot;/C=CN/L=beijing/O=lisea/CN=harbor-registry&quot;<br></code></pre></td></tr></table></figure><p>3，生成一个证书签名, 设置访问域名为   harbor.chen1900s.com</p><blockquote><p>需要把里面的域名 替换成您想要使用的域名，时间可以自定义</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">openssl req -newkey rsa:4096 -nodes -sha256 -keyout harbor.chen1900s.com.key -out server.csr -subj &quot;/C=CN/L=beijing/O=lisea/CN=harbor.chen1900s.com&quot;<br><br></code></pre></td></tr></table></figure><p>4，生成主机的证书</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">openssl x509 -req -days 365 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out harbor.chen1900s.com.crt<br></code></pre></td></tr></table></figure><p>5，查看当前证书文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-249-124-tlinux ~/ssl]# ls -lrt<br>total 24<br>-rw-r--r-- 1 root root 3272 Sep  6 21:08 ca.key<br>-rw-r--r-- 1 root root 1931 Sep  6 21:08 ca.crt<br>-rw-r--r-- 1 root root 1663 Sep  6 21:08 server.csr<br>-rw-r--r-- 1 root root 3272 Sep  6 21:08 harbor.chen1900s.com.key<br>-rw-r--r-- 1 root root   17 Sep  6 21:10 ca.srl<br>-rw-r--r-- 1 root root 1822 Sep  6 21:10 harbor.chen1900s.com.crt<br></code></pre></td></tr></table></figure><p>6，如果已经安装http的harbor，需要先删除，再执行安装命令（如果没有安装过 这步忽略）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#1，停服务<br>docker-compose  stop<br>#2，删除容器<br>docker rm -f $(docker ps -aq)<br>#3，将镜像全部删除<br>docker rmi `docker images -q`<br><br></code></pre></td></tr></table></figure><h3 id="安装Harbor-1"><a href="#安装Harbor-1" class="headerlink" title="安装Harbor"></a>安装Harbor</h3><p>1，修改配置文件harbor.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cp ./harbor.yml.tmpl   ./harbor.yml<br><br>vi harbor.yml<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Configuration file of Harbor<br><br># The IP address or hostname to access admin UI and registry service.<br># DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.<br>hostname: harbor.chen1900s.com<br><br># http related config<br>http:<br>  # port for http, default is 80. If https enabled, this port will redirect to https port<br>  port: 80<br><br># https related config<br>https:<br>  # https port for harbor, default is 443<br>  port: 443<br>  # The path of cert and key files for nginx<br>  certificate: /root/ssl/harbor.chen1900s.com.crt<br>  private_key: /root/ssl/harbor.chen1900s.com.key<br><br># # Uncomment following will enable tls communication between all harbor components<br># internal_tls:<br>#   # set enabled to true means internal tls is enabled<br>#   enabled: true<br>#   # put your cert and key files on dir<br>#   dir: /etc/harbor/tls/internal<br>  #######其他配置保持不变<br>  <br></code></pre></td></tr></table></figure><p>2，执行安装命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">./prepare<br><br>./install.sh<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[Step 5]: starting Harbor ...<br>[+] Running 9/9<br> ⠿ Container harbor-log         Started            0.7s<br> ⠿ Container harbor-portal      Started            1.7s<br> ⠿ Container harbor-db          Started            1.5s<br> ⠿ Container registry           Started            1.6s<br> ⠿ Container redis              Started            1.7s<br> ⠿ Container registryctl        Started            1.5s<br> ⠿ Container harbor-core        Started            2.0s<br> ⠿ Container nginx              Started            2.6s<br> ⠿ Container harbor-jobservice  Started            2.6s<br> ✔ ----Harbor has been installed and started successfully.----<br></code></pre></td></tr></table></figure><p>以上提示表示安装成功</p><p>如果是自签的域名 需要加下hosts配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">94.191.122.37    harbor.chen1900s.com<br></code></pre></td></tr></table></figure><p>浏览器登陆提示不安全的证书，原因是我们是自己当CA机构，所以浏览器会不信任。添加信任就好</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209062147398.png" alt="image-20220906214758292"></p><p>其他机器如果要拉取镜像登陆镜像仓库，需要配置</p><ol><li>创建目录&#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;harbor.chen1900s.com（后面的目录是自己定义的域名）</li><li>将harbor的证书拷贝到创建的目录中</li><li>修改&#x2F;etc&#x2F;docker&#x2F;daemon.json，添加insecure-registries配置，填写自己的域名</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cat /etc/docker/daemon.json<br>&#123;<br>  &quot;registry-mirrors&quot;: [&quot;https://mirror.ccs.tencentyun.com&quot;],<br>  &quot;insecure-registries&quot;: [&quot;harbor.chen1900s.com&quot;]   <br>&#125;<br></code></pre></td></tr></table></figure><p>   4，配置hosts：94.191.122.37    harbor.chen1900s.com</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">echo  “94.191.122.37    harbor.chen1900s.com” &gt;&gt; /etc/hosts<br></code></pre></td></tr></table></figure><p>​    5，然后重启docker容器和harbor服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">systemctl daemon-reload   重新加载daemon<br>systemctl restart docker  #重启docker服务<br>systemctl status docker<br><br>docker-compose  restart  #登陆harbor配置目录执行<br></code></pre></td></tr></table></figure><h3 id="登陆和上传拉取镜像"><a href="#登陆和上传拉取镜像" class="headerlink" title="登陆和上传拉取镜像"></a>登陆和上传拉取镜像</h3><p>登陆：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">root@VM-249-124-tlinux ~/harbor]# docker login harbor.chen1900s.com<br>Username: admin<br>Password: <br>WARNING! Your password will be stored unencrypted in /root/.docker/config.json.<br>Configure a credential helper to remove this warning. See<br>https://docs.docker.com/engine/reference/commandline/login/#credentials-store<br><br>Login Succeeded<br></code></pre></td></tr></table></figure><p>上传镜像：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">docker tag 80d28bedfe5d harbor.chen1900s.com/library/pause:latest  #将镜像重新打tag<br>docker push harbor.chen1900s.com/library/pause:latest        #推送镜像<br>The push refers to repository [harbor.chen1900s.com/library/pause]<br>ba0dae6243cc: Pushed <br>latest: digest: sha256:4a1c4b21597c1b4415bdbecb28a3296c6b5e23ca4f9feeb599860a1dac6a0108 size: 52<br></code></pre></td></tr></table></figure><p>登陆其他节点拉取镜像</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-33-tlinux ~]# docker pull harbor.chen1900s.com/library/pause:latest<br>latest: Pulling from library/pause<br>Digest: sha256:4a1c4b21597c1b4415bdbecb28a3296c6b5e23ca4f9feeb599860a1dac6a0108<br>Status: Downloaded newer image for harbor.chen1900s.com/library/pause:latest<br>harbor.chen1900s.com/library/pause:latest<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Harbor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Helm安装和使用</title>
      <link href="/post/e3ad72ca.html"/>
      <url>/post/e3ad72ca.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-安装Helm客户端"><a href="#一-安装Helm客户端" class="headerlink" title="一  安装Helm客户端"></a>一  安装Helm客户端</h3><blockquote><p>本文是通过二进制方式安装，如需其他方式可以参考官网文档</p><p>helm官方文档： <a href="https://helm.sh/zh/docs/intro/install/">https://helm.sh/zh/docs/intro/install/</a></p></blockquote><p>每个Helm <a href="https://github.com/helm/helm/releases">版本</a>都提供了各种操作系统的二进制版本，不同的版本可以手动下载和安装。</p><ol><li>下载 <a href="https://github.com/helm/helm/releases">需要的版本</a></li><li>解压(<code>tar -zxvf helm-v3.0.0-linux-amd64.tar.gz</code>)</li><li>在解压目中找到<code>helm</code>程序，移动到需要的目录中(<code>mv linux-amd64/helm /usr/local/bin/helm</code>)</li></ol><h3 id="二-添加helm仓库"><a href="#二-添加helm仓库" class="headerlink" title="二  添加helm仓库"></a>二  添加helm仓库</h3><p>以腾讯云TCR镜像仓库为例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#命令示例<br>#helm repo add $instance-$namespace https://$instance.tencentcloudcr.com/chartrepo/$namespace --username $username --password $instance-token<br><br>#实际操作示例，根据自己的参考修改对应的信息<br>#其中用户和密码 可以在控制台创建<br>#helm repo add  tke-pass-helm   https://tke-pass.tencentcloudcr.com/chartrepo/helm --username xxxxxxxx   --password  xxxxxx<br></code></pre></td></tr></table></figure><ul><li><p><code>$instance-$namespace</code>：为 helm repo 名称，建议使用<strong>实例名称+命名空间名称</strong>组合的方式命名，以便于区分各个实例及命名空间。</p></li><li><p>https:&#x2F;&#x2F;$instance.tencentcloudcr.com&#x2F;chartrepo&#x2F;$namespace：为 helm repo 的远端地址。</p></li><li><p><code>$username</code>：已获取的用户名。</p></li><li><p><code>$instance-token</code>：已获取的登录密码。</p><p>如添加成功将提示以下信息。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&quot;tcr-chen-helm&quot; has been added to your repositories<br></code></pre></td></tr></table></figure><p>使用该命令可以查看当前的helm 仓库信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># helm repo list<br>NAME                            URL                                                                                         <br>tcr-chen-helm                   https://tcr-chen.tencentcloudcr.com/chartrepo/helm<br></code></pre></td></tr></table></figure><h3 id="三-推送-Helm-Chart"><a href="#三-推送-Helm-Chart" class="headerlink" title="三 推送 Helm Chart"></a>三 推送 Helm Chart</h3><ol><li><p>安装 Helm Push 插件</p><blockquote><p>注意：请安装 0.9.0 及以上版本的 helm-push 插件，避免因版本不兼容等问题造成无法正常推送 helm chart。</p></blockquote><p>使用 Helm CLI 上传 Chart 包需要安装 helm-push 插件，该插件支持使用helm push 指令推送 helm chart 至指定 repo，同时支持上传目录及压缩包。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">helm plugin install https://github.com/chartmuseum/helm-push<br></code></pre></td></tr></table></figure></li><li><p>在节点上执行以下命令，创建一个 Chart。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">helm create  chart-demo<br></code></pre></td></tr></table></figure></li><li><p>执行以下命令，可直接推送指定目录至 Chart 仓库（可选）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">helm push  chart-demo $instance-$namespace<br>#温馨提示高级版本使用的是cm-push命令<br>#helm cm-push chart-demo $instance-$namespace<br></code></pre></td></tr></table></figure><p>其中   $instance-$namespace  为已添加的本地仓库名称。</p></li><li><p>执行以下命令，可压缩指定目录，并推送至 Chart 仓库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">tar zcvf  chart-demo-1.0.0.tgz chart-demo/<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">helm push  chart-demo-1.0.0.tgz $instance-$namespace<br></code></pre></td></tr></table></figure><p>其中$instance-$namespace为已添加的本地仓库名称。</p></li></ol><h3 id="四-拉取-Helm-Chart"><a href="#四-拉取-Helm-Chart" class="headerlink" title="四 拉取 Helm Chart"></a>四 拉取 Helm Chart</h3><ol><li><p>在节点上执行以下命令，获取最新的 Chart 信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">helm repo update<br></code></pre></td></tr></table></figure></li><li><p>执行以下命令，拉取指定版本 Helm Chart。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">helm fetch &lt;本地仓库名称&gt;/&lt;Chart 名称&gt; --version &lt;Chart 版本&gt;<br></code></pre></td></tr></table></figure><p>以从企业版实例 tcr-demo 中拉取命名空间 project-a 内 tcr-chart-demo 1.0.0 版本为例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">helm fetch tcr-chen-helm/chart-demo --version 1.0.0<br></code></pre></td></tr></table></figure></li></ol><h3 id="五-自建Harbor启用helmchart服务"><a href="#五-自建Harbor启用helmchart服务" class="headerlink" title="五 自建Harbor启用helmchart服务"></a>五 自建Harbor启用helmchart服务</h3><h4 id="1，安装-harbor-的-helmchart-repository"><a href="#1，安装-harbor-的-helmchart-repository" class="headerlink" title="1，安装 harbor 的 helmchart repository"></a><strong>1，安装 harbor 的 helmchart repository</strong></h4><p>默认新版 harbor 不会启用 chart repository service，如果需要自建的harbor管理 helm应用的话，需要在安装时添加额外的参数，例如：启用 chart repository service 服务的安装方式要添加一个参数 –with-chartmuseum</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-55-9-tlinux ~/docker-compose/harbor]# ./install.sh --with-chartmuseum<br></code></pre></td></tr></table></figure><p>安装完成后，会有这个提示 说明是安装成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">⠿ Container chartmuseum              Started <br></code></pre></td></tr></table></figure><h4 id="2，发布-helm-charts"><a href="#2，发布-helm-charts" class="headerlink" title="2，发布 helm charts"></a>2，发布 helm charts</h4><p><strong>方式一、基于dashboard 的可视化上传</strong></p><p>用户使用浏览器登录 harbor镜像仓库后，在对应的管理界面操作即可，如下图：</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/1652931750847.png" alt="1652931750847"></p><p><strong>方式二、基于命令行的 CLI 推送</strong></p><p>作为一个运维人员或者开发人员，更喜欢通过命令行方式推送和拉取helm，如下操作</p><p>1、安装插件</p><p>为了能使用命令推送，我们需要安装并使用 helm push 插件包，地址： <a href="https://github.com/chartmuseum/helm-push/releases">https://github.com/chartmuseum/helm-push/releases</a></p><p>a) 在线安装插件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">helm plugin install https://github.com/chartmuseum/helm-pus<br></code></pre></td></tr></table></figure><p>b) 离线安装插件：</p><p>下载安装包 helm-push_0.10.1_linux_amd64.tar.gz，再使用命令 helm env 获取 HELM_PLUGINS 路径，然后放置和解压安装包，最后使用 helm plugin list 查看结果，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-55-9-tlinux ~/harbor]# helm env | grep HELM_PLUGINS<br>HELM_PLUGINS=&quot;/root/.local/share/helm/plugins<br>[root@VM-55-9-tlinux ~/harbor]# mkdir -p /root/.local/share/helm/plugins/helm-push<br>[root@VM-55-9-tlinux ~/harbor]# mv helm-push_0.10.1_linux_amd64.tar.gz /root/.local/share/helm/plugins/helm-push/<br>[root@VM-55-9-tlinux ~/harbor]# cd /root/.local/share/helm/plugins/helm-push/<br>[root@VM-55-9-tlinux helm-push]# tar -xzvf helm-push_0.10.1_linux_amd64.tar.gz <br>[root@VM-55-9-tlinux helm-push]# helm plugin list<br>NAME    VERSION DESCRIPTION                  <br>cm-push 0.10.1  Push chart package to ChartMuseum<br><br></code></pre></td></tr></table></figure><p>2、添加 harbor 仓库到本地 helm 仓库列表</p><p>查看本地仓库列表(列出的是我已经添加其他仓库)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-55-9-tlinux ~/helm]# helm repo list<br>NAME            URL                                           <br>tke-pass-helm   https://tke-pass.tencentcloudcr.com/chartrepo/helm<br><br># 添加仓库地址到本地列表(其中 myharbor-helm 为这个仓库地址在 helm 本地的名称，连接是仓库URL，后面是登录 harbor 的用户名和密码)<br># URL格式：http(s)://&#123;harbor域名或iP:端口(如果默认443或80可不加)&#125;/chartrepo/&#123;yourHarborProjectName&#125;<br><br>[root@VM-55-9-tlinux ~/helm]# helm repo add myharbor-helm http://101.35.6.116:88/chartrepo/charts --username admin  --password xxxxxx<br><br>#有如下提示表示添加成功<br>&quot;myharbor-helm&quot; has been added to your repositories<br><br># 再查看(发现已添加成功)<br>[root@VM-55-9-tlinux ~/helm]# helm repo list<br>NAME            URL                                           <br>tke-pass-helm   https://tke-pass.tencentcloudcr.com/chartrepo/helm<br>myharbor-helm   http://101.35.6.116:88/chartrepo/charts<br><br>##更新本地仓库缓存内容<br>[root@VM-55-9-tlinux ~/helm]# helm repo update<br>Hang tight while we grab the latest from your chart repositories...<br>...Successfully got an update from the &quot;myharbor-helm&quot; chart repository<br>...Successfully got an update from the &quot;tke-pass-helm&quot; chart repository<br>Update Complete. ⎈Happy Helming!⎈<br></code></pre></td></tr></table></figure><blockquote><p>温馨提示：</p><p>1，harbor 仓库 URL 中的 chartrepo 是固定值。</p><p>2，在操作之前，请务必先在 harbor 中创建好项目，例如 charts即为先创建好的项目名称。</p><p>3，如果你还是搞不清这个URL，可以在harbor界面中上传一个外面下着的 chart 包，上次成功后进入这个 chart 详细页面，在 “概要这个Tab” 的最底部区域，harbor会告诉你在本地添加仓库的URL和命令。</p></blockquote><p>3、推送 chart 以及 chart 的更多操作</p><p>推送 chart 示例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 推送chart文件夹方式<br>helm push mychartdemo myharbor-helm<br><br># 推送chart压缩包方式<br>helm push mychartdemo-1.0.1.tgz myharbor-helm<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Helm </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> Harbor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes容器资源限制和lxcfs问题</title>
      <link href="/post/e0d4c727.html"/>
      <url>/post/e0d4c727.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker容器资源限制问题"><a href="#Docker容器资源限制问题" class="headerlink" title="Docker容器资源限制问题"></a>Docker容器资源限制问题</h2><blockquote><p>以下是基于腾讯云TKE容器服务测试验证</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Linux利用CGroup实现了对容器资源的限制，但是在容器内部还是默认挂载宿主机 &#x2F;proc 目录下的资源信息文件，如：meminfo,cpuinfo,stat,uptiem，等。当进入Containers执行free，df，top等命令的时候，这时候默认读取的是 &#x2F;proc 目录内的资源信息文件内容，而这些资源信息文件使用的是宿主机的，所以我们看到的是宿主机的使用信息。</p><h3 id="关于LXCFS"><a href="#关于LXCFS" class="headerlink" title="关于LXCFS"></a>关于LXCFS</h3><p>LXCFS是一个开源的FUSE（用户态文件系统），用来支持LXC容器，也支持Docker容器，社区中常用此工具来实现容器中的资源可见性。</p><p><strong>LXCFS原理：</strong></p><p>以内存资源为列：通过将宿主机的 &#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;meminfo 文件挂载到容器内的&#x2F;proc&#x2F;meminfo，然后LXCFS会从容器的CGroup中读取正确的内存限制，然后应用到 &#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;meminfo ，这时候容器内部从而就得到了正确的内存信息。</p><blockquote><p>说明：&#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;meminfo 是服务启动的时候默认指定的目录。 </p></blockquote><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>目前腾讯云TKE里面想实现对容器资源的限制，在容器里面执行free，df，top等命令的时候看到容器真正的资源，有两种方案</p><h4 id="方案一：目前-TencentOS-Server-特性已支持容器资源展示隔离"><a href="#方案一：目前-TencentOS-Server-特性已支持容器资源展示隔离" class="headerlink" title="方案一：目前 TencentOS Server 特性已支持容器资源展示隔离"></a>方案一：<strong>目前 <a href="https://github.com/Tencent/TencentOS-kernel/wiki/container-resource-view-isolation">TencentOS Server</a> 特性已支持容器资源展示隔离</strong></h4><ul><li>增加主机级开关：内核已实现了类似 LXCFS 特性。用户无需在节点部署 LXCFS 文件系统及修改 POD spec，仅需在节点开启全局开关（<code>sysctl -w kernel.stats_isolated=1</code>），<code>/proc/cpuinfo</code> 及 <code>/proc/meminfo</code> 等文件获取即可按容器隔离 </li><li>增加容器级开关：针对类似节点监控组件等特殊容器，增加了容器级开关 kernel.container_stats_isolated。在主机级开关开启时，仅需在容器启动脚本中关闭容器级开关（sysctl -w kernel.container_stats_isolated&#x3D;0），即可在容器中读取 &#x2F;proc&#x2F;cpuinfo 及 &#x2F;proc&#x2F;meminfo 文件时获取到主机信息。</li></ul><p><strong>1，环境准备</strong></p><p>已创建集群并添加节点，使用操作系统tlinux 2.4，节点规格4C8G</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~/lxcfs]# uname -r<br>4.14.105-19-0020.1<br>[root@VM-0-17-tlinux ~/lxcfs]# sysctl  -a| grep kernel.stats_isolated<br>kernel.stats_isolated = 0<br><br>#默认是0<br></code></pre></td></tr></table></figure><p><strong>2，查看当前主机节点上资源情况</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~/lxcfs]# cat /proc/meminfo | grep MemTotal<br>MemTotal:        8035132 kB<br>[root@VM-0-17-tlinux ~/lxcfs]# cat /proc/cpuinfo  | grep processor | wc -l<br>4<br>[root@VM-0-17-tlinux ~/lxcfs]# free -m<br>              total        used        free      shared  buff/cache   available<br>Mem:           7846        2394        2571           2        2880        5299<br>Swap:             0           0           0<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041912729.png" alt="1627827269129"></p><p><strong>3，未修改前登录容器查看资源，看到的是宿主机的使用信息。</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~/lxcfs]# kubectl  exec -it centos-5ccb64bbdb-h7nb9  -- /bin/bash<br>[root@centos-5ccb64bbdb-h7nb9 /]# cat /proc/meminfo | grep MemTotal<br>MemTotal:        8035132 kB<br>[root@centos-5ccb64bbdb-h7nb9 /]# cat /proc/cpuinfo  | grep processor | wc -l<br>4<br>[root@centos-5ccb64bbdb-h7nb9 /]# free -m<br>              total        used        free      shared  buff/cache   available<br>Mem:           7846        2409        2555           2        2881        5285<br>Swap:             0           0           0<br></code></pre></td></tr></table></figure><p><strong>4， 开启全局开关  （<code>sysctl -w kernel.stats_isolated=1</code>）</strong> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~]# sysctl -w kernel.stats_isolated=1<br>kernel.stats_isolated = 1<br>[root@VM-0-17-tlinux ~]# sysctl  -p<br></code></pre></td></tr></table></figure><p><strong>5，进一步查看容器资源情况</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@centos-5ccb64bbdb-h7nb9 /]# cat /proc/meminfo | grep MemTotal<br>MemTotal:        1048576 kB<br>[root@centos-5ccb64bbdb-h7nb9 /]# cat /proc/cpuinfo  | grep processor | wc -l<br>1<br>[root@centos-5ccb64bbdb-h7nb9 /]# free -m<br>              total        used        free      shared  buff/cache   available<br>Mem:           1024           4        1014           0           4         934<br>Swap:          1024           0        1024<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041912725.png" alt="1627827658184"></p><p><strong>5，低内核版本不支持该参数</strong></p><blockquote><p>另外一个节点   操作系统是centos 内核版本是 3.10</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-2-46-centos ~]# sysctl -w kernel.stats_isolated=1<br>sysctl: cannot stat /proc/sys/kernel/stats_isolated: No such file or directory<br>[root@VM-2-46-centos ~]# uname -a<br>Linux VM-2-46-centos 3.10.0-1160.11.1.el7.x86_64 #1 SMP Fri Dec 18 16:34:56 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041913987.png" alt="1627828366685"></p><h4 id="方案二-使用LXCFS"><a href="#方案二-使用LXCFS" class="headerlink" title="方案二:使用LXCFS"></a>方案二:使用LXCFS</h4><blockquote><p><a href="https://github.com/denverdino/lxcfs-admission-webhook">lxcfs官方介绍</a></p></blockquote><p>在节点上安装LXCFS ， 通过将宿主机的 &#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;meminfo 文件挂载到容器内的&#x2F;proc&#x2F;meminfo，然后LXCFS会从容器的CGroup中读取正确的内存限制，然后应用到 &#x2F;var&#x2F;lib&#x2F;lxcfs&#x2F;meminfo ，这时候容器内部从而就得到了正确的内存信息 </p><p><strong>1，环境准备 （ node节点OS：centos 7.6 ）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#安装依赖<br>yum install -y fuse-libs<br>git  clone https://github.com/denverdino/lxcfs-admission-webhook.git<br>cd  lxcfs-admission-webhook<br></code></pre></td></tr></table></figure><p><strong>2，部署安装</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#部署lxcfs daemonset<br>kubectl  apply -f deployment/lxcfs-daemonset.yaml<br>#部署lxcfs admission webhook<br>#sh  deployment/install.sh  #删除的话使用sh  deployment/uninstall.sh <br>#执行kubectl get po ，确认所有pod都处于Running状态<br>[root@VM-2-46-centos lxcfs-admission-webhook]# kubectl  get pods  | grep lxcfs<br>lxcfs-4bjxh                                           1/1     Running   0          8m44s<br>lxcfs-56225                                           1/1     Running   0          8m44s<br>lxcfs-admission-webhook-deployment-58d6fdcf49-jmxd9   1/1     Running   0          8m3s<br>lxcfs-f2gt5                                           1/1     Running   0          8m44s<br>lxcfs-h6smp                                           1/1     Running   0          8m44s<br></code></pre></td></tr></table></figure><p><strong>3，验证效果，启动lxcfs</strong></p><p> 对于要使用 lxcfs 的namespace，使用如下命令启用lxcfs admission webhook的自动注入（以lxcf为例）： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kubectl label namespace lxcfs  lxcfs-admission-webhook=enabled<br>kubectl  get ns --show-labels<br>kubectl  get pods -n lxcfs<br><br>#部署POD到centos 7.6 节点上<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041913268.png" alt="1627830668749"></p><p>确认内存信息</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041913663.png" alt="1627830753483"></p><p>确认CPU信息</p><blockquote><p>如果pod设置了cpu limit，看到cpu数量为cpu limit值向上取整</p></blockquote><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041913204.png" alt="1627830843444"></p><p><strong>4，卸载清理lxcfs</strong></p><p> 清理 lxcfs-admission-webhook </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">deployment/uninstall.sh<br></code></pre></td></tr></table></figure><p> 清理 lxcfs </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kubectl delete -f deployment/lxcfs-daemonset.yaml<br></code></pre></td></tr></table></figure><p>lxcfs 支持容器镜像 Centos系统、Ubuntu系统、Debian系统，但是不支持容器镜像 Alpine系统。因为 Alpine 不是使用 Gnu libc，而是使用 musl libc</p><h4 id="附注：1-12-TKE集群版本集群验证"><a href="#附注：1-12-TKE集群版本集群验证" class="headerlink" title="附注：1.12 TKE集群版本集群验证"></a>附注：1.12 TKE集群版本集群验证</h4><blockquote><p>在一次处理客户问题时候，客户咨询1.12版本是否支持lxcfs ，所做以下验证，仅作为记录</p></blockquote><p><strong>1，环境准备</strong></p><ul><li><p>centos7.6.0_x64 </p></li><li><p>集群版本1.12</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-2-2-centos ~]# cat /etc/redhat-release <br>CentOS Linux release 7.6.1810 (Core) <br>[root@VM-2-2-centos ~]# kubectl  get nodes -o wide<br>NAME       STATUS   ROLES    AGE   VERSION          INTERNAL-IP   EXTERNAL-IP       OS-IMAGE                KERNEL-VERSION                CONTAINER-RUNTIME<br>10.1.2.2   Ready    &lt;none&gt;   18m   v1.12.4-tke.29   10.1.2.2      114.117.211.163   CentOS Linux 7 (Core)   3.10.0-1160.11.1.el7.x86_64   docker://19.3.9<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041913476.png" alt="1628694819462"></p><p><strong>2，查看当前主机资源情况</strong>**</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041913463.png" alt="1628694227083"></p><p><strong>3，未安装lxcfs之前部署POD</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">resources:<br>  limits:<br>    cpu: 800m<br>    memory: 1Gi<br>  requests:<br>    cpu: 200m<br>    memory: 256Mi<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041913087.png" alt="1628694282800"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041914606.png" alt="1628694413673"></p><p><strong>4，安装lxcfs组件 并查看是否成功</strong></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041914350.png" alt="1628694556172"></p><p><strong>45，测试，销毁刚才创建的工作负载</strong></p><p><strong>5，登录POD里面查看资源</strong></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041914545.png" alt="1628695298213"></p><p><strong>6 ，CPU 1:2  内存1:1</strong></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041914300.png" alt="1628695390761"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041914669.png" alt="1628695575243"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041914339.png" alt="1628695524786"></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041914326.png" alt="1628695619794"></p><p>参考链接：</p><ul><li><a href="https://github.com/denverdino/lxcfs-admission-webhook">https://github.com/denverdino/lxcfs-admission-webhook</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes部署主从架构Mysql集群</title>
      <link href="/post/24ba3d3c.html"/>
      <url>/post/24ba3d3c.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>随着kubernetes发展，越来越多的人开始使用kubernetes部署自己应用，它是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能，然而很多应用也使用到数据库，下面通过kubernetes上部署个主从架构的Mysql集群供应用使用</p></blockquote><h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>kubernetes集群（本次实验使用的是腾讯云TKE集群，版本1.18）</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>主要通过一下几个步骤完整的搭建一个MySQL集群</p><ol><li>搭建一个<code>主从复制</code>（Master-Slave）的MySQL集群</li><li>从节点可以进行水平扩展，扩容多个节点</li><li>所有的<code>写</code>操作只能在MySQL主节点上执行</li><li>读操作可以在MySQL主从节点上执行</li><li>从节点能自动同步主节点的数据</li></ol><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209041753863.png" alt="image-20211125204741527"></p><h3 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h3><p>1，创建mysql使用的Namespace（如果不创建可以使用默认命名空间，一般建议单独给数据创建个命名空间使用）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: v1<br>kind: Namespace<br>metadata:<br>  name: mysql<br>  labels:<br>    app: mysql<br></code></pre></td></tr></table></figure><p>2，创建数据库的配置文件configmap</p><p>使用ConfigMap为Master&#x2F;Slave节点分配不同的配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: v1<br>kind: ConfigMap<br>metadata:<br>  name: mysql<br>  namespace: mysql<br>  labels:<br>    app: mysql<br>data:<br>  master.cnf: |<br>    # Master主节点配置<br>    [mysqld]<br>    log-bin=mysqllog<br>    skip-name-resolve<br>  slave.cnf: |<br>    # Slave从节点配置<br>    [mysqld]<br>    super-read-only<br>    skip-name-resolve<br>    log-bin=mysql-bin<br>    replicate-ignore-db=mysql<br></code></pre></td></tr></table></figure><p>3，创建MySQL密码Secret</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: v1<br>kind: Secret<br>metadata:<br>  name: mysql-secret<br>  namespace: mysql<br>  labels:<br>    app: mysql<br>type: Opaque<br>data:<br>  password: MTIzNDU2   # echo -n &quot;123456&quot; | base64<br></code></pre></td></tr></table></figure><p>4，使用Service为MySQL提供读写分离</p><ul><li>用户所有写请求，必须以DNS记录的方式直接访问到Master节点，也就是mysql-0.mysql这条DNS记录。</li><li>用户所有读请求，必须访问自动分配的DNS记录可以被转发到任意一个Master或Slave节点上，也就是mysql-read这条DNS记录。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: v1<br>kind: Service<br>metadata:<br>  name: mysql<br>  namespace: mysql<br>  labels:<br>    app: mysql<br>spec:<br>  ports:<br>  - name: mysql<br>    port: 3306<br>  clusterIP: None<br>  selector:<br>    app: mysql<br>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: mysql-read<br>  namespace: mysql<br>  labels:<br>    app: mysql<br>spec:<br>  ports:<br>  - name: mysql<br>    port: 3306<br>  selector:<br>    app: mysql<br></code></pre></td></tr></table></figure><p>5，创建MySQL集群实例</p><p>使用StatefulSet搭建MySQL主从集群</p><p>整体的StatefulSet有两个Replicas，一个Master，一个Slave，然后使用<code>init-mysql</code>这个<code>initContainers</code>进行<code>配置文件的初始化</code>。接着使用<code>clone-mysql</code>这个<code>initContainers</code>进行<code>数据的传输</code>；同时使用<code>xtrabackup</code>这个**<code>sidecar</code>容器**进行<code>SQL初始化和数据传输功能</code>。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: StatefulSet<br>metadata:<br>  name: mysql<br>  namespace: mysql<br>  labels:<br>    app: mysql<br>spec:<br>  selector:<br>    matchLabels:<br>      app: mysql<br>  serviceName: mysql    #注意这个千万别少些<br>  replicas: 2<br>  template:<br>    metadata:<br>      labels:<br>        app: mysql<br>    spec:<br>      initContainers:<br>      - name: init-mysql<br>        image: mysql:5.7<br>        env:<br>        - name: MYSQL_ROOT_PASSWORD<br>          valueFrom:<br>            secretKeyRef:<br>              name: mysql-secret<br>              key: password<br>        command:<br>        - bash<br>        - &quot;-c&quot;<br>        - |<br>          set -ex<br>          # 从Pod的序号，生成server-id<br>          [[ $(hostname) =~ -([0-9]+)$ ]] || exit 1<br>          ordinal=$&#123;BASH_REMATCH[1]&#125;<br>          echo [mysqld] &gt; /mnt/conf.d/server-id.cnf<br>          # 由于server-id不能为0，因此给ID加100来避开它<br>          echo server-id=$((100 + $ordinal)) &gt;&gt; /mnt/conf.d/server-id.cnf<br>          # 如果Pod的序号为0，说明它是Master节点，从ConfigMap里把Master的配置文件拷贝到/mnt/conf.d目录下<br>          # 否则，拷贝ConfigMap里的Slave的配置文件<br>          if [[ $&#123;ordinal&#125; -eq 0 ]]; then<br>            cp /mnt/config-map/master.cnf /mnt/conf.d<br>          else<br>            cp /mnt/config-map/slave.cnf /mnt/conf.d<br>          fi<br>        volumeMounts:<br>        - name: conf<br>          mountPath: /mnt/conf.d<br>        - name: config-map<br>          mountPath: /mnt/config-map<br>      - name: clone-mysql<br>        image: gcr.tencentcloudcr.com/google-samples/xtrabackup:1.0   #使用腾讯镜像加速<br>        env:<br>        - name: MYSQL_ROOT_PASSWORD<br>          valueFrom:<br>            secretKeyRef:<br>              name: mysql-secret<br>              key: password<br>        command:<br>        - bash<br>        - &quot;-c&quot;<br>        - |<br>          set -ex<br>          # 拷贝操作只需要在第一次启动时进行，所以数据已经存在则跳过<br>          [[ -d /var/lib/mysql/mysql ]] &amp;&amp; exit 0<br>          # Master 节点（序号为 0）不需要这个操作<br>          [[ $(hostname) =~ -([0-9]+)$ ]] || exit 1<br>          ordinal=$&#123;BASH_REMATCH[1]&#125;<br>          [[ $ordinal == 0 ]] &amp;&amp; exit 0<br>          # 使用ncat指令，远程地从前一个节点拷贝数据到本地<br>          ncat --recv-only mysql-$(($ordinal-1)).mysql 3307 | xbstream -x -C /var/lib/mysql<br>          # 执行 --prepare，这样拷贝来的数据就可以用作恢复了<br>          xtrabackup --prepare --target-dir=/var/lib/mysql<br>        volumeMounts:<br>        - name: data<br>          mountPath: /var/lib/mysql<br>          subPath: mysql<br>        - name: conf<br>          mountPath: /etc/mysql/conf.d<br>      containers:<br>      - name: mysql<br>        image: mysql:5.7<br>        env:<br> #        - name: MYSQL_ALLOW_EMPTY_PASSWORD<br> #          value: &quot;1&quot;<br>        - name: MYSQL_ROOT_PASSWORD<br>          valueFrom:<br>            secretKeyRef:<br>              name: mysql-secret<br>              key: password<br>        ports:<br>        - name: mysql<br>          containerPort: 3306<br>        volumeMounts:<br>        - name: data<br>          mountPath: /var/lib/mysql<br>          subPath: mysql<br>        - name: conf<br>          mountPath: /etc/mysql/conf.d<br>        resources:<br>          requests:<br>            cpu: 500m<br>            memory: 1Gi<br>        livenessProbe:<br>          exec:<br>            command: [&quot;mysqladmin&quot;, &quot;ping&quot;, &quot;-uroot&quot;, &quot;-p$&#123;MYSQL_ROOT_PASSWORD&#125;&quot;]<br>          initialDelaySeconds: 30<br>          periodSeconds: 10<br>          timeoutSeconds: 5<br>        readinessProbe:<br>          exec:<br>            command: [&quot;mysqladmin&quot;, &quot;ping&quot;, &quot;-uroot&quot;, &quot;-p$&#123;MYSQL_ROOT_PASSWORD&#125;&quot;]<br>          initialDelaySeconds: 5<br>          periodSeconds: 2<br>          timeoutSeconds: 1<br>      - name: xtrabackup<br>        image: gcr.tencentcloudcr.com/google-samples/xtrabackup:1.0<br>        ports:<br>        - name: xtrabackup<br>          containerPort: 3307<br>        env:<br>        - name: MYSQL_ROOT_PASSWORD<br>          valueFrom:<br>            secretKeyRef:<br>              name: mysql-secret<br>              key: password<br>        command:<br>        - bash<br>        - &quot;-c&quot;<br>        - |<br>          set -ex<br>          cd /var/lib/mysql<br>          # 从备份信息文件里读取MASTER_LOG_FILE和MASTER_LOG_POS这2个字段的值，用来拼装集群初始化SQL<br>          if [[ -f xtrabackup_slave_info ]]; then<br>            # 如果xtrabackup_slave_info文件存在，说明这个备份数据来自于另一个Slave节点<br>            # 这种情况下，XtraBackup工具在备份的时候，就已经在这个文件里自动生成了“CHANGE MASTER TO”SQL语句<br>            # 所以，只需要把这个文件重命名为change_master_to.sql.in，后面直接使用即可<br>            mv xtrabackup_slave_info change_master_to.sql.in<br>            # 所以，也就用不着xtrabackup_binlog_info了<br>            rm -f xtrabackup_binlog_info<br>          elif [[ -f xtrabackup_binlog_info ]]; then<br>            # 如果只是存在xtrabackup_binlog_info文件，说明备份来自于Master节点，就需要解析这个备份信息文件，读取所需的两个字段的值<br>            [[ $(cat xtrabackup_binlog_info) =~ ^(.*?)[[:space:]]+(.*?)$ ]] || exit 1<br>            rm xtrabackup_binlog_info<br>            # 把两个字段的值拼装成SQL，写入change_master_to.sql.in文件<br>            echo &quot;CHANGE MASTER TO MASTER_LOG_FILE=&#x27;$&#123;BASH_REMATCH[1]&#125;&#x27;,\<br>                  MASTER_LOG_POS=$&#123;BASH_REMATCH[2]&#125;&quot; &gt; change_master_to.sql.in<br>          fi<br>          # 如果存在change_master_to.sql.in，就意味着需要做集群初始化工作<br>          if [[ -f change_master_to.sql.in ]]; then<br>            # 但一定要先等MySQL容器启动之后才能进行下一步连接MySQL的操作<br>            echo &quot;Waiting for mysqld to be ready（accepting connections）&quot;<br>            until mysql -h 127.0.0.1 -uroot -p$&#123;MYSQL_ROOT_PASSWORD&#125; -e &quot;SELECT 1&quot;; do sleep 1; done<br>            echo &quot;Initializing replication from clone position&quot;<br>            # 将文件change_master_to.sql.in改个名字<br>            # 防止这个Container重启的时候，因为又找到了change_master_to.sql.in，从而重复执行一遍初始化流程<br>            mv change_master_to.sql.in change_master_to.sql.orig<br>            # 使用change_master_to.sql.orig的内容，也就是前面拼装的SQL，组成一个完整的初始化和启动Slave的SQL语句<br>            mysql -h 127.0.0.1 -uroot -p$&#123;MYSQL_ROOT_PASSWORD&#125; &lt;&lt; EOF<br>          $(&lt; change_master_to.sql.orig),<br>            MASTER_HOST=&#x27;mysql-0.mysql.mysql&#x27;,<br>            MASTER_USER=&#x27;root&#x27;,<br>            MASTER_PASSWORD=&#x27;$&#123;MYSQL_ROOT_PASSWORD&#125;&#x27;,<br>            MASTER_CONNECT_RETRY=10;<br>          START SLAVE;<br>          EOF<br>          fi<br>          # 使用ncat监听3307端口。<br>          # 它的作用是，在收到传输请求的时候，直接执行xtrabackup --backup命令，备份MySQL的数据并发送给请求者<br>          exec ncat --listen --keep-open --send-only --max-conns=1 3307 -c \<br>            &quot;xtrabackup --backup --slave-info --stream=xbstream --host=127.0.0.1 --user=root --password=$&#123;MYSQL_ROOT_PASSWORD&#125;&quot;<br>        volumeMounts:<br>        - name: data<br>          mountPath: /var/lib/mysql<br>          subPath: mysql<br>        - name: conf<br>          mountPath: /etc/mysql/conf.d<br>      volumes:<br>      - name: conf<br>        emptyDir: &#123;&#125;<br>      - name: config-map<br>        configMap:<br>          name: mysql<br>  volumeClaimTemplates:<br>  - metadata:<br>      name: data<br>    spec:<br>      accessModes:<br>      - &quot;ReadWriteOnce&quot;<br>      storageClassName: cbs<br>      resources:<br>        requests:<br>          storage: 10Gi            #数据盘大小根据业务情况镜像修改，这个只做测试，只写了10Gi <br></code></pre></td></tr></table></figure><p>可以看到，StatefulSet启动成功后，会有两个Pod运行。接下来，我们可以尝试向这个MySQL集群发起请求，执行一些SQL操作来验证它是否正常。整个过程因为拉取mysql和一个<code>gcr.io/google-samples/xtrabackup:1.0</code>（使用腾讯云加速镜像地址gcr.tencentcloudcr.com）国外的镜像会很慢,但是在创建mysql-0拉取一次之后，后续创建mysql-1就相对很快了。</p><p>最后，容器检查pod的运行状态</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~]# kubectl  get all -n mysql  -o wide<br>NAME          READY   STATUS    RESTARTS   AGE    IP           NODE           NOMINATED NODE   READINESS GATES<br>pod/mysql-0   2/2     Running   0          108s   172.18.1.4   192.168.2.40   &lt;none&gt;           &lt;none&gt;<br>pod/mysql-1   2/2     Running   0          76s    172.18.1.5   192.168.2.40   &lt;none&gt;           &lt;none&gt;<br><br>NAME                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE     SELECTOR<br>service/mysql        ClusterIP   None             &lt;none&gt;        3306/TCP   2m24s   app=mysql<br>service/mysql-read   ClusterIP   172.18.253.108   &lt;none&gt;        3306/TCP   2m24s   app=mysql<br><br>NAME                     READY   AGE    CONTAINERS         IMAGES<br>statefulset.apps/mysql   2/2     108s   mysql,xtrabackup   mysql:5.7,gcr.tencentcloudcr.com/google-samples/xtrabackup:1.0<br></code></pre></td></tr></table></figure><h3 id="服务验证"><a href="#服务验证" class="headerlink" title="服务验证"></a>服务验证</h3><p>1，验证主从关系</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~]# kubectl -n mysql exec mysql-1 -c mysql -- bash -c &quot;mysql -uroot -p123456 -e &#x27;show slave status \G&#x27;&quot;<br>mysql: [Warning] Using a password on the command line interface can be insecure.<br>*************************** 1. row ***************************<br>               Slave_IO_State: Waiting for master to send event<br>                  Master_Host: mysql-0.mysql.mysql<br>                  Master_User: root<br>                  Master_Port: 3306<br>                Connect_Retry: 10<br>              Master_Log_File: mysqllog.000003<br>          Read_Master_Log_Pos: 154<br>               Relay_Log_File: mysql-1-relay-bin.000002<br>                Relay_Log_Pos: 319<br>        Relay_Master_Log_File: mysqllog.000003<br>             Slave_IO_Running: Yes<br>            Slave_SQL_Running: Yes<br>              Replicate_Do_DB: <br>          Replicate_Ignore_DB: mysql<br>           Replicate_Do_Table: <br>       Replicate_Ignore_Table: <br>      Replicate_Wild_Do_Table: <br>  Replicate_Wild_Ignore_Table: <br>                   Last_Errno: 0<br>                   Last_Error: <br>                 Skip_Counter: 0<br>          Exec_Master_Log_Pos: 154<br>              Relay_Log_Space: 528<br>              Until_Condition: None<br>               Until_Log_File: <br>                Until_Log_Pos: 0<br>           Master_SSL_Allowed: No<br>           Master_SSL_CA_File: <br>           Master_SSL_CA_Path: <br>              Master_SSL_Cert: <br>            Master_SSL_Cipher: <br>               Master_SSL_Key: <br>        Seconds_Behind_Master: 0<br>Master_SSL_Verify_Server_Cert: No<br>                Last_IO_Errno: 0<br>                Last_IO_Error: <br>               Last_SQL_Errno: 0<br>               Last_SQL_Error: <br>  Replicate_Ignore_Server_Ids: <br>             Master_Server_Id: 100<br>                  Master_UUID: f8d3bd9a-4df4-11ec-9930-52d15f478b07<br>             Master_Info_File: /var/lib/mysql/master.info<br>                    SQL_Delay: 0<br>          SQL_Remaining_Delay: NULL<br>      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates<br>           Master_Retry_Count: 86400<br>                  Master_Bind: <br>      Last_IO_Error_Timestamp: <br>     Last_SQL_Error_Timestamp: <br>               Master_SSL_Crl: <br>           Master_SSL_Crlpath: <br>           Retrieved_Gtid_Set: <br>            Executed_Gtid_Set: <br>                Auto_Position: 0<br>         Replicate_Rewrite_DB: <br>                 Channel_Name: <br>           Master_TLS_Version: <br></code></pre></td></tr></table></figure><p>2，接下来，我们通过Master容器创建数据库和表、插入数据库。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kubectl -n mysql exec mysql-0 -c mysql -- bash -c &quot;mysql -uroot -p123456 -e &#x27;create database test&#x27;&quot;<br>kubectl -n mysql exec mysql-0 -c mysql -- bash -c &quot;mysql -uroot -p123456 -e &#x27;use test;create table counter(c int);&#x27;&quot;<br>kubectl -n mysql exec mysql-0 -c mysql -- bash -c &quot;mysql -uroot -p123456 -e &#x27;use test;insert into counter values(123)&#x27;&quot;<br></code></pre></td></tr></table></figure><p>3，然后，我们观察Slave节点是否都同步到数据了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kubectl -n mysql exec mysql-1 -c mysql -- bash -c &quot;mysql -uroot -p123456 -e &#x27;use test;select * from counter&#x27;&quot;  <br></code></pre></td></tr></table></figure><p>执行返回结果是，当看到输出结果，主从同步正常了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~]# kubectl -n mysql exec mysql-1 -c mysql -- bash -c &quot;mysql -uroot -p123456 -e &#x27;use test;select * from counter&#x27;&quot; <br>c<br>123<br></code></pre></td></tr></table></figure><h3 id="扩展从节点"><a href="#扩展从节点" class="headerlink" title="扩展从节点"></a>扩展从节点</h3><p>在有了StatefulSet以后，你就可以像Deployment那样，非常方便地扩展这个MySQL集群，比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kubectl -n mysql scale statefulset mysql  --replicas=3<br>statefulset.apps/mysql scaled<br>[root@VM-0-17-tlinux ~]# kubectl  get pods -n mysql<br>NAME      READY   STATUS     RESTARTS   AGE<br>mysql-0   2/2     Running    0          10m<br>mysql-1   2/2     Running    0          10m<br>mysql-2   0/2     Init:1/2   0          24s<br></code></pre></td></tr></table></figure><p>这时候，一个新的mysql-2就创建出来了，我们继续验证新扩容的节点是否都同步到主节点的数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">kubectl -n mysql exec mysql-2 -c mysql -- bash -c &quot;mysql -uroot -p123456 -e &#x27;use test;select * from counter&#x27;&quot;  <br></code></pre></td></tr></table></figure><p>当看到输出结果，主从同步正常了。也就是说从StatefulSet为我们新创建的mysql-2上，同样可以读取到之前插入的记录。也就是说，我们的数据备份和恢复，都是有效的</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes部署nacos服务</title>
      <link href="/post/7af4624e.html"/>
      <url>/post/7af4624e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-部署-Nacos-集群"><a href="#Kubernetes-部署-Nacos-集群" class="headerlink" title="Kubernetes 部署 Nacos 集群"></a>Kubernetes 部署 Nacos 集群</h1><blockquote><p>官网文档：<a href="https://nacos.io/zh-cn/docs/use-nacos-with-kubernetes.html">https://nacos.io/zh-cn/docs/use-nacos-with-kubernetes.html</a></p></blockquote><p>本文是基于腾讯云TKE容器服务集群搭建</p><h2 id="部署数据库"><a href="#部署数据库" class="headerlink" title="部署数据库"></a>部署数据库</h2><p><strong>1，数据库是NFS做数据化存储</strong>（或者CBS都可以）</p><p>需要注意： 镜像要使用nacos提供的数据库nacos&#x2F;nacos-mysql:5.7，自带的数据库创建完成后相关库和数据都已经导入，其中NFS替换成自己NFS实例，自建或者云上CFS</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>  generation: 1<br>  labels:<br>    k8s-app: nacos-mysql<br>    qcloud-app: nacos-mysql<br>  name: nacos-mysql<br>  namespace: nacos<br>spec:<br>  replicas: 1<br>  selector:<br>    matchLabels:<br>      k8s-app: nacos-mysql<br>      qcloud-app: nacos-mysql<br>  template:<br>    metadata:<br>      labels:<br>        k8s-app: nacos-mysql<br>        qcloud-app: nacos-mysql<br>    spec:<br>      containers:<br>      - env:<br>        - name: MYSQL_ROOT_PASSWORD<br>          value: root<br>        - name: MYSQL_DATABASE<br>          value: nacos<br>        - name: MYSQL_USER<br>          value: nacos<br>        - name: MYSQL_PASSWORD<br>          value: nacos<br>        image: nacos/nacos-mysql:5.7<br>        imagePullPolicy: IfNotPresent<br>        name: mysql<br>        resources:<br>          limits:<br>            cpu: 500m<br>            memory: 1Gi<br>          requests:<br>            cpu: 250m<br>            memory: 256Mi<br>        securityContext:<br>          privileged: false<br>        volumeMounts:<br>        - mountPath: /var/lib/mysql<br>          name: mysql-data<br>      dnsPolicy: ClusterFirst<br>      imagePullSecrets:<br>      - name: qcloudregistrykey<br>      restartPolicy: Always<br>      volumes:<br>      - name: mysql-data<br>        nfs:<br>          path: /nacos<br>          server: 192.168.1.6<br><br>---<br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: nacos-mysql<br>  namespace: nacos<br>  labels:<br>    name: nacos-mysql<br>spec:<br>  ports:<br>  - port: 3306<br>    targetPort: 3306<br>  selector:<br>    k8s-app: nacos-mysql<br>    qcloud-app: nacos-mysql<br></code></pre></td></tr></table></figure><p>验证数据库可用性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-0-17-tlinux ~/nacos]# mysql -h172.18.250.54 -unacos -pnacos<br>MySQL [(none)]&gt; show databases;<br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| nacos              |<br>+--------------------+<br>2 rows in set (0.01 sec)<br><br>MySQL [(none)]&gt; use nacos<br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A<br><br>Database changed<br>MySQL [nacos]&gt; show tables;<br>+----------------------+<br>| Tables_in_nacos      |<br>+----------------------+<br>| config_info          |<br>| config_info_aggr     |<br>| config_info_beta     |<br>| config_info_tag      |<br>| config_tags_relation |<br>| group_capacity       |<br>| his_config_info      |<br>| permissions          |<br>| roles                |<br>| tenant_capacity      |<br>| tenant_info          |<br>| users                |<br>+----------------------+<br>12 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="部署nacos"><a href="#部署nacos" class="headerlink" title="部署nacos"></a>部署nacos</h2><p><strong>1，创建链接mysql的配置文件</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: v1<br>kind: ConfigMap<br>metadata:<br>  name: nacos-cm<br>  namespace: nacos<br>data:<br>  mysql.host: &quot;172.18.253.36&quot;  #如果是K8S集群内数据库，可以使用服务名称<br>  mysql.db.name: &quot;nacos&quot;      #上面创建数据库是指的的库名称<br>  mysql.port: &quot;3306&quot;           #端口<br>  mysql.user: &quot;nacos&quot;          #用户<br>  mysql.password: &quot;nacos&quot;      #用户密码<br></code></pre></td></tr></table></figure><p><strong>2，创建nacos-headless 用于集群之间的链接</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: v1<br>kind: Service<br>metadata:<br>  name: nacos-headless<br>  namespace: nacos<br>  labels:<br>    app: nacos<br>  annotations:<br>    service.alpha.kubernetes.io/tolerate-unready-endpoints: &quot;true&quot;<br>spec:<br>  ports:<br>    - port: 8848<br>      name: server<br>      targetPort: 8848<br>  clusterIP: None<br>  selector:<br>    app: nacos<br>    <br>   <br></code></pre></td></tr></table></figure><p><strong>3，部署nacos服务</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: apps/v1<br>kind: StatefulSet<br>metadata:<br>  name: nacos<br>  namespace: nacos<br>spec:<br>  serviceName: nacos-headless<br>  replicas: 3<br>  template:<br>    metadata:<br>      labels:<br>        app: nacos<br>      annotations:<br>        pod.alpha.kubernetes.io/initialized: &quot;true&quot;<br>    spec:<br>      affinity:<br>        podAntiAffinity:<br>          requiredDuringSchedulingIgnoredDuringExecution:<br>            - labelSelector:<br>                matchExpressions:<br>                  - key: &quot;app&quot;<br>                    operator: In<br>                    values:<br>                      - nacos<br>              topologyKey: &quot;kubernetes.io/hostname&quot;<br>      containers:<br>        - name: k8snacos<br>          imagePullPolicy: Always<br>          image: nacos/nacos-server:latest<br>          resources:<br>            requests:<br>              memory: &quot;2Gi&quot;<br>              cpu: &quot;500m&quot;<br>          ports:<br>            - containerPort: 8848<br>              name: client<br>          env:<br>            - name: NACOS_REPLICAS<br>              value: &quot;3&quot;<br>            - name: MYSQL_SERVICE_HOST<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: nacos-cm<br>                  key: mysql.host<br>            - name: MYSQL_SERVICE_DB_NAME<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: nacos-cm<br>                  key: mysql.db.name<br>            - name: MYSQL_SERVICE_PORT<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: nacos-cm<br>                  key: mysql.port<br>            - name: MYSQL_SERVICE_USER<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: nacos-cm<br>                  key: mysql.user<br>            - name: MYSQL_SERVICE_PASSWORD<br>              valueFrom:<br>                configMapKeyRef:<br>                  name: nacos-cm<br>                  key: mysql.password<br>            - name: MODE<br>              value: &quot;cluster&quot;<br>            - name: NACOS_SERVER_PORT<br>              value: &quot;8848&quot;<br>            - name: PREFER_HOST_MODE<br>              value: &quot;hostname&quot;<br>            - name: NACOS_SERVERS<br>              value: &quot;nacos-0.nacos-headless.nacos.svc.cluster.local:8848 nacos-1.nacos-headless.nacos.svc.cluster.local:8848 nacos-2.nacos-headless.nacos.svc.cluster.local:8848&quot;<br>  selector:<br>    matchLabels:<br>      app: nacos<br>      <br>      <br></code></pre></td></tr></table></figure><p><strong>4，创建公网类型CLB的service（可选）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: v1<br>kind: Service<br>metadata:<br>  annotations:<br>    service.kubernetes.io/service.extensiveParameters: &#x27;&#123;&quot;AddressIPVersion&quot;:&quot;IPV4&quot;,&quot;ZoneId&quot;:&quot;ap-chongqing-1&quot;&#125;&#x27;<br>  name: nacos<br>  namespace: nacos<br>spec:<br>  externalTrafficPolicy: Cluster<br>  ports:<br>  - name: 8848-8848-tcp<br>    port: 8848<br>    protocol: TCP<br>    targetPort: 8848<br>  selector:<br>    app: nacos<br>  sessionAffinity: None<br>  type: LoadBalancer<br><br></code></pre></td></tr></table></figure><p><strong>5，创建公网访问的ingress（可选）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">apiVersion: networking.k8s.io/v1beta1<br>kind: Ingress<br>metadata:<br>  annotations:<br>    ingress.cloud.tencent.com/direct-access: &quot;false&quot;<br>  name: nacos-ingress<br>  namespace: nacos<br>spec:<br>  rules:<br>  - host: nacos.dev.cc<br>    http:<br>      paths:<br>      - backend:<br>          serviceName: nacos<br>          servicePort: 8848<br>        path: /nacos<br></code></pre></td></tr></table></figure><h2 id="nacos使用"><a href="#nacos使用" class="headerlink" title="nacos使用"></a>nacos使用</h2><p><strong>1，使用service访问 或者ingress进行访问</strong></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/image-20220826004712494.png" alt="image-20220826004712494"></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes中pod数据存储</title>
      <link href="/post/76f3febd.html"/>
      <url>/post/76f3febd.html</url>
      
        <content type="html"><![CDATA[<h2 id="POD如何使用节点磁盘"><a href="#POD如何使用节点磁盘" class="headerlink" title="POD如何使用节点磁盘"></a>POD如何使用节点磁盘</h2><p>K8S中，容器container在运行过程中，会产生一些日志，临时文件，如果没有任何限制的话，会写满POD所在节点磁盘空间，从而会影响对应节点 已经节点上其他POD应用，</p><p> 容器的<strong>临时存储，例如 emptyDir</strong>，位于目录&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods 下 </p><blockquote><p>通过如下命令可以查询到集群POD所对应的POD_ID</p><p>kubectl get pods -o custom-columns&#x3D;podName:.metadata.name,podIP:.status.podIP,podStatus:.status.phase,nodeIP:.status.hostIP,Pod_ID:.metadata.uid</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-249-47-tlinux /var/lib/kubelet/pods]# kubectl get pods -o custom-columns=podName:.metadata.name,podIP:.status.podIP,podStatus:.status.phase,nodeIP:.status.hostIP,Pod_ID:.metadata.uid<br>podName                   podIP        podStatus   nodeIP          Pod_ID<br>centos-74cd685986-rcfqk   10.200.0.5   Running     172.30.249.47   9ad30306-f6cd-49eb-a279-cd58201be8c3<br><br>[root@VM-249-47-tlinux /var/lib/kubelet/pods]# <br>[root@VM-249-47-tlinux /var/lib/kubelet/pods]# tree  9ad30306-f6cd-49eb-a279-cd58201be8c3<br>9ad30306-f6cd-49eb-a279-cd58201be8c3   #pod的 uid<br>├── containers                         # pod 里面的container 容器<br>│   ├── busybox                        #容器1<br>│   │   └── 21efdec2<br>│   └── centos                         #容器2<br>│       └── 64bbf490<br>├── etc-hosts                          # 命名空间的Host文件<br>├── plugins<br>│   └── kubernetes.io~empty-dir<br>│       ├── wrapped_cm<br>│       │   └── ready<br>│       ├── wrapped_default-token-7llnd<br>│       │   └── ready<br>│       └── wrapped_secret<br>│           └── ready<br>└── volumes                                           # Pod的卷<br>    ├── kubernetes.io~configmap                       # ConfigMap类型的卷<br>    │   └── cm<br>    │       └── app -&gt; ..data/app<br>    ├── kubernetes.io~qcloud-cbs                      #CBS类型的数据卷<br>    │   └── pvc-137607ae-974d-4c25-90dc-efc3c2a6c5a8  #PV名称，对应POD里面挂载点<br>    │       └── lost+found<br>    └── kubernetes.io~secret                          #Secret类型的卷<br>        ├── default-token-7llnd<br>        │   ├── ca.crt -&gt; ..data/ca.crt<br>        │   ├── namespace -&gt; ..data/namespace<br>        │   └── token -&gt; ..data/token<br>        └── secret<br>            └── password -&gt; ..data/password<br><br>17 directories, 11 files<br></code></pre></td></tr></table></figure><p><strong>持久卷的挂载点</strong>也位于&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods 下，但是<strong>不会导致存储空间的消耗</strong>。</p><p>容器的日志，存放在&#x2F;var&#x2F;log&#x2F;pods 目录下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@VM-249-47-tlinux /var/log/pods]# ls -lrt  | grep centos<br>drwxr-xr-x 4 root root 4096 Aug  7 18:23 default_centos-74cd685986-rcfqk_9ad30306-f6cd-49eb-a279-cd58201be8c3<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209031845790.png" alt="1659868302215"></p><blockquote><p>目录命名方式是：命名空间_POD名称_POD-UID</p><p>9ad30306-f6cd-49eb-a279-cd58201be8c3 这个指的就是POD的uid</p></blockquote><p>日志是软链接到&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers&#x2F;容器ID&#x2F;容器ID-json.log</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209031846679.png" alt="1659868600279"></p><p> 使用 Docker 时，<strong>容器的 rootfs</strong>位于&#x2F;var&#x2F;lib&#x2F;docker 下，具体位置取决于存储驱动。 </p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux创建指定大小文件</title>
      <link href="/post/6757b0f7.html"/>
      <url>/post/6757b0f7.html</url>
      
        <content type="html"><![CDATA[<p>在使用Linux时候，经常使用用 touch 命令创建一个空文件。当我们排除故障或想在某些特定场景中进行测试时，我们可能需要特定大小的大文件，比如1024MB 或5GB大小的文件，下面介绍几种常用的方法</p><h3 id="使用-dd-命令创建大文件"><a href="#使用-dd-命令创建大文件" class="headerlink" title="使用 dd 命令创建大文件"></a>使用 dd 命令创建大文件</h3><p>dd 命令用于复制和转换文件</p><p>dd 命令是实际写入硬盘，文件产生的速度取决于硬盘的读写速度，根据文件的大小，该命令将需要一些时间才能完成。</p><p>假设我们要创建一个名为test.img 的 2 GB 大小的文本文件，可以执行以下操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=test1.txt bs=2G count=1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@chen tmp]<span class="hljs-comment"># dd if=/dev/zero of=text.img bs=2G count=1  #命令</span><br>0+1 records <span class="hljs-keyword">in</span><br>0+1 records out<br>2147479552 bytes (2.1 GB) copied, 94.4318 s, 22.7 MB/s<br>[root@cjweichen tmp]<span class="hljs-comment"># ls -lh text.img        #查看文件大小</span><br>-rw-r--r-- 1 root root 2.0G Dec  8 10:46 text.img<br></code></pre></td></tr></table></figure><p>我们可以根据需要来更改块大小和块数。例如，可以使用 bs&#x3D;1M 和 count&#x3D;1024 来获得 1024 Mb 的文件。</p><h3 id="使用-truncate-命令创建大文件"><a href="#使用-truncate-命令创建大文件" class="headerlink" title="使用 truncate 命令创建大文件"></a>使用 truncate 命令创建大文件</h3><p>truncate 命令将一个文件缩小或者扩展到所需大小。使用 -s 选项来指定文件的大小，执行速度会快些</p><p>我们使用 truncare 命令来创建一个 2GB 大小的文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">truncate</span> -s  2G test2.txt<br></code></pre></td></tr></table></figure><p>可以使用<code>ls -lh test2.txt </code>命令查看生成的文件。</p><p>默认情况下，如果请求的输出文件不存在，truncate 命令将创建新文件。我们可以使用 -c 选项来避免创建新文件。</p><h3 id="使用-fallocate-命令创建大文件"><a href="#使用-fallocate-命令创建大文件" class="headerlink" title="使用 fallocate 命令创建大文件"></a>使用 fallocate 命令创建大文件</h3><p>fallocate 命令创建大文件的方法，创建大文件的速度是三个中最快的。</p><p>假设我们要创建一个2 GB 的文件，可以执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">fallocate -l 2G  test3.txt <br></code></pre></td></tr></table></figure><p>可以使用<code>ls -lh test3.txt </code>查看生成的文件。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>dd 和 truncate 创建的文件是稀疏文件。在计算机世界中，稀疏文件是一种特殊文件，具有不同的表观文件大小（它们可以扩展到的最大大小）和真实文件大小（为磁盘上的数据分配了多少空间）。</p><p>fallocate 命令则不会创建稀疏文件，而且它的速度更快，这也是我比较推荐使用 fallocate 创建大文件的原因。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装NodeJS</title>
      <link href="/post/fe4ed47c.html"/>
      <url>/post/fe4ed47c.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linux安装NodeJS"><a href="#Linux安装NodeJS" class="headerlink" title="Linux安装NodeJS"></a>Linux安装NodeJS</h2><blockquote><p>Node.js  是一个基于Chrome V8 引擎 JavaScript 运行时环境， <a href="https://nodejs.org/zh-cn/download/">nodejs 官网</a></p></blockquote><h3 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h3><p><strong>1，可以在官网控制台下载上传至服务器</strong></p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/202209031802065.png" alt="image-20220409115051104"></p><p><strong>2，或者使用命令直接下载</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@xxx ~/nodejs]# wget https://nodejs.org/dist/v16.14.2/node-v16.14.2-linux-x64.tar.xz   // 下载<br>[root@xxx ~/nodejs]# tar xf  node-v16.14.2-linux-x64.tar.xz        // 解压<br>[root@xxx ~/nodejs]# cd nnode-v16.14.2-linux-x64/                  // 进入解压目录<br></code></pre></td></tr></table></figure><blockquote><p> <a href="https://nodejs.org/dist/">历史版本下载</a>  </p></blockquote><h3 id="使用RZ上传到服务器并解压"><a href="#使用RZ上传到服务器并解压" class="headerlink" title="使用RZ上传到服务器并解压"></a>使用RZ上传到服务器并解压</h3><blockquote><p>Linux的sz和rz命令，可使用yum命令安装：yum install -y lrzsz</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@xxx ~/nodejs]# pwd<br>/root/nodejs<br>[root@xxx ~/nodejs]# ls -lrt<br>total 21428<br>-rw-rw-rw- 1 root root 21941244 Apr  9 11:52 node-v16.14.2-linux-x64.tar.xz<br>[root@xxx ~/nodejs]# tar -xvf node-v16.14.2-linux-x64.tar.xz <br>[root@xxx ~/nodejs]# cd /usr/local/<br>[root@xxx /usr/local]# ls<br>bin  etc  games  include  lib  lib64  libexec  lost+found  qcloud  sa  sbin  share  src<br>[root@xxx /usr/local]# mv /root/nodejs/node-v16.14.2-linux-x64 .<br>[root@xxx /usr/local]# mv node-v16.14.2-linux-x64/ nodejs <br></code></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p><strong>方式一：环境变量</strong></p><p>　1）、加入环境变量，在 &#x2F;etc&#x2F;profile 文件末尾增加配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">vi /etc/profile<br>export PATH=$PATH:/usr/local/nodejs/bin<br></code></pre></td></tr></table></figure><p>　2）、执行命令使配置文件生效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">source /etc/profile<br></code></pre></td></tr></table></figure><p><strong>方式二：软链接方式</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">ln -s /usr/local/nodejs/bin/npm /usr/local/bin/<br>ln -s /usr/local/nodejs/bin/node /usr/local/bin/<br></code></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[root@xxx /usr/local]# node -v<br>v16.14.2<br>[root@xxx /usr/local]# npm -v<br>8.5.0<br></code></pre></td></tr></table></figure><h3 id="Npm-更换淘宝镜像"><a href="#Npm-更换淘宝镜像" class="headerlink" title="Npm 更换淘宝镜像"></a>Npm 更换淘宝镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm config set registry https://registry.npm.taobao.org<br>npm install<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Front-matter基本使用</title>
      <link href="/post/265fa930.html"/>
      <url>/post/265fa930.html</url>
      
        <content type="html"><![CDATA[<h2 id="Front-matter-说明"><a href="#Front-matter-说明" class="headerlink" title="Front-matter 说明"></a>Front-matter 说明</h2><p>Front-matter 是 markdown 文件最上方以 —  分隔的区域，用于指定个别文件的变量。</p><ul><li>Page Front-matter  用于页面配置</li><li>Post Front-matter  用于文章页配置</li></ul><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_posts</code></td></tr><tr><td><code>page</code></td><td><code>source</code></td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td></tr></tbody></table><blockquote><p>如果你不想你的文章被处理，你可以将 Front-Matter 中的<code>layout:</code> 设为 <code>false</code> 。</p></blockquote><h2 id="Butterfly-Front-matter"><a href="#Butterfly-Front-matter" class="headerlink" title="Butterfly  Front-matter"></a>Butterfly  Front-matter</h2><h3 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">---<br>title:<br>date:<br>updated:<br>tags:<br>categories:<br>keywords:<br>description:<br>top_img:<br>comments:<br>cover:<br>toc:<br>toc_number:<br>toc_style_simple:<br>copyright:<br>copyright_author:<br>copyright_author_href:<br>copyright_url:<br>copyright_info:<br>mathjax:<br>katex:<br>aplayer:<br>highlight_shrink:<br>aside:<br>---<br></code></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标籤</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认 true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>toc_style_simple</td><td>【可选】显示 toc 简洁模式</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>copyright_author</td><td>【可选】文章版权模块的文章作者</td></tr><tr><td>copyright_author_href</td><td>【可选】文章版权模块的文章作者链接</td></tr><tr><td>copyright_url</td><td>【可选】文章版权模块的文章连结链接</td></tr><tr><td>copyright_info</td><td>【可选】文章版权模块的版权声明文字</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page:  false时，才需要配置，默认 false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr></tbody></table><h3 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">---<br>title:<br>date:<br>updated:<br>type:<br>comments:<br>description:<br>keywords:<br>top_img:<br>mathjax:<br>katex:<br>aside:<br>aplayer:<br>highlight_shrink:<br>#############################################<br>---<br><br></code></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面标题</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标籤、分类和友情链接三个页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】页面描述</td></tr><tr><td>keywords</td><td>【可选】页面关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块(默认 true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏 (默认 true)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-butterfly主题</title>
      <link href="/post/e56702c9.html"/>
      <url>/post/e56702c9.html</url>
      
        <content type="html"><![CDATA[<p><strong>写在前言</strong></p><blockquote><p>本文主要记录下Hexo使用butterfly主题优化的一些操作，便于后续可寻可查，首先感谢butterfly主题官方提供者</p></blockquote><h2 id="butterfly主题"><a href="#butterfly主题" class="headerlink" title="butterfly主题"></a>butterfly主题</h2><blockquote><p><a href="https://github.com/jerryc127/hexo-theme-butterfly">hexo-theme-melody官方介绍 </a></p><p>If you are in Mainland China, you can download in <a href="https://gitee.com/immyw/hexo-theme-butterfly.git">Gitee</a></p></blockquote><h3 id="下载安装主题"><a href="#下载安装主题" class="headerlink" title="下载安装主题"></a>下载安装主题</h3><p>1，在你的 <strong>Hexo 根目</strong>使用git可以直接下载</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly<br></code></pre></td></tr></table></figure><p>或者NPM安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm i hexo-theme-butterfly<br></code></pre></td></tr></table></figure><p>2，在hexo工作文件夹的根配置文件_config.yml中设置主题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Extensions<br>## Plugins: https://hexo.io/plugins/<br>## Themes: https://hexo.io/themes/<br>theme: butterfly<br></code></pre></td></tr></table></figure><p>3，执行如下命令测试看是否安装成功（需要在hexo主题根目录执行）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo clean<br>hexo d<br>hexo server<br></code></pre></td></tr></table></figure><h3 id="主题页面设置"><a href="#主题页面设置" class="headerlink" title="主题页面设置"></a>主题页面设置</h3><h4 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h4><ol><li>前往你的 Hexo 博客的根目录</li><li>输入 hexo new page tags</li><li>你会找到source&#x2F;tags&#x2F;index.md这个文件</li><li>修改这个文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo new page tags<br></code></pre></td></tr></table></figure><p>​5. 添加添加 type: “tags”</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">---<br>title: 标签<br>date: 2022-08-23 00:17:54<br>type: &quot;tags&quot;<br>---<br></code></pre></td></tr></table></figure><h4 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h4><ol><li><p>前往你的 Hexo 博客的根目录</p></li><li><p>输入hexo new page categories</p></li><li><p>你会找到source&#x2F;categories&#x2F;index.md这個文件</p></li><li><p>修改这个文件：</p></li><li><p>记得添加 type: “categories”</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#hexo new page categories<br>---<br>title: 分类<br>date: 2022-08-23 00:20:08<br>type: &quot;categories&quot;<br>---<br></code></pre></td></tr></table></figure><h4 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h4><ol><li><p>前往你的 Hexo 博客的根目錄</p></li><li><p>输入 hexo new page link</p></li><li><p>你会找到source&#x2F;link&#x2F;index.md這個文件</p></li><li><p>修改这个文件：</p></li><li><p>記得添加 type: “link”</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#hexo new page link<br>---<br>title: 友情链接<br>date: 2022-08-23 00:23:12<br>type: &quot;link&quot;<br>---<br></code></pre></td></tr></table></figure><p>   6，友情链接添加</p><p>在Hexo博客目录中的source&#x2F;_data（如果沒有 _data 文件夾，请自行创建），创建一个文件link.yml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">- class_name: 友情链接<br>  class_desc: 记录生活，学习点滴<br>  link_list:<br>    - name: Hexo<br>      link: https://hexo.io/zh-tw/<br>      avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg<br>      descr: 快速、简单且强调的博客框架<br><br>- class_name: 网站<br>  class_desc: 值得推荐的网站<br>  link_list:<br>    - name: Youtube<br>      link: https://www.youtube.com/<br>      avatar: https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png<br>      descr: 视频网站<br>    - name: Weibo<br>      link: https://www.weibo.com/<br>      avatar: https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png<br>      descr: 中国最大社交分享平台<br>    - name: Twitter<br>      link: https://twitter.com/<br>      avatar: https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png<br>      descr: 社交分享平台<br></code></pre></td></tr></table></figure><p>class_name 和 class_desc 支持 html 格式，如不需要，也可以留空。</p><h4 id="相册"><a href="#相册" class="headerlink" title="相册"></a>相册</h4><p>图库页面是一个普通的页面挂在图片信息概念，具体构建如下所示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#hexo new page photos<br># 在source/photos/index.md文件中：使用标签外挂galleryGroup<br><br>&lt;div class=&quot;gallery-group-main&quot;&gt;<br>&#123;% galleryGroup &#x27;壁纸&#x27; &#x27;收藏的一些壁紙&#x27; &#x27;/photos/wallpaper&#x27; https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/3.jpg %&#125;<br>&#123;% galleryGroup &#x27;动漫&#x27; &#x27;关于动漫的图片&#x27; &#x27;/photos/comic&#x27;    https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/timg3.jpg %&#125;<br>&lt;/div&gt;<br><br></code></pre></td></tr></table></figure><h5 id="子页面"><a href="#子页面" class="headerlink" title="子页面"></a>子页面</h5><p>子也面也是普通的也面，你只需要hexo new  page xxxxx 创建你的也面就行</p><p>然后使用标签外挂 gallery，具体用法请查看对应的內容。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 创建子页面<br>hexo new page daily<br><br># 在指定source/daily/index.md文件中外挂gallery<br>&#123;% gallery %&#125;<br>![](https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/timg.jpg)<br>![](https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/image-20220826125722620.png)<br>&#123;% endgallery %&#125;<br></code></pre></td></tr></table></figure><h4 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h4><p>主題內置了一個简单的404页面，可在設置中开启</p><p>在主题_config.yml配置文件，查看404配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># A simple 404 page<br>error_404:<br>  enable: true<br>  subtitle: &#x27;Page Not Found&#x27;<br>  background: https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/image-20220823004052578.png<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/image-20220823004052578.png" alt="image-20220823004052578"></p><h4 id="其他页面"><a href="#其他页面" class="headerlink" title="其他页面"></a>其他页面</h4><p>同理，使用相同的方式创建，我这边创建有如下页面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo new page   archives  #归档<br>hexo new page   messageboard #留言板<br>hexo new page   music     #音乐<br>hexo new page   movies    #电影<br>hexo new page   game      #游戏<br>hexo new page   book      #书籍<br>hexo new page   about     #关于我<br></code></pre></td></tr></table></figure><h3 id="站点主题设置"><a href="#站点主题设置" class="headerlink" title="站点主题设置"></a>站点主题设置</h3><h4 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h4><p>修改站点<strong>Hexo根目录</strong>配置文件 _config.yml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">默认是 en<br><br>主題支持三种语音<br><br>default(en)<br>zh-CN (简体中文)<br>zh-TW (繁体中文)<br></code></pre></td></tr></table></figure><h4 id="网站资料"><a href="#网站资料" class="headerlink" title="网站资料"></a>网站资料</h4><p>修改站点各种资料，例如标题、副标题和邮箱等个人资料，请修改博客<strong>根目录</strong>的_config.yml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Site<br>title: &#x27;JingWei Chen&#x27;<br>subtitle: &#x27;&#x27;<br>description: &#x27;抬头，微笑，你好&#x27;<br>keywords: kubernetes<br>author: JingWei Chen<br>language: zh-CN<br>timezone: &#x27;Asia/Shanghai&#x27;<br></code></pre></td></tr></table></figure><h4 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h4><p>修改主题的配置文件位于themes&#x2F;butterfly&#x2F;_config.yaml</p><blockquote><p>前面列 文字可自行更改，默认是英文的，用户可以根据需求修改成中文 ，示例如下</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">menu:<br>   首页: / || fas fa-home<br>   归档: /archives/ || fas fa-archive<br>   标签: /tags/ || fas fa-tags<br>   分类: /categories/ || fas fa-folder-open<br>   留言板: /messageboard/ || fa fa-paper-plane<br>   友链: /link/ || fas fa-link<br>   娱乐 || fas fa-list||hide:<br>     音乐: /music/  || fas fa-music<br>     电影: /movies/ || fas fa-video<br>     游戏: /game/   || fas fa-gamepad<br>     相册: /photos/ || fa fa-camera-retro<br>     电子书: /book/ ||  fa fa-book<br>   关于我: /about/ || fas fa-heart<br></code></pre></td></tr></table></figure><p>必须是 &#x2F;xxx&#x2F;，后面||分开，然后写图标名，如果不希望显示图标，图标名可不写。</p><p>默认子目录是展开，如果你想要隐藏，在子目录里面添加 hide 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">List||fas fa-list||hide:<br>  Music: /music/ || fas fa-music<br>  Movie: /movies/ || fas fa-video<br></code></pre></td></tr></table></figure><h4 id="副主题设置"><a href="#副主题设置" class="headerlink" title="副主题设置"></a>副主题设置</h4><p>如果没设置副标题，上面的<code>description：</code>签名，就是显示在主页面。而设置的话，<code>签名</code>自动不显示，<code>副标题</code>出现。</p><p>修改 主題配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># the subtitle on homepage (主页subtitle)<br>subtitle:<br>  enable: true<br>  # Typewriter Effect (打字效果)<br>  effect: true<br>  # Effect Speed Options (打字效果速度參數)<br>  startDelay: 200 # time before typing starts in milliseconds<br>  typeSpeed: 100 # type speed in milliseconds<br>  backSpeed: 100 # backspacing speed in milliseconds<br>  # loop (循环字)<br>  loop: true<br>  # source 調用第三方服務<br>  # source: false 關閉調用<br>  # source: 1  調用一言網的一句話（簡體） https://hitokoto.cn/<br>  # source: 2  調用一句網（簡體） http://yijuzhan.com/<br>  # source: 3  調用今日詩詞（簡體） https://www.jinrishici.com/<br>  # subtitle 會先顯示 source , 再顯示 sub 的內容<br>  source: false<br>  # 如果打开打字效果，subtitle 只會顯示 sub 的第一行文字<br>  sub:<br>    - As long as willing to learn, it will be able to learn.<br>    - 只要愿意学习，就一定能够学会<br>    - Take learning as a kind of living habits.<br>    - 把学习当成一种生活习惯<br></code></pre></td></tr></table></figure><h5 id="副标题字体大小颜色"><a href="#副标题字体大小颜色" class="headerlink" title="副标题字体大小颜色"></a>副标题字体大小颜色</h5><p>在<code>\themes\butterfly\source\css\_layout</code>中的<code>head.styl</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#site-subtitle<br>    color: var(--white)   #此处修改为白色<br>    font-size: 1.05em     #字体大小<br><br>    +minWidth768()<br>      font-size: 1.55em   #字体大小<br></code></pre></td></tr></table></figure><h4 id="图片设置"><a href="#图片设置" class="headerlink" title="图片设置"></a>图片设置</h4><p>图片可以使用<code>网上的图片</code>(即使用该<code>图片链接</code>)，也可以使用<code>\themes\butterfly\source\img</code>下的图片。</p><h5 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Favicon（网站图标）<br>favicon: /img/favicon.png<br></code></pre></td></tr></table></figure><h5 id="个人资料头像"><a href="#个人资料头像" class="headerlink" title="个人资料头像"></a>个人资料头像</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Avatar (头像)<br>avatar:<br>  img: /img/avatar.png<br>  effect: false<br></code></pre></td></tr></table></figure><h5 id="首页面图片"><a href="#首页面图片" class="headerlink" title="首页面图片"></a>首页面图片</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># The banner image of home page (首页的横幅图像)<br>index_img: /img/index_img.jpg<br></code></pre></td></tr></table></figure><h5 id="子标签页图片"><a href="#子标签页图片" class="headerlink" title="子标签页图片"></a>子标签页图片</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># The banner image of archive page<br>archive_img: /img/tag.jpg<br></code></pre></td></tr></table></figure><ol><li>主页的顶部图可以在<code>_config.yml</code>设置<code>index_img</code></li><li>&#96;&#96;archives<code>页的顶部图可以在</code>_config.yml<code>设置</code>archive_img&#96;</li><li>其他<code>page页</code>的顶部图可以在各自的md页面设置<code>front-matter</code>中的<code>top_img</code></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">favicon: /img/favicon.png<br>avatar:<br>  img: /img/tit.png<br>  effect: false<br>index_img: /img/index_img.jpg<br>default_top_img: /img/tag.jpg #这个推荐：不加入可能部分标签页不出现图片<br>archive_img: /img/tag.jpg<br>tag_img: /img/tag.jpg<br>category_img: /img/tag.jpg<br></code></pre></td></tr></table></figure><h5 id="文章列表图片"><a href="#文章列表图片" class="headerlink" title="文章列表图片"></a>文章列表图片</h5><p>修改 主題配置文件 &#x2F;themes&#x2F;butterfly&#x2F;_config.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cover:<br>  # display the cover or not (是否显示文章封面)<br>  index_enable: true<br>  aside_enable: true<br>  archives_enable: true<br>  # the position of cover in home page (封面显示的位置)<br>  # left/right/both<br>  position: both<br>  default_cover:<br>  <br>文章封面设置：<br>一个:<br> default_cover: https://xxxx.jpg<br>多个:<br>此时会随机选择一张<br>  default_cover:<br>     - https://i.loli.net/2020/05/01/xxxxxx.jpg<br>or文章内<br></code></pre></td></tr></table></figure><h5 id="图片查看大图"><a href="#图片查看大图" class="headerlink" title="图片查看大图"></a>图片查看大图</h5><p>修改 主題配置文件 &#x2F;themes&#x2F;butterfly&#x2F;_config.yaml</p><p>这是两种<code>方式</code>，<code>只能选择一个</code> 或者 <code>两个都不选</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># medium-zoom<br># https://github.com/francoischalifour/medium-zoom<br>medium_zoom: false<br><br># fancybox<br># http://fancyapps.com/fancybox/3/<br>fancybox: true<br></code></pre></td></tr></table></figure><h5 id="图片慢加载"><a href="#图片慢加载" class="headerlink" title="图片慢加载"></a>图片慢加载</h5><p>1.新增<code>hexo-lazyload-image</code>模块</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install hexo-lazyload-image --save<br></code></pre></td></tr></table></figure><p>2.在主目录配置文件<code>_config.yml</code>增加配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">lazyload:<br>  enable: true<br>  loadingImg: /img/loading.gif<br></code></pre></td></tr></table></figure><p>这个就是图片没加载出来的时候，出现一个动图转转转。</p><h5 id="图片描述"><a href="#图片描述" class="headerlink" title="图片描述"></a>图片描述</h5><p>可开启图片Figcaption描述文字显示</p><p>优先显示的 title 属性，然後是 alt 属性</p><p>修改 主题配置文件 ，默认false，这里保持默认不修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">photofigcaption: false<br></code></pre></td></tr></table></figure><h4 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h4><h5 id="1，代码高亮主题"><a href="#1，代码高亮主题" class="headerlink" title="1，代码高亮主题"></a>1，代码高亮主题</h5><blockquote><p>Butterfly 支持6种代码高亮样式，修改主題配置文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">darker<br>pale night<br>light<br>ocean<br>mac<br>mac light<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">highlight_theme: light<br></code></pre></td></tr></table></figure><h5 id="2，代码复制"><a href="#2，代码复制" class="headerlink" title="2，代码复制"></a>2，代码复制</h5><blockquote><p>主題支持代码复制功能，修改主题配置文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">highlight_copy: true<br></code></pre></td></tr></table></figure><h5 id="3，-代码展开和折叠"><a href="#3，-代码展开和折叠" class="headerlink" title="3， 代码展开和折叠"></a>3， 代码展开和折叠</h5><blockquote><p>在默认情況下，代码框自动展开，可设置是否所有代码框都关闭专题，点开&gt;可展开代码，修改 主題配置文件</p></blockquote><ul><li>true 全部代码框不展开，需点击&gt;打开</li><li>false 代码框展开，有&gt;点击按鈕</li><li>none 不显示&gt;按鈕</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">highlight_shrink: true #代码框不展开，需点击&gt;打开<br></code></pre></td></tr></table></figure><blockquote><p>你也可以在post&#x2F;page也对应的markdown文件front-matter添加highlight_shrink来独立配置。</p><p>当主题配置文件中的 highlight_shrink 设为true时，可在front-matter添加highlight_shrink: false来单独配置文章展开代码框。</p><p>当主题配置文件中的 highlight_shrink 设为false时，可在front-matter添加highlight_shrink: true来单独配置文章收縮代码框。</p></blockquote><h5 id="4，代码换行"><a href="#4，代码换行" class="headerlink" title="4，代码换行"></a>4，代码换行</h5><p>在默认情況下，Hexo 在编译的時候不会实现代码自动換行。如果你不希望在代码块的区域里有橫向滾动條的話，那麼你可以考慮开启這個功能。</p><p>修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">code_word_wrap: true   #我这边设置的是false<br></code></pre></td></tr></table></figure><p>如果你是使用 highlight 渲染，需要找到你站点的 Hexo 配置博客<strong>根目录</strong>文件_config.yml，將line_number改成false:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">highlight:<br>  enable: true<br>  line_number: false # &lt;- 改这里<br>  auto_detect: false<br>  tab_replace:<br></code></pre></td></tr></table></figure><p>如果你是使用 prismjs 渲染，需要找到你站点的 Hexo博客<strong>根目录</strong> 配置文件_config.yml，將line_number改成false:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">prismjs:<br>  enable: false<br>  preprocess: true<br>  line_number: false # &lt;- 改这里<br>  tab_replace: &#x27;&#x27;<br></code></pre></td></tr></table></figure><h5 id="5，代码高度设置"><a href="#5，代码高度设置" class="headerlink" title="5，代码高度设置"></a>5，代码高度设置</h5><blockquote><p>3.7.0 及以上支持</p><p>注意：單位是 px，直接添加數字，如 200</p><p>实际限制高度为 highlight_height_limit + 30 px 多增加 30px 限制，目的是避免代码高度只超出highlight_height_limit 一点時，出現展开按鈕，展开沒內容。</p><p>不適用于隐藏後的代码块（ css 設置 display: none）</p></blockquote><p>可配置代码高度限制，超出的部分会隐藏，並显示展开按鈕。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">highlight_height_limit: false # unit: px<br></code></pre></td></tr></table></figure><h4 id="社交信息设置"><a href="#社交信息设置" class="headerlink" title="社交信息设置"></a>社交信息设置</h4><p>Butterfly支持 font-awesome v6图标.</p><p>书写格式 图标名：url || 描述性文字(可以选择使用<code>fa fa-xxx</code>图标，也可以选择使用<code>阿里iconfont</code>图)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># social settings (社交图标设置)<br># formal:<br>#   icon: link || the description<br>social:<br>   fab fa-github: https://github.com/chen1900s || Github<br>   fas fa-envelope: chen1900s@163.com || Email<br>   fab fa-qq:  tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=728831102&amp;website=www.oicqzone.com || QQ<br>   <br></code></pre></td></tr></table></figure><h4 id="主页文章节选"><a href="#主页文章节选" class="headerlink" title="主页文章节选"></a>主页文章节选</h4><p>因为主题UI的关系，主页文章節選只支持自动節選和文章页description。</p><p>在butterfly里，有四種可供選擇</p><ol><li><p>description： 只显示description</p></li><li><p>both： 優先選擇description，如果沒有配置description，則显示自动節選的內容</p></li><li><p>auto_excerpt：只显示自动節選</p></li><li><p>false： 不显示文章內容</p></li></ol><p>修改主题配置文件&#x2F;themes&#x2F;butterfly&#x2F;_config.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">index_post_content:<br>  method: 2<br>  length: 500 # if you set method to 2 or 3, the length need to config<br></code></pre></td></tr></table></figure><h4 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h4><blockquote><p>如果不要显示顶部图，可直接配置 disable_top_img:  true<br>其它页面 （tags&#x2F;categories&#x2F;自建页面）和 文章页 的 top_img ，請到對應的 md 页面設置front-matter中的top_img<br>以上所有的 top_img 可配置以下值</p></blockquote><table><thead><tr><th>配置</th><th>解释</th></tr></thead><tbody><tr><td>index_img</td><td>主页的 top_img</td></tr><tr><td>default_top_img</td><td>默认的 top_img，当主页的 top_img  沒有配置时，会显示default_top_img</td></tr><tr><td>archive_img</td><td>归档页面的 top_img</td></tr><tr><td>tag_img</td><td>tag    标签页面的 默认 top_img</td></tr><tr><td>tag_per_img</td><td>tag  子页面的 top_img，可配置每個 tag 的  top_img</td></tr><tr><td>category_img</td><td>category子页面 的 默认 top_img</td></tr><tr><td>category_per_img</td><td>category 子页面的 top_img，可配置每個 category 的 top_img</td></tr></tbody></table><h4 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">【推荐】hexo-generator-index从 2.0.0 开始，已經支持文章置頂功能。你可以直接在文章的front-matter区域里添加sticky: 1属性来把這篇文章置頂。數值越大，置頂的優先級越大。<br></code></pre></td></tr></table></figure><h4 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h4><p>文章的markdown文档上，在Front-matter添加cover，并填上要显示的图片地址。如果不配置cover，可以設置显示默认的cover，如果不想在首页头示cover,可以设置为false，</p><p>修改 主題配置文件&#x2F;themes&#x2F;butterfly&#x2F;_config.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cover:<br>  # 是否显示文章封面<br>  index_enable: true<br>  aside_enable: true<br>  archives_enable: true<br>  # 封面显示的位置<br>  # 三个值可配置 left , right , both<br>  position: both<br>  # 当沒有设置cover時，默认的封面显示<br>  default_cover: <br></code></pre></td></tr></table></figure><p>当配置多张图片时候  会随机选择一张作为cover.，此时的写法为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">default_cover:<br>  - https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png<br>  - https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png<br>  - https://fastly.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png<br></code></pre></td></tr></table></figure><h4 id="文章页相关配置"><a href="#文章页相关配置" class="headerlink" title="文章页相关配置"></a>文章页相关配置</h4><h5 id="生成文章唯一链接"><a href="#生成文章唯一链接" class="headerlink" title="生成文章唯一链接"></a>生成文章唯一链接</h5><p>Hexo的默认文章链接格式是年，月，日，标题这种格式来生成的。如果你的标题是中文的话，那你的URL链接就会包含中文。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">permalink: :year/:month/:day/:title<br></code></pre></td></tr></table></figure><p>前往你的Hexo博客根目录，打开cmd命令窗口执行npm install hexo-abbrlink –save</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install hexo-abbrlink --save<br></code></pre></td></tr></table></figure><p>修改站点配置文件_config.yml中permalink属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">permalink: :year/:month/:day/:title/<br>#修改为<br>permalink: post/:abbrlink.html # post为自定义前缀<br>abbrlink:<br>  alg: crc32   #算法： crc16(default) and crc32<br>  rep: hex     #进制： dec(default) and hex<br></code></pre></td></tr></table></figure><h5 id="文章meta显示"><a href="#文章meta显示" class="headerlink" title="文章meta显示"></a>文章meta显示</h5><p>这个选项是用来显示文章的相关信息的。</p><p>修改 主题配置文件&#x2F;themes&#x2F;butterfly&#x2F;_config.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">post_meta:<br>  page:<br>    date_type: both          # created or updated or both 主页文章日期是創建日或者更新日或都显示<br>    date_format: relative    # date/relative 显示日期還是相對日期<br>    categories: true         # true or false 主页是否显示分类<br>    tags: true               # true or false 主页是否显示標籤<br>    label: true              # true or false 显示描述性文字<br>  post:<br>    date_type: both           # created or updated or both 文章页日期是創建日或者更新日或都显示<br>    date_format: relative     # date/relative 显示日期還是相對日期<br>    categories: true          # true or false 文章页是否显示分類<br>    tags: true                # true or false 文章页是否显示標籤<br>    label: true               # true or false 显示描述性文字<br></code></pre></td></tr></table></figure><h5 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h5><p>為你的博客文章展示文章版权和许可协议。</p><p>修改主题配置文件&#x2F;themes&#x2F;butterfly&#x2F;_config.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">post_copyright:<br>  enable: true<br>  decode: false<br>  author_href:<br>  license: CC BY-NC-SA 4.0<br>  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/<br></code></pre></td></tr></table></figure><p>如果有文章（例如：转载文章）不需要显示，可以在文章Front-matter单独设置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">copyright: false<br></code></pre></td></tr></table></figure><p>从3.0.0开始，支持对单独文章设置版权信息，可以在文章Front-matter单独設置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">copyright_author: xxxx<br>copyright_author_href: https://xxxxxx.com<br>copyright_url: https://xxxxxx.com<br>copyright_info: 此文章版版权xxxxx所有，如有转载，请注明来自原作者<br></code></pre></td></tr></table></figure><h5 id="文章打赏"><a href="#文章打赏" class="headerlink" title="文章打赏"></a>文章打赏</h5><p>在你每篇文章的結尾，可以添加打賞按鈕。相關二維码可以自行配置。</p><p>對于沒有提供二維码的，可配置一張軟件的icon圖片，然後在link上添加相應的打賞鏈接。用户点擊圖片就会跳轉到鏈接去。</p><p>link可以不寫，会默认為圖片的鏈接。</p><p>修改 主題配置文件&#x2F;themes&#x2F;butterfly&#x2F;_config.yaml  建议把img相关二维码文件替换成自己的二维码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">reward:<br>  enable: true<br>  QR_code:<br>    - img: /img/wechat.jpg<br>      link:<br>      text: 微信<br>    - img: /img/alipay.jpg<br>      link:<br>      text: 支付宝<br></code></pre></td></tr></table></figure><h5 id="TOC显示"><a href="#TOC显示" class="headerlink" title="TOC显示"></a>TOC显示</h5><p>在文章页，会有一一个目录，用于显示TOC。修改主题配置文件&#x2F;themes&#x2F;butterfly&#x2F;_config.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">toc:<br>  post: true<br>  page: false<br>  number: true<br>  expand: false<br>  style_simple: false # for post <br></code></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>post</td><td>文章页是否显示 TOC</td></tr><tr><td>page</td><td>普通页面是否显示 TOC</td></tr><tr><td>number</td><td>是否显示章節數</td></tr><tr><td>expand</td><td>是否展开 TOC</td></tr><tr><td>style_simple</td><td>簡潔模式（側邊欄只显示 TOC, 只對文章页有效 ）</td></tr></tbody></table><h6 id="為特定的文章配置"><a href="#為特定的文章配置" class="headerlink" title="為特定的文章配置"></a>為特定的文章配置</h6><p>在你的文章md文件的頭部，加入toc_number和toc，並配置true或者false即可。</p><p>主題会優先判斷文章Ma</p><h5 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h5><p>相关文章推荐的原理是根据文章tags的比重来推荐</p><p>修改主題配置文件&#x2F;themes&#x2F;butterfly&#x2F;_config.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">related_post:<br>  enable: true<br>  limit: 6 # 显示推荐文章数目<br>  date_type: created # or created or updated 文章日期显示創建日或者更新日<br></code></pre></td></tr></table></figure><h5 id="文章錨点"><a href="#文章錨点" class="headerlink" title="文章錨点"></a>文章錨点</h5><p>开启文章錨点後，當你在文章页進行滾动時，文章鏈接会根據標題ID進行替換<br>(注意: 每替換一次，会留下一個歷史記錄。所以如果一篇文章有很多錨点的話，網页的歷史記錄会很多。)</p><p>修改 主題配置文件&#x2F;themes&#x2F;butterfly&#x2F;_config.yaml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># anchor<br># when you scroll in post , the url will update according to header id.<br>anchor: true<br></code></pre></td></tr></table></figure><h5 id="文章过期提醒"><a href="#文章过期提醒" class="headerlink" title="文章过期提醒"></a>文章过期提醒</h5><p>可設置是否显示文章过期提醒，以更新时间为基准。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Displays outdated notice for a post (文章過期提醒)<br>noticeOutdate:<br>  enable: true<br>  style: flat # style: simple/flat<br>  limit_day: 365 # When will it be shown<br>  position: top # position: top/bottom<br>  message_prev: It has been<br>  message_next: days since the last update, the content of the article may be outdated.<br><br>limit_day： 距離更新時間多少天才显示文章過期提醒<br>message_prev ： 天數之前的文字<br>message_next：天數之後的文字<br></code></pre></td></tr></table></figure><h5 id="文章编辑按钮"><a href="#文章编辑按钮" class="headerlink" title="文章编辑按钮"></a>文章编辑按钮</h5><p>在文章標題旁邊显示一個編輯按鈕，点擊会跳轉到對應的鏈接去，这里保持默认配置不设置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Post edit<br># Easily browse and edit blog source code online.<br>post_edit:<br>  enable: false<br>  # url: https://github.com/user-name/repo-name/edit/branch-name/subdirectory-name/<br>  # For example: https://github.com/jerryc127/butterfly.js.org/edit/main/source/<br>  url:<br><br></code></pre></td></tr></table></figure><h5 id="文章分页按钮"><a href="#文章分页按钮" class="headerlink" title="文章分页按钮"></a>文章分页按钮</h5><p>可设置分页的逻辑，也可以关闭分页显示，我这里设置的是1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># post_pagination (分页)<br># value: 1 || 2 || false<br># 1: The &#x27;next post&#x27; will link to old post  下一篇显示的是舊文章<br># 2: The &#x27;next post&#x27; will link to new post 下一篇显示的是新文章<br># false: disable pagination  关闭分页按鈕<br>post_pagination: 1<br><br></code></pre></td></tr></table></figure><h5 id="隐藏部分文章不在首页显示"><a href="#隐藏部分文章不在首页显示" class="headerlink" title="隐藏部分文章不在首页显示"></a>隐藏部分文章不在首页显示</h5><p>如果有些文章不想在主页显示，可以修改主题配置文件 themes&#x2F;butterfly&#x2F;layout&#x2F;includes&#x2F;mixins&#x2F;post-ui.pug</p><p>添加了if article.hide !&#x3D;&#x3D; true这一行，然后这一行后全部需要按下tab缩进一层。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">mixin postUI(posts)<br>  each article , index in page.posts.data<br>    if article.hide !== true<br>      .recent-post-item<br></code></pre></td></tr></table></figure><p>修改文章在md文件的头部信息中添加hide: true，示例如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">title: Hexo搭建个人博客<br>tags: Hexo<br>categories: Hexo<br>keywords: hexo<br>hide: true  #添加这个<br></code></pre></td></tr></table></figure><h5 id="复制相关配置"><a href="#复制相关配置" class="headerlink" title="复制相关配置"></a>复制相关配置</h5><p>可配置网站是否可以复制、复制的內容是否添加版权信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># copy settings<br># copyright: Add the copyright information after copied content (複製的內容後面加上版權信息)<br>copy:<br>  enable: true<br>  copyright:<br>    enable: true<br>    limit_count: 50<br><br>#enable 是否开启網站複製權限<br>#copyright複製的內容後面加上版權信息<br>#enable     是否开启複製版權信息添加<br>#limit_count字數限制，當複製文字大于這個字數限制時，將在複製的內容後面加上版權信息<br></code></pre></td></tr></table></figure><h5 id="Footer页尾设置"><a href="#Footer页尾设置" class="headerlink" title="Footer页尾设置"></a>Footer页尾设置</h5><h6 id="博客年份"><a href="#博客年份" class="headerlink" title="博客年份"></a>博客年份</h6><p>since是一个来展示你站点起始时间的选项。它位于页面的最底部。</p><p>修改 主題配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">footer:<br>  owner:<br>    enable: true<br>    since: 2018<br></code></pre></td></tr></table></figure><h6 id="页脚自定义文本"><a href="#页脚自定义文本" class="headerlink" title="页脚自定义文本"></a>页脚自定义文本</h6><p>custom_text是一個給你用来在页腳自定义文本的选项。通常你可以在这里声明文本等。支持 HTML。</p><p>修改主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">custom_text: Hi, welcome to my &lt;a href=&quot;https://butterfly.js.org/&quot;&gt;blog&lt;/a&gt;!<br></code></pre></td></tr></table></figure><h6 id="页面底部-footer跳动的心"><a href="#页面底部-footer跳动的心" class="headerlink" title="页面底部 footer跳动的心"></a>页面底部 footer跳动的心</h6><p>编辑&#x2F;themes&#x2F;butterfly&#x2F;layout&#x2F;includes&#x2F;footer.pug文件</p><p>将以下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&amp;copy;$&#123;theme.footer.owner.since&#125; - $&#123;nowYear&#125; By $&#123;config.author&#125;<br></code></pre></td></tr></table></figure><p>改为:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&amp;copy;$&#123;theme.footer.owner.since&#125; - $&#123;nowYear + &#x27; &#x27;&#125; &lt;i id=&quot;heartbeat&quot; class=&quot;fa fas fa-heartbeat&quot;&gt;&lt;/i&gt; $&#123;config.author&#125;<br></code></pre></td></tr></table></figure><p>将以下内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&amp;copy;$&#123;nowYear&#125; By $&#123;config.author&#125; <br></code></pre></td></tr></table></figure><p>改为:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&amp;copy;$&#123;nowYear + &#x27; &#x27;&#125; &lt;i id=&quot;heartbeat&quot; class=&quot;fa fas fa-heartbeat&quot;&gt;&lt;/i&gt; $&#123;config.author&#125;<br></code></pre></td></tr></table></figure><p>将以下内容添加到 <head></head>标签内：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css&quot;&gt;<br></code></pre></td></tr></table></figure><h5 id="右下角按钮"><a href="#右下角按钮" class="headerlink" title="右下角按钮"></a>右下角按钮</h5><h6 id="简繁转换"><a href="#简繁转换" class="headerlink" title="简繁转换"></a>简繁转换</h6><p>简体繁体互换，右下角会有简繁转换按鈕。</p><p>修改主题的配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Conversion between Traditional and Simplified Chinese (简繁转换)<br>translate:<br>  enable: true    # 2022 默认false<br>  # The text of a button<br>  default: 简<br>  # the language of website (1 - Traditional Chinese/ 2 - Simplified Chinese）<br>  defaultEncoding: 1<br>  # Time delay<br>  translateDelay: 0<br>  # The text of the button when the language is Simplified Chinese<br>  msgToTraditionalChinese: &#x27;繁&#x27;<br>  # The text of the button when the language is Traditional Chinese<br>  msgToSimplifiedChinese: &#x27;简&#x27;<br></code></pre></td></tr></table></figure><h6 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a>夜间模式</h6><p>右下角会有夜间模式按钮，修改主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># dark mode<br>darkmode:<br>  enable: true<br>  # dark mode和 light mode切换按钮<br>  button: true<br>  autoChangeMode: false<br></code></pre></td></tr></table></figure><h6 id="阅读模式"><a href="#阅读模式" class="headerlink" title="阅读模式"></a>阅读模式</h6><p>阅读模式下会去掉除文章外的内容，避免干扰阅读。只会出现在文章页面，右下角会有阅读模式按钮。</p><p>修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Read Mode (阅读模式)<br>readmode: true<br></code></pre></td></tr></table></figure><h6 id="按钮排序"><a href="#按钮排序" class="headerlink" title="按钮排序"></a>按钮排序</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Don&#x27;t modify the following settings unless you know how they work (非必要请不要修改 )<br># Choose: readmode,translate,darkmode,hideAside,toc,chat,comment<br># Don&#x27;t repeat 不要重复<br>rightside_item_order:<br>  enable: false<br>  hide: # readmode,translate,darkmode,hideAside<br>  show: # toc,chat,comment<br></code></pre></td></tr></table></figure><h5 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h5><h6 id="侧边排版"><a href="#侧边排版" class="headerlink" title="侧边排版"></a>侧边排版</h6><p>可自行决定哪个项目需要显示，可决定位置，也可以设置不显示侧边栏。</p><p>修改主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">aside:<br>  enable: true<br>  hide: true<br>  button: true<br>  mobile: true # display on mobile<br>  position: right # left or right<br>  display:<br>    archive: true<br>    tag: true<br>    category: true<br>  card_author:<br>    enable: true<br>    description:<br>    button:<br>      enable: true<br>      icon: iconfont icon-CSDN           #fab fa-github<br>      text: My Blog<br>      link: https://blog.chen1900s.cn/<br>  card_announcement:<br>    enable: true<br>    content: 刚开始写博客，欢迎大家来吐槽<br>  card_recent_post:<br>    enable: true<br>    limit: 5 # if set 0 will show all<br>    sort: date # date or updated<br>    sort_order: # Don&#x27;t modify the setting unless you know how it works<br>  card_categories:<br>    enable: true<br>    limit: 8 # if set 0 will show all<br>    expand: none # none/true/false<br>    sort_order: # Don&#x27;t modify the setting unless you know how it works<br>  card_tags:<br>    enable: true<br>    limit: 40 # if set 0 will show all<br>    color: false<br>    sort_order: # Don&#x27;t modify the setting unless you know how it works<br>  card_archives:<br>    enable: true<br>    type: monthly # yearly or monthly<br>    format: MMMM YYYY # eg: YYYY年MM月<br>    order: -1 # Sort of order. 1, asc for ascending; -1, desc for descending<br>    limit: 8 # if set 0 will show all<br>    sort_order: # Don&#x27;t modify the setting unless you know how it works<br>  card_webinfo:<br>    enable: true<br>    post_count: true<br>    last_push_date: true<br>    sort_order: # Don&#x27;t modify the setting unless you know how it works<br></code></pre></td></tr></table></figure><h6 id="访问人数-UV-和-PV"><a href="#访问人数-UV-和-PV" class="headerlink" title="访问人数(UV 和 PV)"></a>访问人数(UV 和 PV)</h6><p>访问 busuanzi 的官方网站查看更多的介绍，修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">busuanzi:<br>  site_uv: true<br>  site_pv: true<br>  page_pv: true<br></code></pre></td></tr></table></figure><h6 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h6><p>网页已运行时间</p><p>修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">runtimeshow:<br>  enable: true   #默认false<br>  publish_date: 9/9/2018 00:00:00<br>  ##网页开通时间<br>  #格式: 月/日/年 时间<br>  #也可以写成 年/月/日 时间<br></code></pre></td></tr></table></figure><h6 id="最新评论"><a href="#最新评论" class="headerlink" title="最新评论"></a>最新评论</h6><blockquote><p>最新评论只会在刷新时才会去读取，并不会实时变化</p><p>由于 API 有 访问次数限制，为了避免调用太多，主题默认存取期限为 10 分鐘。也就是説，调用后资料会存在 localStorage 里，10分鐘内刷新网站只会去 localStorage 读取资料。 10 分鐘期限一过，刷新页面时才会去调取 API 读取新的数据。（ 3.6.0 新增了 storage 配置，可自行配置缓存时间）</p></blockquote><p>在侧边栏显示最新评论板块</p><p>修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Aside widget - Newest Comments<br>newest_comments:<br>  enable: true<br>  sort_order: # Don&#x27;t modify the setting unless you know how it works<br>  limit: 6<br>  storage: 10 # unit: mins, save data to localStorage<br>  avatar: true<br></code></pre></td></tr></table></figure><h6 id="自定义添加栏目"><a href="#自定义添加栏目" class="headerlink" title="自定义添加栏目"></a>自定义添加栏目</h6><p>标签外挂（Tag Plugins）</p><blockquote><p>标签外挂是Hexo独有的功能，并不是标準的Markdown格式。</p><p>以下的写法，只适用于Butterfly主题，用在其它主题上不会有效果，甚至可能会报错。使用前请留意</p></blockquote><h6 id="Follow-me信息修改"><a href="#Follow-me信息修改" class="headerlink" title="Follow me信息修改"></a>Follow me信息修改</h6><p>在主题配置文件修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">card_author:<br>  enable: true<br>  description:<br>  button:<br>    enable: true<br>    icon: fab fa-github<br>    text: my blog<br>    link: https://chen1900s.github.io/<br></code></pre></td></tr></table></figure><h6 id="公告信息"><a href="#公告信息" class="headerlink" title="公告信息"></a>公告信息</h6><p>在主题配置文件修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">card_announcement:<br>    enable: true<br>    content: This is my Blog  #修改此处<br></code></pre></td></tr></table></figure><h5 id="在线聊天"><a href="#在线聊天" class="headerlink" title="在线聊天"></a>在线聊天</h5><p>从3.0开始，Butterfly主题内置了多种在线聊天工具。你可以选择开启一种，方便你与访客的交流。这些工具都提供了一个按钮可以打开&#x2F;关闭聊天窗口。<br>主题也提供了一个集合主题特色的按钮来替换这些工具本身的按钮，这个聊天按钮将会出现在右下角里。<br>你只需要把chat_btn打开就行。</p><p>修改主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Chat Button [recommend]<br># It will create a button in the bottom right corner of website, and hide the origin button<br>chat_btn: true  默认false<br></code></pre></td></tr></table></figure><p>为了不影响访客的体验，主题提供一个chat_hide_show配置，设为true后，使用工具提供的按钮时，只有向上滚动才会显示聊天按钮，向下滚动时会隐藏按钮。</p><p>修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># The origin chat button is displayed when scrolling up, and the button is hidden when scrolling down<br>chat_hide_show: true<br></code></pre></td></tr></table></figure><h5 id="分享功能"><a href="#分享功能" class="headerlink" title="分享功能"></a>分享功能</h5><blockquote><p>只能选择一个分享服务商</p></blockquote><p>可以到addtoany查看使用説明</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">sharejs:<br>  enable: true<br>  sites: facebook,twitter,wechat,weibo,qq  #想要显示的内容<br></code></pre></td></tr></table></figure><h5 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h5><blockquote><p>记得运行 hexo clean</p></blockquote><p>你需要安装 hexo-generator-search，根据它的文档去做相应配置</p><p>修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install  hexo-generator-search  --save<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">local_search:<br>  enable: true<br>  labels:<br>    input_placeholder: Search for Posts<br>    hits_empty: &quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot; # 如果没有查到内容相关内容显示<br></code></pre></td></tr></table></figure><p>你需要安装 hexo-algolia或 hexo-algoliasearch. 根据它们的説明文档去做相应的配置。</p><p>修改主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">algolia_search:<br>  enable: true <br>  hits:<br>    per_page: 6<br></code></pre></td></tr></table></figure><h6 id="分割线图标更换"><a href="#分割线图标更换" class="headerlink" title="分割线图标更换"></a>分割线图标更换</h6><p>将图标更换为“太空飞船”。</p><p>修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hr_icon:<br>  enable: true<br>  icon: &#x27;\f197&#x27; # the unicode value of Font Awesome icon, such as &#x27;\3423&#x27;<br>  icon-top: -10px<br></code></pre></td></tr></table></figure><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/image-20220823130546940.png" alt="image-20220823130546940"></p><h5 id="广告设置"><a href="#广告设置" class="headerlink" title="广告设置"></a>广告设置</h5><p>主题已集成谷歌广告（自动广告）</p><p>修改主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Google Adsense (谷歌广告)<br>google_adsense:<br>  enable: false<br>  auto_ads: true<br>  js: https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js<br>  client:<br>  enable_page_level_ads: true<br><br></code></pre></td></tr></table></figure><h5 id="美化-x2F-特效"><a href="#美化-x2F-特效" class="headerlink" title="美化&#x2F;特效"></a>美化&#x2F;特效</h5><h6 id="自定义主题色"><a href="#自定义主题色" class="headerlink" title="自定义主题色"></a>自定义主题色</h6><p>可以修改大部分UI颜色</p><p>修改 主题配置文件，比如：</p><blockquote><p>颜色值必须被双引号包裹，就像”#000”而不是#000。否则将会在构建的时候报错，我这里保持默认配置不做修改</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># theme_color:<br>#   enable: true<br>#   main: &quot;#49B1F5&quot;<br>#   paginator: &quot;#00c4b6&quot;<br>#   button_hover: &quot;#FF7242&quot;<br>#   text_selection: &quot;#00c4b6&quot;<br>#   link_color: &quot;#99a9bf&quot;<br>#   meta_color: &quot;#858585&quot;<br>#   hr_color: &quot;#A4D8FA&quot;<br>#   code_foreground: &quot;#F47466&quot;<br>#   code_background: &quot;rgba(27, 31, 35, .05)&quot;<br>#   toc_color: &quot;#00c4b6&quot;<br>#   blockquote_padding_color: &quot;#49b1f5&quot;<br>#   blockquote_background_color: &quot;#49b1f5&quot;<br>#   scrollbar_color: &quot;#49b1f5&quot;<br>#   meta_theme_color_light: &quot;ffffff&quot;<br>#   meta_theme_color_dark: &quot;#0d0d0d&quot;<br><br></code></pre></td></tr></table></figure><h6 id="页面背景"><a href="#页面背景" class="headerlink" title="页面背景"></a>页面背景</h6><p>默认显示白色，可设置图片或者颜色 修改主题配置文件<code>_config.yml</code>：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># The formal of image: url(http://xxxxxx.com/xxx.jpg)<br>background: &#x27;#efefef&#x27;   #默认留空的<br></code></pre></td></tr></table></figure><p>可以自定义</p><p>在<code>\Butterfly\source\css\</code>目录下创建css文件 <code>backgound.css</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#web_bg &#123;<br>  background: -webkit-linear-gradient(<br>    0deg,<br>    rgba(247, 149, 51, 0.1) 0,<br>    rgba(243, 112, 85, 0.1) 15%,<br>    rgba(239, 78, 123, 0.1) 30%,<br>    rgba(161, 102, 171, 0.1) 44%,<br>    rgba(80, 115, 184, 0.1) 58%,<br>    rgba(16, 152, 173, 0.1) 72%,<br>    rgba(7, 179, 155, 0.1) 86%,<br>    rgba(109, 186, 130, 0.1) 100%<br>  );<br>  background: -moz-linear-gradient(<br>    0deg,<br>    rgba(247, 149, 51, 0.1) 0,<br>    rgba(243, 112, 85, 0.1) 15%,<br>    rgba(239, 78, 123, 0.1) 30%,<br>    rgba(161, 102, 171, 0.1) 44%,<br>    rgba(80, 115, 184, 0.1) 58%,<br>    rgba(16, 152, 173, 0.1) 72%,<br>    rgba(7, 179, 155, 0.1) 86%,<br>    rgba(109, 186, 130, 0.1) 100%<br>  );<br>  background: -o-linear-gradient(<br>    0deg,<br>    rgba(247, 149, 51, 0.1) 0,<br>    rgba(243, 112, 85, 0.1) 15%,<br>    rgba(239, 78, 123, 0.1) 30%,<br>    rgba(161, 102, 171, 0.1) 44%,<br>    rgba(80, 115, 184, 0.1) 58%,<br>    rgba(16, 152, 173, 0.1) 72%,<br>    rgba(7, 179, 155, 0.1) 86%,<br>    rgba(109, 186, 130, 0.1) 100%<br>  );<br>  background: -ms-linear-gradient(<br>    0deg,<br>    rgba(247, 149, 51, 0.1) 0,<br>    rgba(243, 112, 85, 0.1) 15%,<br>    rgba(239, 78, 123, 0.1) 30%,<br>    rgba(161, 102, 171, 0.1) 44%,<br>    rgba(80, 115, 184, 0.1) 58%,<br>    rgba(16, 152, 173, 0.1) 72%,<br>    rgba(7, 179, 155, 0.1) 86%,<br>    rgba(109, 186, 130, 0.1) 100%<br>  );<br>  background: linear-gradient(<br>    90deg,<br>    rgba(247, 149, 51, 0.1) 0,<br>    rgba(243, 112, 85, 0.1) 15%,<br>    rgba(239, 78, 123, 0.1) 30%,<br>    rgba(161, 102, 171, 0.1) 44%,<br>    rgba(80, 115, 184, 0.1) 58%,<br>    rgba(16, 152, 173, 0.1) 72%,<br>    rgba(7, 179, 155, 0.1) 86%,<br>    rgba(109, 186, 130, 0.1) 100%<br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>修改配置文件<code>_config.yml</code>的引入方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">inject:<br>  head:<br>     - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/background.css&quot;&gt;<br>  bottom:<br></code></pre></td></tr></table></figure><p>如果背景色不生效，设置<code>_config.yml</code>，需将background:设置成#efefef</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># The formal of image: url(http://xxxxxx.com/xxx.jpg)<br>background: &#x27;#efefef&#x27;<br></code></pre></td></tr></table></figure><h6 id="鼠标点击特效"><a href="#鼠标点击特效" class="headerlink" title="鼠标点击特效"></a>鼠标点击特效</h6><p>修改主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Mouse click effects: fireworks (鼠标点击效果: 煙火特效)<br>fireworks:<br>  enable: false<br>  zIndex: 9999 # -1 or 9999<br>  mobile: false<br><br># Mouse click effects: Heart symbol (鼠標點擊效果: 愛心)<br>click_heart:<br>  enable: false<br>  mobile: false<br><br># Mouse click effects: words (鼠標點擊效果: 文字)<br>ClickShowText:<br>  enable: false<br>  text:<br>    # - I<br>    # - LOVE<br>    # - YOU<br>  fontSize: 15px<br>  random: false<br>  mobile: false<br></code></pre></td></tr></table></figure><h6 id="打字特效"><a href="#打字特效" class="headerlink" title="打字特效"></a>打字特效</h6><p>修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Typewriter Effect (打字效果)<br># https://github.com/disjukr/activate-power-mode<br>activate_power_mode:<br>  enable: false<br>  colorful: true # open particle animation (冒光特效)<br>  shake: true #  open shake (抖动特效)<br>  mobile: false<br></code></pre></td></tr></table></figure><h6 id="页面背景特效"><a href="#页面背景特效" class="headerlink" title="页面背景特效"></a>页面背景特效</h6><p>有三种，根据自己喜好选择开启，将<code>enable</code>设置为true就可以</p><blockquote><p>静态彩带</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># canvas_ribbon (靜止彩帶背景)<br># See: https://github.com/hustcc/ribbon.js<br>canvas_ribbon:<br>  enable: false<br>  size: 150<br>  alpha: 0.6<br>  zIndex: -1<br>  click_to_change: true<br>  mobile: true<br> #点击页面，彩带会进行变化。<br></code></pre></td></tr></table></figure><blockquote><p>动态彩带</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Fluttering Ribbon (动態彩帶)<br>canvas_fluttering_ribbon:<br>  enable: true<br>  mobile: true<br>  <br>#这个彩带可以动态变换<br></code></pre></td></tr></table></figure><blockquote><p>自动吸附</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># canvas_nest<br># https://github.com/hustcc/canvas-nest.js<br>canvas_nest:<br>  enable: false<br>  color: &#x27;0,0,255&#x27; #线条颜色, default: &#x27;0,0,0&#x27;; <br>  opacity: 0.7 # 线条的不透明度 (0~1), default: 0.5.<br>  zIndex: -1 # z-index property of the background, default: -1.<br>  count: 99 # 线条数量, default: 99.<br>  mobile: false<br></code></pre></td></tr></table></figure><h6 id="Snackbar-弹窗"><a href="#Snackbar-弹窗" class="headerlink" title="Snackbar 弹窗"></a>Snackbar 弹窗</h6><p>修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Snackbar (Toast Notification 彈窗)<br># position 彈窗位置<br># 可選 top-left / top-center / top-right / bottom-left / bottom-center / bottom-right<br>snackbar:<br>  enable: false  #默认就是false<br>  position: top-right<br>  bg_light: &#x27;#49b1f5&#x27; # light 背景下的样式<br>  bg_dark: &#x27;#121212&#x27; # dark 背景下的样式<br>  <br>#开启后，在你设置的位置会有可爱的小弹窗出现<br></code></pre></td></tr></table></figure><h6 id="底部设置"><a href="#底部设置" class="headerlink" title="底部设置"></a>底部设置</h6><p>修改主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Footer Settings<br># --------------------------------------<br>footer:<br>  owner:<br>    enable: true<br>    since: 2018<br>  custom_text: welcome to my &lt;a href=&quot;https://blog.chen1900s.cn&quot;&gt;blog&lt;/a&gt;!<br>  copyright: false # Copyright of theme and framework 默认为true<br>  ICP: # Chinese ICP License   #最后一句<br>    enable: true<br>    url: http://www.beian.gov.cn<br>    text: 豫ICP备20001029号<br>    icon: /img/icp.png<br></code></pre></td></tr></table></figure><h5 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h5><p>开启评论需要在<code>butterfly.yml</code>—<code>comments</code>—<code>use</code>中填写你需要的评论。</p><p>支持<code>双评论显示</code>，只需要配置两个评论（第一个为<code>默认</code>显示）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">comments:<br>  use:<br>   - Valine<br>  # - Disqus    <br>  text: true <br>  lazyload: false<br>  count: false <br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>use</td><td>使用的评论（填写的评论首字母需要大写。最多支持两个，不需要就留空）</td></tr><tr><td>text</td><td>是否显示评论服务商的名字</td></tr><tr><td>lazyload</td><td>是否为评论开启lazyload，开启后，只有滚动到评论位置时才会加载评论所需要的资源（开启lazyload后，评论数将不显示）</td></tr><tr><td>count</td><td>是否在文章顶部显示评论数</td></tr></tbody></table><p><code>注意</code>：双评论不能是<code>Disqus</code> 和<code>Disqusjs</code> 一起，由于其共用同一个 <code>ID</code>，会出错。</p><p>以下是举例的我在用的：<code>Valine</code></p><p>1.在<a href="https://leancloud.cn/dashboard/login.html#/signin">LeanCloud</a>中注册账号，并进入。</p><p>2.创建应用</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/image-20220823175230964.png" alt="image-20220823175230964"></p><p>3.创建成功后，进入<code>设置</code></p><p>4.进入<code>应用Keys</code></p><p><code>应用Keys</code>中有<code>AppID</code>和<code>AppKey</code>，这两个需要填写到你的<code>butterfly.yml</code>中</p><p>5.修改 主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># valine<br># https://valine.js.org<br>valine:<br>  appId:              #  app id<br>  appKey:              # app key<br>  pageSize: 10<br>  avatar: monsterid <br>  lang: zh-CN <br>  placeholder: Please leave your footprints p<br>  guest_info: nick,mail,link <br>  recordIP: true <br>  serverURLs: <br>  bg: <br>  emojiCDN: <br>  enableQQ: true <br>  requiredFields: nick,mail<br></code></pre></td></tr></table></figure><h5 id="音乐Aplayer"><a href="#音乐Aplayer" class="headerlink" title="音乐Aplayer"></a>音乐Aplayer</h5><h6 id="安装-hexo-tag-aplayer-插件"><a href="#安装-hexo-tag-aplayer-插件" class="headerlink" title="安装 hexo-tag-aplayer 插件"></a>安装 hexo-tag-aplayer 插件</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install --save hexo-tag-aplayer<br></code></pre></td></tr></table></figure><p>关闭 asset_inject</p><p>由于需要全局都插入 aplayer 和 meting 资源，为了防止插入重复的资源，需要把 asset_inject 设为 false</p><h6 id="在-Hexo-的配置文件中"><a href="#在-Hexo-的配置文件中" class="headerlink" title="在 Hexo 的配置文件中"></a>在 Hexo 的配置文件中</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">aplayer:<br>  meting: true<br>  asset_inject: false<br></code></pre></td></tr></table></figure><h6 id="开启主题的-aplayerInject"><a href="#开启主题的-aplayerInject" class="headerlink" title="开启主题的 aplayerInject"></a>开启主题的 aplayerInject</h6><p>在主题的配置文件中，enable 设为 true 和 per_page 设为 true</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Inject the css and script (aplayer/meting)<br>aplayerInject:<br>  enable: true<br>  per_page: true<br></code></pre></td></tr></table></figure><p>插入 Aplayer html为了适配 hexo-tag-aplayer，主题内置的 Meting js 仍为 1.2 版本，并非最新的 2.x 版本。</p><p>Aplayer html 例子：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;7607717868&quot; data-server=&quot;netease&quot; data-type=&quot;playlist&quot; data-fixed=&quot;true&quot; data-mini=&quot;true&quot; data-listFolded=&quot;false&quot; data-order=&quot;random&quot; data-lrctype=&quot;1&quot; data-preload=&quot;none&quot; data-autoplay=&quot;false&quot; muted&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>把 aplayer代码 插入到主题配置文件的 inject.bottom 去</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">inject:<br>  head:<br>  bottom:<br>       - &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;7607717868&quot; data-server=&quot;netease&quot; data-type=&quot;playlist&quot; data-fixed=&quot;true&quot; data-mini=&quot;true&quot; data-listFolded=&quot;false&quot; data-order=&quot;random&quot; data-lrctype=&quot;1&quot; data-preload=&quot;none&quot; data-autoplay=&quot;false&quot; muted&gt;&lt;/div&gt;<br><br></code></pre></td></tr></table></figure><p>运行 Hexo 就可以看到网页左下角出现了 Aplayer</p><p>最后，如果你想切换页面时，音乐不会中断。请把主题配置文件的 pjax 设为 true</p><p>音乐页面也显示播放列表，可以直接在&#x2F;source&#x2F;music&#x2F;目录下的index.md 里面填入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">---<br>title: 音乐<br>date: 2018-08-24 11:06:40<br>type: music<br>---<br>&#123;% meting &quot;7607717868&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#ad7a86&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125;<br></code></pre></td></tr></table></figure><h5 id="电影movies"><a href="#电影movies" class="headerlink" title="电影movies"></a>电影movies</h5><p>电影界面使用了插件 hexo-butterfly-douban，使用方法请参考插件的文档。</p><blockquote><p><a href="https://github.com/jerryc127/butterfly-plugins/tree/main/hexo-butterfly-douban">hexo-butterfly-douban介绍</a>   </p></blockquote><h6 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install hexo-butterfly-douban --save<br></code></pre></td></tr></table></figure><h6 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h6><p>將下面的配置寫入站點的配置文件 <code>_config.yml</code> 里(不是主題的配置文件).</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">##电影<br>douban:<br>  user: 261805469<br>  builtin: true<br>  book:<br>    title: &#x27;书籍&#x27;<br>    quote: &#x27;读书不是为了拿文凭或者发财，而是成为一个温度，有情趣，会思考的人！&#x27;<br>    meta: true<br>    comments: true<br>    top_img: https://cccccc.png<br>    aside: true<br>    path: book<br>    limit:<br>  movie:<br>    title: &#x27;电影&#x27;<br>    quote: &#x27;一杯奶茶，一个人，一张票，一场电影&#x27;<br>    meta: true<br>    comments: true<br>    top_img: https://cccccc.png<br>    aside: true<br>    path: movies<br>    limit:<br>  game:<br>    title: &#x27;游戏&#x27;<br>    quote: &#x27;不好意思，目前还没有找到好玩的游戏，有推荐的吗&#x27;<br>    meta: true<br>    comments: true<br>    top_img: https://cccccc.png<br>    aside: true<br>    path: game<br>    limit:<br>  timeout: 10000<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建个人博客</title>
      <link href="/post/ec7d7221.html"/>
      <url>/post/ec7d7221.html</url>
      
        <content type="html"><![CDATA[<p><strong>简单介绍</strong></p><blockquote><p>一直想拥有一个属于自己的博客主站，便于记录平时工作中遇到一技术问题 或是生活琐事，于是在网上搜索了如何搭建博客，了解到hexo使用的人还挺多，那就行动起来，在网上一边搜教程一边搭建，本站是基于Hexo+butterfly 的，感谢网上各种前辈的分享，让我学习了很多</p></blockquote><h2 id="Hexo基本搭建"><a href="#Hexo基本搭建" class="headerlink" title="Hexo基本搭建"></a>Hexo基本搭建</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。一个命令即可部署到 Github页面、 Giteee、 Heroku等平台，强大的APl,可无限扩展,拥有数百个主题和插件供用户自主安装 </p><blockquote><p><a href="https://hexo.io/zh-cn/docs/">hexo官方文档</a></p></blockquote><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><blockquote><p>(Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本</p></blockquote><p>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/en/download/">安装程序</a>。对于国内用户，可以前往 <a href="https://npm.taobao.org/mirrors/node">淘宝 Node.js 镜像</a> 下载 </p><ul><li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者 <a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li><li>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="http://www.macports.org/">MacPorts</a> 安装。</li><li>Linux（DEB&#x2F;RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li><li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a href="https://nodejs.org/en/download/package-manager/">指导</a>。</li></ul><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><p>也可以使用cnpm</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install -g cnpm --registry=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>以上安装前提的应用程序安装完成后，就可以使用npm进行安装</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install -g hexo-cli  #或者： cnpm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>查看是否安装成功和对应安装的版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo -v<br>#若有正常版本输出表示安装成功<br></code></pre></td></tr></table></figure><h3 id="搭建博客主站"><a href="#搭建博客主站" class="headerlink" title="搭建博客主站"></a>搭建博客主站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo init myblog<br></code></pre></td></tr></table></figure><p>初始化完后，切换到博客主目录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">cd  myblog<br>npm install   #或者cnpm install<br></code></pre></td></tr></table></figure><p>查看当前目录文件</p><blockquote><p>_config.landscape.yml<br>themes                   #主题文件夹。Hexo 会根据主题来生成静态页面。<br>scaffolds                #模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>source                   # 资源文件夹是存放用户资源的地方<br>public<br>package-lock.json<br>package.json             #应用程序信息<br>_config.yml               #网站配置信息，后续主站配置需要在这个配置文件进行修改<br>db.json<br>node_modules<br>.deploy_git<br>.github</p></blockquote><h3 id="启动服务站点"><a href="#启动服务站点" class="headerlink" title="启动服务站点"></a>启动服务站点</h3><p>hexo 三板斧命令 启动服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo cl    #完整命令是hexo clean   清理缓存文件<br>hexo g     #hexo generate    用于生成静态文件<br>hexo s     #hexo server     命令用于启动本地服务<br></code></pre></td></tr></table></figure><p>正常输出表示启动成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">INFO  Validating config<br>INFO <br>  ===================================================================<br><br>      #####  #    # ##### ##### ###### #####  ###### #      #   #<br>      #    # #    #   #     #   #      #    # #      #       # #<br>      #####  #    #   #     #   #####  #    # #####  #        #<br>      #    # #    #   #     #   #      #####  #      #        #<br>      #    # #    #   #     #   #      #   #  #      #        #<br>      #####   ####    #     #   ###### #    # #      ######   #<br><br>                            4.4.0<br>  ===================================================================<br>INFO  Start processing<br>INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.<br><br></code></pre></td></tr></table></figure><p>然后通过  <a href="http://localhost:4000/">http://localhost:4000/</a>   可以正常访问（使用的是默认主题）</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/1660970724356.png" alt="1660970724356"></p><h3 id="GitHub上建站访问"><a href="#GitHub上建站访问" class="headerlink" title="GitHub上建站访问"></a>GitHub上建站访问</h3><p>将 Hexo 博客部署到 GitHub Pages 上，如果还没有github账号的，需要先去注册账号，具体如何注册，这里就不做介绍了，</p><h4 id="新建github仓库"><a href="#新建github仓库" class="headerlink" title="新建github仓库"></a>新建github仓库</h4><p>仓库名称限制了为你的：用户名+.github.io。我这里使用的是我自己用户名 chen1900s</p><p><img src="https://chen1900s-1257020962.cos.ap-chongqing.myqcloud.com/my-blog/image/image-20220831181326723.png" alt="image-20220831181326723"></p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git init<br>git add README.md<br>git commit -m &quot;first commit&quot;<br>git branch -M main<br>git remote add origin https://github.com/chen1900s/chen1900s.github.io.git<br>git push -u origin main<br>#已有仓库<br>git remote add origin https://github.com/chen1900s/chen1900s.github.io.git<br>git branch -M main<br>git push -u origin main<br></code></pre></td></tr></table></figure></blockquote><h4 id="推送站点到github"><a href="#推送站点到github" class="headerlink" title="推送站点到github"></a>推送站点到github</h4><p>1，安装hexo上传插件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install hexo-deployer-git --save<br>或者<br>cnpm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>2，修改hexo配置文件指定仓库路径</p><p>可在hexo博客主目录文件夹中直接打开文件，也可通过vim直接编辑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">vim _config.yml <br>#找到<br>deploy:<br>  type: git<br>  repo: https://github.com/chen1900s/chen1900s.github.io.git<br>  branch: master <br></code></pre></td></tr></table></figure><p>3，运行命令（执行命令时候需要在博客主目录执行）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy`<br></code></pre></td></tr></table></figure><blockquote><p>需要配置github ssh公私钥访问 </p></blockquote><h4 id="主站访问"><a href="#主站访问" class="headerlink" title="主站访问"></a>主站访问</h4><p>输入你的仓库名称,即可访问成功。</p><p>https:&#x2F;&#x2F; username.github.io  </p><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>创建 Hexo 主题非常容易，您只要在 <code>themes</code> 文件夹内，新增一个任意名称的文件夹，并修改 <code>_config.yml</code> 内的 <code>theme</code> 设定，即可切换主题。</p><p>到GitHub上搜索hexo主题或者hero自带的主题<a href="https://hexo.io/themes/%E3%80%82">https://hexo.io/themes/。</a></p><p>这里我选择butterfly 主题进行配置</p><blockquote><p><a href="https://butterfly.js.org/">butterfly 官方主题</a></p></blockquote><p>按照各自的主题文档上面一步步操作即可。</p><p> 一般步骤： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1、下载解压主题 或者使用命令行<br>2、放到主题包themes文件夹下面<br>3、在hero配置文件_config.yml中修改为喜欢主题的名字<br>4、hero server启动即可访问<br></code></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>在你的<strong>Hexo 根目</strong>录里执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly<br></code></pre></td></tr></table></figure><p>或者手动下载下来 上传到博客根目录</p><h4 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h4><p>修改 <strong>Hexo 根目录</strong>下的 _config.yml，把主题改为butterfly</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Extensions<br>## Plugins: https://hexo.io/plugins/<br>## Themes: https://hexo.io/themes/<br>theme: butterfly     <br></code></pre></td></tr></table></figure><p>修改完成后，重启服务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#1，清理<br>hexo clean<br>#2 构建静态文件<br>hexo g<br>#3，上传至仓库<br>hexo deploy<br></code></pre></td></tr></table></figure><h4 id="创建博客文章"><a href="#创建博客文章" class="headerlink" title="创建博客文章"></a>创建博客文章</h4><p>在<strong>Hexo根目录</strong>文件夹中打开终端 ，输入如下命令创建文章，hexo会在source文件夹下创建一个markdowm的文件。这就是你要编写的文章。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo new “这里填入文章的标题”<br></code></pre></td></tr></table></figure><p> 用软件typora打开直接编写文章 ， 在上传更新到github上立马能够查看到。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#1，清理<br>hexo clean<br>#2 构建静态文件<br>hexo g<br>#3，上传至仓库<br>hexo deploy<br></code></pre></td></tr></table></figure><p>草稿箱</p><blockquote><p>有时候我们需要先写成草稿，而暂时不发布出去。draft page就可以满足我们的要求，我们的网站上是看不到草稿文件的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//新建草稿文件<br>hexo new draft b<br><br>//预览草稿文件<br>hexo server --draft<br><br>//发布草稿hexo publish <br></code></pre></td></tr></table></figure><h4 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h4><p>有时我们不满足主题自由的一些页面，希望自己添加一些标题页面。</p><p>我们可以新建页面，新建页面则会在hexo的source中新建该页面文件并生成md文件，这就是你要编辑的博客页了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">hexo new page &quot;resouces&quot;<br></code></pre></td></tr></table></figure><p>然后打开主题的配置文件<code>_config.yml</code>，在菜单属性<code>menu</code>中的添加如下（注意不是Hexo的配置文件）</p><p>将页面路径联接到页面上去</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">菜单自定义名称：/生成的页面名称<br></code></pre></td></tr></table></figure><p>具体见我下一篇文章的<a href="https://blog.chen1900s.cn/post/e56702c9.html">butterfly主题优化</a></p><p><strong>写在最后</strong></p><p>感谢占用您的时间阅读，如果有不对的地方随时吐槽</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
